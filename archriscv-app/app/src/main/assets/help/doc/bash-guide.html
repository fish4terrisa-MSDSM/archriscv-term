<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML
><HEAD
><TITLE
>Bash Guide for Beginners</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.7"><META
NAME="KEYWORD"
CONTENT="Linux"><META
NAME="KEYWORD"
CONTENT="Scripts"><META
NAME="KEYWORD"
CONTENT="linux"><META
NAME="KEYWORD"
CONTENT="Bash"><META
NAME="KEYWORD"
CONTENT="guide"><META
NAME="KEYWORD"
CONTENT="Guide"><META
NAME="KEYWORD"
CONTENT="Exercises"><META
NAME="KEYWORD"
CONTENT="exercises"><META
NAME="KEYWORD"
CONTENT="bash"><META
NAME="KEYWORD"
CONTENT="scripting"><META
NAME="KEYWORD"
CONTENT="Scripting"><META
NAME="KEYWORD"
CONTENT="awk"><META
NAME="KEYWORD"
CONTENT="sed"><META
NAME="KEYWORD"
CONTENT="variables"><META
NAME="KEYWORD"
CONTENT="functions"><META
NAME="KEYWORD"
CONTENT="loops"><META
NAME="KEYWORD"
CONTENT="conditionals"></HEAD
><BODY
CLASS="book"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="BOOK"
><A
NAME="AEN1"
></A
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="title"
><A
NAME="AEN2"
></A
>Bash Guide for Beginners</H1
><H3
CLASS="author"
><A
NAME="AEN5"
></A
>Machtelt Garrels</H3
><DIV
CLASS="affiliation"
><SPAN
CLASS="orgname"
>Garrels BVBA
<BR></SPAN
><DIV
CLASS="address"
><P
CLASS="address"
><br>
<TT
CLASS="email"
>&#60;<A
HREF="mailto:tille wants no spam _at_ garrels dot be"
>tille wants no spam _at_ garrels dot be</A
>&#62;</TT
><br>
</P
></DIV
></DIV
><P
CLASS="edition"
>Version 1.11 Last updated 20081227&nbsp;Edition </P
><HR></DIV
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
><A
HREF="#AEN32"
>Introduction</A
></DT
><DD
><DL
><DT
>1. <A
HREF="#intro_01"
>Why this guide?</A
></DT
><DT
>2. <A
HREF="#intro_02"
>Who should read this book?</A
></DT
><DT
>3. <A
HREF="#intro_03"
>New versions, translations and availability</A
></DT
><DT
>4. <A
HREF="#intro_04"
>Revision History</A
></DT
><DT
>5. <A
HREF="#intro_05"
>Contributions</A
></DT
><DT
>6. <A
HREF="#intro_06"
>Feedback</A
></DT
><DT
>7. <A
HREF="#intro_07"
>Copyright information</A
></DT
><DT
>8. <A
HREF="#intro_08"
>What do you need?</A
></DT
><DT
>9. <A
HREF="#intro_09"
>Conventions used in this document</A
></DT
><DT
>10. <A
HREF="#intro_10"
>Organization of this document</A
></DT
></DL
></DD
><DT
>1. <A
HREF="#chap_01"
>Bash and Bash scripts</A
></DT
><DD
><DL
><DT
>1.1. <A
HREF="#sect_01_01"
>Common shell programs</A
></DT
><DT
>1.2. <A
HREF="#sect_01_02"
>Advantages of the Bourne Again SHell</A
></DT
><DT
>1.3. <A
HREF="#sect_01_03"
>Executing commands</A
></DT
><DT
>1.4. <A
HREF="#sect_01_04"
>Building blocks</A
></DT
><DT
>1.5. <A
HREF="#sect_01_05"
>Developing good scripts</A
></DT
><DT
>1.6. <A
HREF="#sect_01_06"
>Summary</A
></DT
><DT
>1.7. <A
HREF="#sect_01_07"
>Exercises</A
></DT
></DL
></DD
><DT
>2. <A
HREF="#chap_02"
>Writing and debugging scripts</A
></DT
><DD
><DL
><DT
>2.1. <A
HREF="#sect_02_01"
>Creating and running a script</A
></DT
><DT
>2.2. <A
HREF="#sect_02_02"
>Script basics</A
></DT
><DT
>2.3. <A
HREF="#sect_02_03"
>Debugging Bash scripts</A
></DT
><DT
>2.4. <A
HREF="#sect_02_05"
>Summary</A
></DT
><DT
>2.5. <A
HREF="#sect_02_06"
>Exercises</A
></DT
></DL
></DD
><DT
>3. <A
HREF="#chap_03"
>The Bash environment</A
></DT
><DD
><DL
><DT
>3.1. <A
HREF="#sect_03_01"
>Shell initialization files</A
></DT
><DT
>3.2. <A
HREF="#sect_03_02"
>Variables</A
></DT
><DT
>3.3. <A
HREF="#sect_03_03"
>Quoting characters</A
></DT
><DT
>3.4. <A
HREF="#sect_03_04"
>Shell expansion</A
></DT
><DT
>3.5. <A
HREF="#sect_03_05"
>Aliases</A
></DT
><DT
>3.6. <A
HREF="#sect_03_06"
>More Bash options</A
></DT
><DT
>3.7. <A
HREF="#sect_03_07"
>Summary</A
></DT
><DT
>3.8. <A
HREF="#sect_03_08"
>Exercises</A
></DT
></DL
></DD
><DT
>4. <A
HREF="#chap_04"
>Regular expressions</A
></DT
><DD
><DL
><DT
>4.1. <A
HREF="#sect_04_01"
>Regular expressions</A
></DT
><DT
>4.2. <A
HREF="#sect_04_02"
>Examples using grep</A
></DT
><DT
>4.3. <A
HREF="#sect_04_03"
>Pattern matching using Bash features</A
></DT
><DT
>4.4. <A
HREF="#sect_04_04"
>Summary</A
></DT
><DT
>4.5. <A
HREF="#sect_04_05"
>Exercises</A
></DT
></DL
></DD
><DT
>5. <A
HREF="#chap_05"
>The GNU sed stream editor</A
></DT
><DD
><DL
><DT
>5.1. <A
HREF="#sect_05_01"
>Introduction</A
></DT
><DT
>5.2. <A
HREF="#sect_05_02"
>Interactive editing</A
></DT
><DT
>5.3. <A
HREF="#sect_05_03"
>Non-interactive editing</A
></DT
><DT
>5.4. <A
HREF="#sect_05_04"
>Summary</A
></DT
><DT
>5.5. <A
HREF="#sect_05_05"
>Exercises</A
></DT
></DL
></DD
><DT
>6. <A
HREF="#chap_06"
>The GNU awk programming language</A
></DT
><DD
><DL
><DT
>6.1. <A
HREF="#sect_06_01"
>Getting started with gawk</A
></DT
><DT
>6.2. <A
HREF="#sect_06_02"
>The print program</A
></DT
><DT
>6.3. <A
HREF="#sect_06_03"
>Gawk variables</A
></DT
><DT
>6.4. <A
HREF="#sect_06_04"
>Summary</A
></DT
><DT
>6.5. <A
HREF="#sect_06_05"
>Exercises</A
></DT
></DL
></DD
><DT
>7. <A
HREF="#chap_07"
>Conditional statements</A
></DT
><DD
><DL
><DT
>7.1. <A
HREF="#sect_07_01"
>Introduction to if</A
></DT
><DT
>7.2. <A
HREF="#sect_07_02"
>More advanced if usage</A
></DT
><DT
>7.3. <A
HREF="#sect_07_03"
>Using case statements</A
></DT
><DT
>7.4. <A
HREF="#sect_07_04"
>Summary</A
></DT
><DT
>7.5. <A
HREF="#sect_07_05"
>Exercises</A
></DT
></DL
></DD
><DT
>8. <A
HREF="#chap_08"
>Writing interactive scripts</A
></DT
><DD
><DL
><DT
>8.1. <A
HREF="#sect_08_01"
>Displaying user messages</A
></DT
><DT
>8.2. <A
HREF="#sect_08_02"
>Catching user input</A
></DT
><DT
>8.3. <A
HREF="#sect_08_03"
>Summary</A
></DT
><DT
>8.4. <A
HREF="#sect_08_04"
>Exercises</A
></DT
></DL
></DD
><DT
>9. <A
HREF="#chap_09"
>Repetitive tasks</A
></DT
><DD
><DL
><DT
>9.1. <A
HREF="#sect_09_01"
>The for loop</A
></DT
><DT
>9.2. <A
HREF="#sect_09_02"
>The while loop</A
></DT
><DT
>9.3. <A
HREF="#sect_09_03"
>The until loop</A
></DT
><DT
>9.4. <A
HREF="#sect_09_04"
>I/O redirection and loops</A
></DT
><DT
>9.5. <A
HREF="#sect_09_05"
>Break and continue</A
></DT
><DT
>9.6. <A
HREF="#sect_09_06"
>Making menus with the select built-in</A
></DT
><DT
>9.7. <A
HREF="#sect_09_07"
>The shift built-in</A
></DT
><DT
>9.8. <A
HREF="#sect_09_08"
>Summary</A
></DT
><DT
>9.9. <A
HREF="#sect_09_09"
>Exercises</A
></DT
></DL
></DD
><DT
>10. <A
HREF="#chap_10"
>More on variables</A
></DT
><DD
><DL
><DT
>10.1. <A
HREF="#sect_10_01"
>Types of variables</A
></DT
><DT
>10.2. <A
HREF="#sect_10_02"
>Array variables</A
></DT
><DT
>10.3. <A
HREF="#sect_10_03"
>Operations on variables</A
></DT
><DT
>10.4. <A
HREF="#sect_10_04"
>Summary</A
></DT
><DT
>10.5. <A
HREF="#sect_10_05"
>Exercises</A
></DT
></DL
></DD
><DT
>11. <A
HREF="#chap_11"
>Functions</A
></DT
><DD
><DL
><DT
>11.1. <A
HREF="#sect_11_01"
>Introduction</A
></DT
><DT
>11.2. <A
HREF="#sect_11_02"
>Examples of functions in scripts</A
></DT
><DT
>11.3. <A
HREF="#sect_11_03"
>Summary</A
></DT
><DT
>11.4. <A
HREF="#sect_11_04"
>Exercises</A
></DT
></DL
></DD
><DT
>12. <A
HREF="#chap_12"
>Catching signals</A
></DT
><DD
><DL
><DT
>12.1. <A
HREF="#sect_12_01"
>Signals</A
></DT
><DT
>12.2. <A
HREF="#sect_12_02"
>Traps</A
></DT
><DT
>12.3. <A
HREF="#sect_12_03"
>Summary</A
></DT
><DT
>12.4. <A
HREF="#sect_12_04"
>Exercises</A
></DT
></DL
></DD
><DT
>A. <A
HREF="#app3"
>Shell Features</A
></DT
><DD
><DL
><DT
>A.1. <A
HREF="#AEN7243"
>Common features</A
></DT
><DT
>A.2. <A
HREF="#AEN7369"
>Differing features</A
></DT
></DL
></DD
><DT
><A
HREF="#glossary"
>Glossary</A
></DT
><DT
><A
HREF="#glossary"
>Index</A
></DT
></DL
></DIV
><DIV
CLASS="LOT"
><DL
CLASS="LOT"
><DT
><B
>List of Tables</B
></DT
><DT
>1. <A
HREF="#conventions"
>Typographic and usage conventions</A
></DT
><DT
>1-1. <A
HREF="#table_01_01"
>Overview of programming terms</A
></DT
><DT
>2-1. <A
HREF="#table_02_01"
>Overview of set debugging options</A
></DT
><DT
>3-1. <A
HREF="#table_03_01"
>Reserved Bourne shell variables</A
></DT
><DT
>3-2. <A
HREF="#table_03_02"
>Reserved Bash variables</A
></DT
><DT
>3-3. <A
HREF="#table_03_03"
>Special bash variables</A
></DT
><DT
>3-4. <A
HREF="#table_03_04"
>Arithmetic operators</A
></DT
><DT
>4-1. <A
HREF="#table_04_01"
>Regular expression operators</A
></DT
><DT
>5-1. <A
HREF="#tab_05_01"
>Sed editing commands</A
></DT
><DT
>5-2. <A
HREF="#tab_05_02"
>Sed options</A
></DT
><DT
>6-1. <A
HREF="#tab_06_01"
>Formatting characters for gawk</A
></DT
><DT
>7-1. <A
HREF="#tab_07_01"
>Primary expressions</A
></DT
><DT
>7-2. <A
HREF="#tab_07_02"
>Combining expressions</A
></DT
><DT
>8-1. <A
HREF="#tab_08_01"
>Escape sequences used by the echo command</A
></DT
><DT
>8-2. <A
HREF="#tab_08_02"
>Options to the read built-in</A
></DT
><DT
>10-1. <A
HREF="#tab_10_01"
>Options to the declare built-in</A
></DT
><DT
>12-1. <A
HREF="#tab_12_01"
>Control signals in Bash</A
></DT
><DT
>12-2. <A
HREF="#tab_12_02"
>Common kill signals</A
></DT
><DT
>A-1. <A
HREF="#AEN7246"
>Common Shell Features</A
></DT
><DT
>A-2. <A
HREF="#AEN7387"
>Differing Shell Features</A
></DT
></DL
></DIV
><DIV
CLASS="LOT"
><DL
CLASS="LOT"
><DT
><B
>List of Figures</B
></DT
><DT
>1. <A
HREF="#AEN71"
>Bash Guide for Beginners front cover</A
></DT
><DT
>2-1. <A
HREF="#AEN1409"
>script1.sh</A
></DT
><DT
>3-1. <A
HREF="#AEN1878"
>Different prompts for different users</A
></DT
><DT
>6-1. <A
HREF="#AEN4111"
>Fields in awk</A
></DT
><DT
>7-1. <A
HREF="#AEN5029"
>Testing of a command line argument with if</A
></DT
><DT
>7-2. <A
HREF="#AEN5144"
>Example using Boolean operators</A
></DT
></DL
></DIV
><DIV
CLASS="preface"
><HR><H1
><A
NAME="AEN32"
></A
>Introduction</H1
><DIV
CLASS="section"
><H1
CLASS="section"
><A
NAME="intro_01"
></A
>1. Why this guide?</H1
><P
>The primary reason for writing this document is that a lot of readers feel the existing <A
HREF="http://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO.html"
TARGET="_top"
>HOWTO</A
> to be too short and incomplete, while the <A
HREF="http://tldp.org/LDP/abs/html/"
TARGET="_top"
>Bash Scripting</A
> guide is too much of a reference work.  There is nothing in between these two extremes.  I also wrote this guide on the general principal that not enough free basic courses are available, though they should be.</P
><P
>This is a practical guide which, while not always being too serious, tries to give real-life instead of theoretical examples.  I partly wrote it because I don't get excited with stripped down and over-simplified examples written by people who know what they are talking about, showing some really cool Bash feature so much out of its context that you cannot ever use it in practical circumstances.  You can read that sort of stuff after finishing this book, which contains exercises and examples that will help you survive in the real world.</P
><P
>From my experience as UNIX/Linux user, system administrator and trainer, I know that people can have years of daily interaction with their systems, without having the slightest knowledge of task automation.  Thus they often think that UNIX is not userfriendly, and even worse, they get the impression that it is slow and old-fashioned.  This problem is another one that can be remedied by this guide.</P
></DIV
><DIV
CLASS="section"
><HR><H1
CLASS="section"
><A
NAME="intro_02"
></A
>2. Who should read this book?</H1
><P
>Everybody working on a UNIX or UNIX-like system who wants to make life easier on themselves, power users and sysadmins alike, can benefit from reading this book.  Readers who already have a grasp of working the system using the command line will learn the ins and outs of shell scripting that ease execution of daily tasks.  System administration relies a great deal on shell scripting; common tasks are often automated using simple scripts.  This document is full of examples that will encourage you to write your own and that will inspire you to improve on existing scripts.</P
><P
>Prerequisites/not in this course:</P
><P
></P
><UL
><LI
><P
>You should be an experienced UNIX or Linux user, familiar with basic commands, man pages and documentation</P
></LI
><LI
><P
>Being able to use a text editor</P
></LI
><LI
><P
>Understand system boot and shutdown processes, init and initscripts</P
></LI
><LI
><P
>Create users and groups, set passwords</P
></LI
><LI
><P
>Permissions, special modes</P
></LI
><LI
><P
>Understand naming conventions for devices, partitioning, mounting/unmounting file systems</P
></LI
><LI
><P
>Adding/removing software on your system</P
></LI
></UL
><P
>See <A
HREF="http://tldp.org/LDP/intro-linux/html/"
TARGET="_top"
>Introduction to Linux</A
> (or your local <A
HREF="http://www.tldp.org/mirrors.html"
TARGET="_top"
>TLDP mirror</A
>) if you haven't mastered one or more of these topics.  Additional information can be found in your system documentation (man and info pages), or at <A
HREF="http://tldp.org"
TARGET="_top"
>the Linux Documentation Project</A
>.</P
></DIV
><DIV
CLASS="section"
><HR><H1
CLASS="section"
><A
NAME="intro_03"
></A
>3. New versions, translations and availability</H1
><P
>The most recent edition can be found at <A
HREF="http://tille.garrels.be/training/bash/"
TARGET="_top"
>http://tille.garrels.be/training/bash/</A
>.  You should find the same version at <A
HREF="http://tldp.org/LDP/Bash-Beginners-Guide/html/index.html"
TARGET="_top"
>http://tldp.org/LDP/Bash-Beginners-Guide/html/index.html</A
>.</P
><P
>This guide is available in print from <A
HREF="http://store.fultus.com/product_info.php?products_id=66"
TARGET="_top"
>Fultus.com</A
>.</P
><DIV
CLASS="figure"
><A
NAME="AEN71"
></A
><P
><B
>Figure 1. Bash Guide for Beginners front cover</B
></P
><DIV
CLASS="mediaobject"
><P
><IMG
SRC="images/bgb.jpg"></P
></DIV
></DIV
><P
>This guide has been translated:</P
><P
></P
><UL
><LI
><P
>Chinese translation at <A
HREF="http://xiaowang.net/bgb-cn/"
TARGET="_top"
>http://xiaowang.net/bgb-cn/</A
>, by Wang Wei.</P
></LI
><LI
><P
>Ukrainian translation at <A
HREF="http://docs.linux.org.ua/index.php/LDP:Bash_beginners_guide"
TARGET="_top"
>http://docs.linux.org.ua/index.php/LDP:Bash_beginners_guide</A
>, by Yaroslav Fedevych and his team.</P
></LI
></UL
><P
>A french translation is in the making and will be linked to as soon as it is finished.</P
></DIV
><DIV
CLASS="section"
><HR><H1
CLASS="section"
><A
NAME="intro_04"
></A
>4. Revision History</H1
><P
>&#13;<DIV
CLASS="revhistory"
><TABLE
WIDTH="100%"
BORDER="0"
><TR
><TH
ALIGN="LEFT"
VALIGN="TOP"
COLSPAN="3"
><B
>Revision History</B
></TH
></TR
><TR
><TD
ALIGN="LEFT"
>Revision 1.11</TD
><TD
ALIGN="LEFT"
>2008-12-27</TD
><TD
ALIGN="LEFT"
>Revised by: MG</TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>Processed input from readers.</TD
></TR
><TR
><TD
ALIGN="LEFT"
>Revision 1.10</TD
><TD
ALIGN="LEFT"
>2008-06-06</TD
><TD
ALIGN="LEFT"
>Revised by: MG</TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>address change</TD
></TR
><TR
><TD
ALIGN="LEFT"
>Revision 1.9</TD
><TD
ALIGN="LEFT"
>2006-10-10</TD
><TD
ALIGN="LEFT"
>Revised by: MG</TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>Incorporated reader remarks, added index using DocBook tags.</TD
></TR
><TR
><TD
ALIGN="LEFT"
>Revision 1.8</TD
><TD
ALIGN="LEFT"
>2006-03-15</TD
><TD
ALIGN="LEFT"
>Revised by: MG</TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>clarified example in Chap4, corrected here doc in chap9, general checks and correction of typos, added link to Chinese and Ukrainian translation, note and stuff to know about awk in chap6.</TD
></TR
><TR
><TD
ALIGN="LEFT"
>Revision 1.7</TD
><TD
ALIGN="LEFT"
>2005-09-05</TD
><TD
ALIGN="LEFT"
>Revised by: MG</TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>Corrected typos in chapter 3, 6 and 7, incorporated user remarks, added a note in chap7.</TD
></TR
><TR
><TD
ALIGN="LEFT"
>Revision 1.6</TD
><TD
ALIGN="LEFT"
>2005-03-01</TD
><TD
ALIGN="LEFT"
>Revised by: MG</TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>Minor debugging, added more keywords, info about new Bash 3.0, took out blank image.</TD
></TR
><TR
><TD
ALIGN="LEFT"
>Revision 1.0</TD
><TD
ALIGN="LEFT"
>2004-04-27</TD
><TD
ALIGN="LEFT"
>Revised by: TM</TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>Initial release for LDP; more exercises, more markup, less errors and abuse; added glossary.</TD
></TR
><TR
><TD
ALIGN="LEFT"
>Revision 1.0-beta</TD
><TD
ALIGN="LEFT"
>2003-04-20</TD
><TD
ALIGN="LEFT"
>Revised by: MG</TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>Pre-release</TD
></TR
></TABLE
></DIV
>
</P
></DIV
><DIV
CLASS="section"
><HR><H1
CLASS="section"
><A
NAME="intro_05"
></A
>5. Contributions</H1
><P
>&#13;Thanks to all the friends who helped (or tried to) and to my husband; your encouraging words made this work possible.  Thanks to all the people who submitted bug reports, examples and remarks - among many, many others:</P
><P
></P
><UL
><LI
><P
>Hans Bol, one of the groupies</P
></LI
><LI
><P
>Mike Sim, remarks on style</P
></LI
><LI
><P
>Dan Richter, for array examples</P
></LI
><LI
><P
>Gerg Ferguson, for ideas on the title</P
></LI
><LI
><P
>Mendel Leo Cooper, for making room</P
></LI
><LI
><P
>#linux.be, for keeping my feet on the ground</P
></LI
><LI
><P
>Frank Wang, for his detailed remarks on all the things I did wrong ;-)</P
></LI
></UL
><P
>Special thanks to Tabatha Marshall, who volunteered to do a complete review and spell and grammar check.  We make a great team: she works when I sleep.  And vice versa ;-)</P
></DIV
><DIV
CLASS="section"
><HR><H1
CLASS="section"
><A
NAME="intro_06"
></A
>6. Feedback</H1
><P
>&#13;Missing information, missing links, missing characters, remarks?  Mail it to 
<P
CLASS="address"
><TT
CLASS="email"
>&#60;<A
HREF="mailto:tille wants no spam _at_ garrels dot be"
>tille wants no spam _at_ garrels dot be</A
>&#62;</TT
></P
>
the maintainer of this document.
</P
></DIV
><DIV
CLASS="section"
><HR><H1
CLASS="section"
><A
NAME="intro_07"
></A
>7. Copyright information</H1
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;* Copyright (c) 2002-2007, Machtelt Garrels
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the author, Machtelt Garrels, nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL THE AUTHOR AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</PRE
></FONT
></TD
></TR
></TABLE
><P
>The author and publisher have made every effort in the preparation of this book to ensure the accuracy of the information.  However, the information contained in this book is offered without warranty, either express or implied.  Neither the author nor the publisher nor any dealer or distributor will be held liable for any damages caused or alleged to be caused either directly or indirectly by this book.</P
><P
>The logos, trademarks and symbols used in this book are the properties of
their respective owners.</P
></DIV
><DIV
CLASS="section"
><HR><H1
CLASS="section"
><A
NAME="intro_08"
></A
>8. What do you need?</H1
><P
><B
CLASS="command"
>bash</B
>, available from <A
HREF="http://www.gnu.org/directory/GNU/"
TARGET="_top"
>http://www.gnu.org/directory/GNU/</A
>.  The Bash shell is available on nearly every Linux system, and can these days be found on a wide variety of UNIX systems.</P
><P
>Compiles easily if you need to make your own, tested on a wide variety of UNIX, Linux, MS Windows and other systems.</P
></DIV
><DIV
CLASS="section"
><HR><H1
CLASS="section"
><A
NAME="intro_09"
></A
>9. Conventions used in this document</H1
><P
>The following typographic and usage conventions occur in this text:
</P
><DIV
CLASS="table"
><A
NAME="conventions"
></A
><P
><B
>Table 1. Typographic and usage conventions</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
>Text type</TH
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
>Meaning</TH
></TR
></THEAD
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><SPAN
CLASS="QUOTE"
>"Quoted text"</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Quotes from people, quoted computer output.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>terminal view</PRE
></FONT
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Literal computer input and output captured from the terminal,
usually rendered with a light grey background.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>command</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Name of a command that can be entered on the command line.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><TT
CLASS="varname"
>VARIABLE</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Name of a variable or pointer to content of a variable, as in
<TT
CLASS="varname"
>$VARNAME</TT
>.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><TT
CLASS="option"
>option</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Option to a command, as in <SPAN
CLASS="QUOTE"
>"the <TT
CLASS="option"
>-a</TT
> option to the
<B
CLASS="command"
>ls</B
> command"</SPAN
>.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><TT
CLASS="parameter"
><I
>argument</I
></TT
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Argument to a command, as in <SPAN
CLASS="QUOTE"
>"read
<B
CLASS="command"
>man <TT
CLASS="parameter"
><I
>ls</I
></TT
></B
>"</SPAN
>.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><P
><B
CLASS="command"
>command <TT
CLASS="option"
>options</TT
>
<TT
CLASS="parameter"
><I
>arguments</I
></TT
></B
> </P
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Command synopsis or general usage, on a separated line.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><TT
CLASS="filename"
>filename</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Name of a file or directory, for example <SPAN
CLASS="QUOTE"
>"Change to the
<TT
CLASS="filename"
>/usr/bin</TT
> directory."</SPAN
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="keycap"
>Key</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Keys to hit on the keyboard, such as <SPAN
CLASS="QUOTE"
>"type <B
CLASS="keycap"
>Q</B
>
to quit"</SPAN
>.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><SPAN
CLASS="guibutton"
>Button</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Graphical button to click, like the <SPAN
CLASS="guibutton"
>OK</SPAN
>
button.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><SPAN
CLASS="guimenu"
>Menu</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Choice</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Choice to select from a graphical menu, for instance: <SPAN
CLASS="QUOTE"
>"Select
<SPAN
CLASS="guimenu"
>Help</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>About Mozilla</SPAN
> in your browser."</SPAN
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><EM
>Terminology</EM
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Important term or concept: <SPAN
CLASS="QUOTE"
>"The Linux <EM
>kernel</EM
>
is the heart of the system."</SPAN
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>\</PRE
></FONT
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>The backslash in a terminal view or command synopsis indicates an unfinished line.  In other words, if you see a long command that is cut into multiple lines, \ means <SPAN
CLASS="QUOTE"
>"Don't press <B
CLASS="keycap"
>Enter</B
> yet!"</SPAN
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>See <A
HREF="#chap_01"
>Chapter 1</A
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>link to related subject
within this guide.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><A
HREF="http://tille.garrels.be"
TARGET="_top"
>The author</A
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Clickable link to an external web resource.</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="section"
><HR><H1
CLASS="section"
><A
NAME="intro_10"
></A
>10. Organization of this document</H1
><P
>This guide discusses concepts useful in the daily life of the serious Bash user.  While a basic knowledge of the usage of the shell is required, we start with a discussion of the basic shell components and practices in the first three chapters.</P
><P
>Chapters four to six are discussions of basic tools that are commonly used in shell scripts.</P
><P
>Chapters eight to twelve discuss the most common constructs in shell scripts.</P
><P
>All chapters come with exercises that will test your preparedness for the
next chapter.</P
><P
></P
><UL
><LI
><P
><A
HREF="#chap_01"
>Chapter 1</A
>: Bash basics: why Bash is so good, building blocks, first guidelines on developing good scripts.</P
></LI
><LI
><P
><A
HREF="#chap_02"
>Chapter 2</A
>: Script basics: writing and debugging.</P
></LI
><LI
><P
><A
HREF="#chap_03"
>Chapter 3</A
>: The Bash Environment: initialization files, variables, quoting characters, shell expansion order, aliases, options.</P
></LI
><LI
><P
><A
HREF="#chap_04"
>Chapter 4</A
>: Regular expressions: an introduction.</P
></LI
><LI
><P
><A
HREF="#chap_05"
>Chapter 5</A
>: Sed: an introduction to the sed line editor.</P
></LI
><LI
><P
><A
HREF="#chap_06"
>Chapter 6</A
>:Awk: introduction to the awk programming language.</P
></LI
><LI
><P
><A
HREF="#chap_07"
>Chapter 7</A
>: Conditional statements: constructs used in Bash to test conditions.</P
></LI
><LI
><P
><A
HREF="#chap_08"
>Chapter 8</A
>: Interactive scripts: making scripts user-friendly, catching user input.</P
></LI
><LI
><P
><A
HREF="#chap_09"
>Chapter 9</A
>: Executing commands repetitively: constructs used in Bash to automate command execution.</P
></LI
><LI
><P
><A
HREF="#chap_10"
>Chapter 10</A
>: Advanced variables: specifying variable types, introduction to arrays of variables, operations on variables.</P
></LI
><LI
><P
><A
HREF="#chap_11"
>Chapter 11</A
>: Functions: an introduction.</P
></LI
><LI
><P
><A
HREF="#chap_12"
>Chapter 12</A
>: Catching signals: introduction to process signalling, trapping user-sent signals.</P
></LI
></UL
></DIV
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="chap_01"
></A
>Chapter 1. Bash and Bash scripts</H1
><BLOCKQUOTE
CLASS="ABSTRACT"
><DIV
CLASS="abstract"
><A
NAME="AEN311"
></A
><P
></P
><P
>In this introduction module we</P
><P
><P
></P
><UL
><LI
><P
>Describe some common shells</P
></LI
><LI
><P
>Point out GNU Bash advantages and features</P
></LI
><LI
><P
>Describe the shell's building blocks</P
></LI
><LI
><P
>Discuss Bash initialization files</P
></LI
><LI
><P
>See how the shell executes commands</P
></LI
><LI
><P
>Look into some simple script examples</P
></LI
></UL
></P
><P
></P
></DIV
></BLOCKQUOTE
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="sect_01_01"
></A
>1.1. Common shell programs</H1
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="sect_01_01_01"
></A
>1.1.1. General shell functions</H2
><P
>The UNIX shell program interprets user commands, which are either directly entered by the user, or which can be read from a file called the shell script or shell program.  Shell scripts are interpreted, not compiled.  The shell reads commands from the script line per line and searches for those commands on the system (see <A
HREF="#sect_01_02"
>Section 1.2</A
>), while a compiler converts a program into machine readable form, an executable file - which may then be used in a shell script.</P
><P
>Apart from passing commands to the kernel, the main task of a shell is providing a user environment, which can be configured individually using shell resource configuration files.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_01_01_02"
></A
>1.1.2. Shell types</H2
><P
>Just like people know different languages and dialects, your UNIX system will usually offer a variety of shell types:</P
><P
></P
><UL
><LI
><P
><B
CLASS="command"
>sh</B
> or Bourne Shell: the original shell still
used on UNIX systems and in UNIX-related environments.  This is the basic shell, a small program with few features.  While this is not the standard shell, it is still available on every Linux system for compatibility with UNIX programs.</P
></LI
><LI
><P
><B
CLASS="command"
>bash</B
> or Bourne Again shell: the standard GNU
shell, intuitive and flexible.  Probably most advisable for beginning users while being at the same time a powerful tool for the advanced and professional user.  On Linux, <B
CLASS="command"
>bash</B
> is the standard shell for common users.  This shell is a so-called <EM
>superset</EM
> of the Bourne shell, a set
of add-ons and plug-ins.  This means that the Bourne Again shell is compatible with the Bourne shell: commands that work in <B
CLASS="command"
>sh</B
>, also work in
<B
CLASS="command"
>bash</B
>.  However, the reverse is not always the case.  All examples and exercises in this book use <B
CLASS="command"
>bash</B
>.</P
></LI
><LI
><P
><B
CLASS="command"
>csh</B
> or C shell: the syntax of this shell resembles that of the C programming language.  Sometimes asked for by programmers.</P
></LI
><LI
><P
><B
CLASS="command"
>tcsh</B
> or TENEX C shell: a superset of the common C shell, enhancing user-friendliness and speed.  That is why some also call it the Turbo C shell.</P
></LI
><LI
><P
><B
CLASS="command"
>ksh</B
> or the Korn shell: sometimes appreciated
by people with a UNIX background.  A superset of the Bourne shell; with standard configuration a nightmare for beginning users.</P
></LI
></UL
><P
>The file <TT
CLASS="filename"
>/etc/shells</TT
> gives an overview of known shells on a Linux system:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>mia:~&#62;</TT
> <B
CLASS="command"
>cat <TT
CLASS="filename"
>/etc/shells</TT
></B
>
/bin/bash
/bin/sh
/bin/tcsh
/bin/csh
</PRE
></FONT
></TD
></TR
></TABLE
><P
>Your default shell is set in the <TT
CLASS="filename"
>/etc/passwd</TT
> file, like this line for user <EM
>mia</EM
>:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;mia:L2NOfqdlPrHwE:504:504:Mia Maya:/home/mia:/bin/bash
</PRE
></FONT
></TD
></TR
></TABLE
><P
>To switch from one shell to another, just enter the name of the new shell
in the active terminal.  The system finds the directory where the name occurs using the <TT
CLASS="varname"
>PATH</TT
> settings, and since a shell is an executable file (program), the current shell activates it and it gets executed.  A new prompt is usually shown, because each shell has its typical appearance:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>mia:~&#62;</TT
> <B
CLASS="command"
>tcsh</B
>
[mia@post21 ~]$
</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="sect_01_02"
></A
>1.2. Advantages of the Bourne Again SHell</H1
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="sect_01_02_01"
></A
>1.2.1. Bash is the GNU shell</H2
><P
>The GNU project (GNU's Not UNIX) provides tools for UNIX-like system administration which are free software and comply to UNIX standards.</P
><P
>Bash is an sh-compatible shell that incorporates useful features from the Korn shell (ksh) and C shell (csh). It is intended to conform to the IEEE POSIX P1003.2/ISO 9945.2 Shell and Tools standard. It offers functional improvements over sh for both programming and interactive use; these include command line editing, unlimited size command history, job control, shell functions and aliases, indexed arrays of unlimited size, and integer arithmetic in any base from two to sixty-four. Bash can run most sh scripts without modification.</P
><P
>Like the other GNU projects, the bash initiative was started to preserve, protect and promote the freedom to use, study, copy, modify and redistribute software.  It is generally known that such conditions stimulate creativity.  This was also the case with the bash program, which has a lot of extra features that other shells can't offer.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_01_02_02"
></A
>1.2.2. Features only found in bash</H2
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="sect_01_02_02_01"
></A
>1.2.2.1. Invocation</H3
><P
>In addition to the single-character shell command line options which can generally be configured using the <B
CLASS="command"
>set</B
> shell built-in command, there are several multi-character options that you can use.  We will come across a couple of the more popular options in this and the following chapters; the complete list can be found in the Bash info pages, <SPAN
CLASS="guimenu"
>Bash features</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Invoking Bash</SPAN
>.</P
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="sect_01_02_02_02"
></A
>1.2.2.2. Bash startup files</H3
><P
>Startup files are scripts that are read and executed by Bash when it starts.  The following subsections describe different ways to start the shell, and the startup files that are read consequently.</P
><DIV
CLASS="sect4"
><HR><H4
CLASS="sect4"
><A
NAME="sect_01_02_02_02_01"
></A
>1.2.2.2.1. Invoked as an interactive login shell, or with `--login'</H4
><P
>Interactive means you can enter commands.  The shell is not running because a script has been activated.  A login shell means that you got the shell after authenticating to the system, usually by giving your user name and password.</P
><P
>Files read:</P
><P
></P
><UL
><LI
><P
><TT
CLASS="filename"
>/etc/profile</TT
></P
></LI
><LI
><P
><TT
CLASS="filename"
>~/.bash_profile</TT
>, <TT
CLASS="filename"
>~/.bash_login</TT
> or <TT
CLASS="filename"
>~/.profile</TT
>: first existing readable file is read</P
></LI
><LI
><P
><TT
CLASS="filename"
>~/.bash_logout</TT
> upon logout.</P
></LI
></UL
><P
>Error messages are printed if configuration files exist but are not readable.  If a file does not exist, bash searches for the next.</P
></DIV
><DIV
CLASS="sect4"
><HR><H4
CLASS="sect4"
><A
NAME="sect_01_02_02_02_02"
></A
>1.2.2.2.2. Invoked as an interactive non-login shell</H4
><P
>A non-login shell means that you did not have to authenticate to the system.  For instance, when you open a terminal using an icon, or a menu item, that is a non-login shell.</P
><P
>Files read:</P
><P
></P
><UL
><LI
><P
><TT
CLASS="filename"
>~/.bashrc</TT
></P
></LI
></UL
><P
>This file is usually referred to in <TT
CLASS="filename"
>~/.bash_profile</TT
>:</P
><P
><B
CLASS="command"
>if <TT
CLASS="function"
>[ -f <TT
CLASS="filename"
>~/.bashrc</TT
> ]</TT
>; then . <TT
CLASS="filename"
>~/.bashrc</TT
>; fi</B
> </P
><P
>See <A
HREF="#chap_07"
>Chapter 7</A
> for more information on the <B
CLASS="command"
>if</B
> construct.</P
></DIV
><DIV
CLASS="sect4"
><HR><H4
CLASS="sect4"
><A
NAME="sect_01_02_02_02_03"
></A
>1.2.2.2.3. Invoked non-interactively</H4
><P
>All scripts use non-interactive shells.  They are programmed to do certain tasks and cannot be instructed to do other jobs than those for which they are programmed.</P
><P
>Files read:</P
><P
></P
><UL
><LI
><P
>defined by <TT
CLASS="varname"
>BASH_ENV</TT
></P
></LI
></UL
><P
><TT
CLASS="varname"
>PATH</TT
> is not used to search for this file, so if you want to use it, best refer to it by giving the full path and file name.</P
></DIV
><DIV
CLASS="sect4"
><HR><H4
CLASS="sect4"
><A
NAME="sect_01_02_02_02_04"
></A
>1.2.2.2.4. Invoked with the sh command</H4
><P
>Bash tries to behave as the historical Bourne <B
CLASS="command"
>sh</B
> program while conforming to the POSIX standard as well.</P
><P
>Files read:</P
><P
></P
><UL
><LI
><P
><TT
CLASS="filename"
>/etc/profile</TT
></P
></LI
><LI
><P
><TT
CLASS="filename"
>~/.profile</TT
></P
></LI
></UL
><P
>When invoked interactively, the <TT
CLASS="varname"
>ENV</TT
> variable can point to extra startup information.</P
></DIV
><DIV
CLASS="sect4"
><HR><H4
CLASS="sect4"
><A
NAME="sect_01_02_02_02_05"
></A
>1.2.2.2.5. POSIX mode</H4
><P
>This option is enabled either using the <B
CLASS="command"
>set</B
> built-in:</P
><P
><B
CLASS="command"
>set <TT
CLASS="option"
>-o posix</TT
></B
> </P
><P
>or by calling the <B
CLASS="command"
>bash</B
> program with the <TT
CLASS="option"
>--posix</TT
> option.  Bash will then try to behave as compliant as possible to the POSIX standard for shells.  Setting the <TT
CLASS="varname"
>POSIXLY_CORRECT</TT
> variable does the same.</P
><P
>Files read:</P
><P
></P
><UL
><LI
><P
>defined by <TT
CLASS="varname"
>ENV</TT
> variable.</P
></LI
></UL
></DIV
><DIV
CLASS="sect4"
><HR><H4
CLASS="sect4"
><A
NAME="sect_01_02_02_02_06"
></A
>1.2.2.2.6. Invoked remotely</H4
><P
>Files read when invoked by <B
CLASS="command"
>rshd</B
>:</P
><P
></P
><UL
><LI
><P
><TT
CLASS="filename"
>~/.bashrc</TT
></P
></LI
></UL
><DIV
CLASS="warning"
><P
></P
><TABLE
CLASS="warning"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="images/warning.gif"
HSPACE="5"
ALT="Warning"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>Avoid use of r-tools</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Be aware of the dangers when using tools such as <B
CLASS="command"
>rlogin</B
>, <B
CLASS="command"
>telnet</B
>, <B
CLASS="command"
>rsh</B
> and <B
CLASS="command"
>rcp</B
>.  They are intrinsically insecure because confidential data is sent over the network unencrypted.  If you need tools for remote execution, file transfer and so on, use an implementation of Secure SHell, generally known as SSH, freely available from <A
HREF="http://www.openssh.org"
TARGET="_top"
>http://www.openssh.org</A
>.  Different client programs are available for non-UNIX systems as well, see your local software mirror.</P
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="sect4"
><HR><H4
CLASS="sect4"
><A
NAME="sect_01_02_02_02_07"
></A
>1.2.2.2.7. Invoked when UID is not equal to EUID</H4
><P
>No startup files are read in this case.</P
></DIV
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="sect_01_02_02_03"
></A
>1.2.2.3. Interactive shells</H3
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
NAME="sect_01_02_02_03_01"
></A
>1.2.2.3.1. What is an interactive shell?</H4
><P
>An interactive shell generally reads from, and writes to, a user's terminal: input and output are connected to a terminal.  Bash interactive behavior is started when the <B
CLASS="command"
>bash</B
> command is called upon without non-option arguments, except when the option is a string to read from or when the shell is invoked to read from standard input, which allows for positional parameters to be set (see <A
HREF="#chap_03"
>Chapter 3</A
> ).</P
></DIV
><DIV
CLASS="sect4"
><HR><H4
CLASS="sect4"
><A
NAME="sect_01_02_02_03_02"
></A
>1.2.2.3.2. Is this shell interactive?</H4
><P
>Test by looking at the content of the special parameter <TT
CLASS="varname"
>-</TT
>, it contains an 'i' when the shell is interactive:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>eddy:~&#62;</TT
> <B
CLASS="command"
>echo <TT
CLASS="varname"
>$-</TT
></B
>
himBH
</PRE
></FONT
></TD
></TR
></TABLE
><P
>In non-interactive shells, the prompt, <TT
CLASS="varname"
>PS1</TT
>, is unset.</P
></DIV
><DIV
CLASS="sect4"
><HR><H4
CLASS="sect4"
><A
NAME="sect_01_02_02_03_03"
></A
>1.2.2.3.3. Interactive shell behavior</H4
><P
>Differences in interactive mode:</P
><P
></P
><UL
><LI
><P
>Bash reads startup files.</P
></LI
><LI
><P
>Job control enabled by default.</P
></LI
><LI
><P
>Prompts are set, <TT
CLASS="varname"
>PS2</TT
> is enabled for multi-line commands, it is usually set to <SPAN
CLASS="QUOTE"
>"&#62;"</SPAN
>.  This is also the prompt you get when the shell thinks you entered an unfinished command, for instance when you forget quotes, command structures that cannot be left out, etc.</P
></LI
><LI
><P
>Commands are by default read from the command line using <B
CLASS="command"
>readline</B
>.</P
></LI
><LI
><P
>Bash interprets the shell option <TT
CLASS="option"
>ignoreeof</TT
> instead of exiting immediately upon receiving EOF (End Of File).</P
></LI
><LI
><P
>Command history and history expansion are enabled by default.  History is saved in the file pointed to by <TT
CLASS="varname"
>HISTFILE</TT
> when the shell exits.  By default, <TT
CLASS="varname"
>HISTFILE</TT
> points to <TT
CLASS="filename"
>~/.bash_history</TT
>.</P
></LI
><LI
><P
>Alias expansion is enabled.</P
></LI
><LI
><P
>In the absence of traps, the <TT
CLASS="option"
>SIGTERM</TT
> signal is ignored.</P
></LI
><LI
><P
>In the absence of traps, <TT
CLASS="option"
>SIGINT</TT
> is caught and handled.  Thus, typing <B
CLASS="keycap"
>Ctrl</B
>+<B
CLASS="keycap"
>C</B
>, for example, will not quit your interactive shell.</P
></LI
><LI
><P
>Sending <TT
CLASS="option"
>SIGHUP</TT
> signals to all jobs on exit is configured with the <TT
CLASS="option"
>huponexit</TT
> option.</P
></LI
><LI
><P
>Commands are executed upon read.</P
></LI
><LI
><P
>Bash checks for mail periodically.</P
></LI
><LI
><P
>Bash can be configured to exit when it encounters unreferenced variables.  In interactive mode this behavior is disabled.</P
></LI
><LI
><P
>When shell built-in commands encounter redirection errors, this will not cause the shell to exit.</P
></LI
><LI
><P
>Special built-ins returning errors when used in POSIX mode don't cause the shell to exit.  The built-in commands are listed in <A
HREF="#sect_01_03_02"
>Section 1.3.2</A
>.</P
></LI
><LI
><P
>Failure of <B
CLASS="command"
>exec</B
> will not exit the shell.</P
></LI
><LI
><P
>Parser syntax errors don't cause the shell to exit.</P
></LI
><LI
><P
>Simple spell check for the arguments to the <B
CLASS="command"
>cd</B
> built-in is enabled by default.</P
></LI
><LI
><P
>Automatic exit after the length of time specified in the <TT
CLASS="varname"
>TMOUT</TT
> variable has passed, is enabled.</P
></LI
></UL
><P
>More information:</P
><P
></P
><UL
><LI
><P
><A
HREF="#sect_03_02"
>Section 3.2</A
></P
></LI
><LI
><P
><A
HREF="#sect_03_06"
>Section 3.6</A
></P
></LI
><LI
><P
>See <A
HREF="#chap_12"
>Chapter 12</A
> for more about signals.</P
></LI
><LI
><P
><A
HREF="#sect_03_04"
>Section 3.4</A
> discusses the various expansions performed upon entering a command.</P
></LI
></UL
></DIV
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="sect_01_02_02_04"
></A
>1.2.2.4. Conditionals</H3
><P
>Conditional expressions are used by the <B
CLASS="command"
>[[</B
> compound command and by the <B
CLASS="command"
>test</B
> and <B
CLASS="command"
>[</B
> built-in commands.</P
><P
>Expressions may be unary or binary.  Unary expressions are often used to examine the status of a file.  You only need one object, for instance a file, to do the operation on.</P
><P
>There are string operators and numeric comparison operators as well; these are binary operators, requiring two objects to do the operation on.  If the <TT
CLASS="option"
>FILE</TT
> argument to one of the primaries is in the form <TT
CLASS="filename"
>/dev/fd/N</TT
>, then file descriptor N is checked.  If the <TT
CLASS="option"
>FILE</TT
> argument to one of the primaries is one of <TT
CLASS="filename"
>/dev/stdin</TT
>, <TT
CLASS="filename"
>/dev/stdout</TT
> or <TT
CLASS="filename"
>/dev/stderr</TT
>, then file descriptor 0, 1 or 2 respectively is checked.</P
><P
>Conditionals are discussed in detail in <A
HREF="#chap_07"
>Chapter 7</A
>.</P
><P
>More information about the file descriptors in <A
HREF="#sect_08_02_03"
>Section 8.2.3</A
>.</P
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="sect_01_02_02_05"
></A
>1.2.2.5. Shell arithmetic</H3
><P
>The shell allows arithmetic expressions to be evaluated, as one of
the shell expansions or by the <B
CLASS="command"
>let</B
> built-in.</P
><P
>Evaluation is done in fixed-width integers with no check for overflow, though division by 0 is trapped and flagged as an error.  The operators and their precedence and associativity are the same as in the C language, see <A
HREF="#chap_03"
>Chapter 3</A
>.</P
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="sect_01_02_02_06"
></A
>1.2.2.6. Aliases</H3
><P
>Aliases allow a string to be substituted for a word when it is used as the first word of a simple command.  The shell maintains a list of aliases that may be set and unset with the <B
CLASS="command"
>alias</B
> and <B
CLASS="command"
>unalias</B
> commands.</P
><P
>Bash always reads at least one complete line of input before executing any of the commands on that line.  Aliases are expanded when a command is read, not when it is executed.  Therefore, an alias definition appearing on the same line as another command does not take effect until the next line of input is read.  The commands following the alias definition on that line are not affected by the new alias.</P
><P
>Aliases are expanded when a function definition is read, not when the function is executed, because a function definition is itself a compound command.  As a consequence, aliases defined in a function are not available until after that function is executed.</P
><P
>We will discuss aliases in detail in <A
HREF="#sect_03_05"
>Section 3.5</A
>.</P
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="sect_01_02_02_07"
></A
>1.2.2.7. Arrays</H3
><P
>Bash provides one-dimensional array variables.  Any variable may be used as an array; the <B
CLASS="command"
>declare</B
> built-in will explicitly declare an array.  There is no maximum limit on the size of an array, nor any requirement that members be indexed or assigned contiguously.  Arrays are zero-based.  See <A
HREF="#chap_10"
>Chapter 10</A
>.</P
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="sect_01_02_02_08"
></A
>1.2.2.8. Directory stack</H3
><P
>The directory stack is a list of recently-visited directories.  The <B
CLASS="command"
>pushd</B
> built-in adds directories to the stack as it changes the current directory, and the <B
CLASS="command"
>popd</B
> built-in removes specified directories from the stack and changes the current directory to the directory removed.</P
><P
>Content can be displayed issuing the <B
CLASS="command"
>dirs</B
> command or by checking the content of the <TT
CLASS="varname"
>DIRSTACK</TT
> variable.</P
><P
>More information about the workings of this mechanism can be found in the Bash info pages.</P
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="sect_01_02_02_09"
></A
>1.2.2.9. The prompt</H3
><P
>Bash makes playing with the prompt even more fun.  See the section <EM
>Controlling the Prompt</EM
> in the Bash info pages.</P
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="sect_01_02_02_10"
></A
>1.2.2.10. The restricted shell</H3
><P
>When invoked as <B
CLASS="command"
>rbash</B
> or with the <TT
CLASS="option"
>--restricted</TT
> or <TT
CLASS="option"
>-r</TT
> option, the following happens:</P
><P
></P
><UL
><LI
><P
>The <B
CLASS="command"
>cd</B
> built-in is disabled.</P
></LI
><LI
><P
>Setting or unsetting <TT
CLASS="varname"
>SHELL</TT
>, <TT
CLASS="varname"
>PATH</TT
>, <TT
CLASS="varname"
>ENV</TT
> or <TT
CLASS="varname"
>BASH_ENV</TT
> is not possible.</P
></LI
><LI
><P
>Command names can no longer contain slashes.</P
></LI
><LI
><P
>Filenames containing a slash are not allowed with the <B
CLASS="command"
>.</B
> (<B
CLASS="command"
>source</B
>) built-in command.</P
></LI
><LI
><P
>The <B
CLASS="command"
>hash</B
> built-in does not accept slashes with the <TT
CLASS="option"
>-p</TT
> option.</P
></LI
><LI
><P
>Import of functions at startup is disabled.</P
></LI
><LI
><P
><TT
CLASS="varname"
>SHELLOPTS</TT
> is ignored at startup.</P
></LI
><LI
><P
>Output redirection using <B
CLASS="command"
>&#62;</B
>, <B
CLASS="command"
>&#62;|</B
>, <B
CLASS="command"
>&#62;&#60;</B
>, <B
CLASS="command"
>&#62;&#38;</B
>, <B
CLASS="command"
>&#38;&#62;</B
> and <B
CLASS="command"
>&#62;&#62;</B
> is disabled.</P
></LI
><LI
><P
>The <B
CLASS="command"
>exec</B
> built-in is disabled.</P
></LI
><LI
><P
>The <TT
CLASS="option"
>-f</TT
> and <TT
CLASS="option"
>-d</TT
> options are disabled for the <B
CLASS="command"
>enable</B
> built-in.</P
></LI
><LI
><P
>A default <TT
CLASS="varname"
>PATH</TT
> cannot be specified with the <B
CLASS="command"
>command</B
> built-in.</P
></LI
><LI
><P
>Turning off restricted mode is not possible.</P
></LI
></UL
><P
>When a command that is found to be a shell script is executed, <B
CLASS="command"
>rbash</B
> turns off any restrictions in the shell spawned to execute the script.</P
><P
>More information:</P
><P
></P
><UL
><LI
><P
><A
HREF="#sect_03_02"
>Section 3.2</A
></P
></LI
><LI
><P
><A
HREF="#sect_03_06"
>Section 3.6</A
></P
></LI
><LI
><P
><SPAN
CLASS="guimenu"
>Info Bash</SPAN
>-&gt;<SPAN
CLASS="guisubmenu"
>Basic Shell Features</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Redirections</SPAN
></P
></LI
><LI
><P
><A
HREF="#sect_08_02_03"
>Section 8.2.3</A
>: advanced redirection</P
></LI
></UL
></DIV
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="sect_01_03"
></A
>1.3. Executing commands</H1
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="sect_01_03_01"
></A
>1.3.1. General</H2
><P
>Bash determines the type of program that is to be executed.  Normal programs are system commands that exist in compiled form on your system.  When such a program is executed, a new process is created because Bash makes an exact copy of itself.  This child process has the same environment as its parent, only the process ID number is different.  This procedure is called <EM
>forking</EM
>.</P
><P
>After the forking process, the address space of the child process is overwritten with the new process data.  This is done through an <EM
>exec</EM
> call to the system.</P
><P
>The <EM
>fork-and-exec</EM
> mechanism thus switches an old command with a new, while the environment in which the new program is executed remains the same, including configuration of input and output devices, environment variables and priority.  This mechanism is used to create all UNIX processes, so it also applies to the Linux operating system.  Even the first process, <B
CLASS="command"
>init</B
>, with process ID 1, is forked during the boot procedure in the so-called <EM
>bootstrapping</EM
> procedure.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_01_03_02"
></A
>1.3.2. Shell built-in commands</H2
><P
>Built-in commands are contained within the shell itself.  When the name of a built-in command is used as the first word of a simple command, the shell executes the command directly, without creating a new process.  Built-in commands are necessary to implement functionality impossible or inconvenient to obtain with separate utilities.</P
><P
>Bash supports 3 types of built-in commands:</P
><P
></P
><UL
><LI
><P
>Bourne Shell built-ins:</P
><P
><B
CLASS="command"
>:</B
>, <B
CLASS="command"
>.</B
>, <B
CLASS="command"
>break</B
>, <B
CLASS="command"
>cd</B
>, <B
CLASS="command"
>continue</B
>, <B
CLASS="command"
>eval</B
>, <B
CLASS="command"
>exec</B
>, <B
CLASS="command"
>exit</B
>, <B
CLASS="command"
>export</B
>, <B
CLASS="command"
>getopts</B
>, <B
CLASS="command"
>hash</B
>, <B
CLASS="command"
>pwd</B
>, <B
CLASS="command"
>readonly</B
>, <B
CLASS="command"
>return</B
>, <B
CLASS="command"
>set</B
>, <B
CLASS="command"
>shift</B
>, <B
CLASS="command"
>test</B
>, <B
CLASS="command"
>[</B
>, <B
CLASS="command"
>times</B
>, <B
CLASS="command"
>trap</B
>, <B
CLASS="command"
>umask</B
> and <B
CLASS="command"
>unset</B
>.</P
></LI
><LI
><P
>Bash built-in commands:</P
><P
><B
CLASS="command"
>alias</B
>, <B
CLASS="command"
>bind</B
>, <B
CLASS="command"
>builtin</B
>, <B
CLASS="command"
>command</B
>, <B
CLASS="command"
>declare</B
>, <B
CLASS="command"
>echo</B
>, <B
CLASS="command"
>enable</B
>, <B
CLASS="command"
>help</B
>, <B
CLASS="command"
>let</B
>, <B
CLASS="command"
>local</B
>, <B
CLASS="command"
>logout</B
>, <B
CLASS="command"
>printf</B
>, <B
CLASS="command"
>read</B
>, <B
CLASS="command"
>shopt</B
>, <B
CLASS="command"
>type</B
>, <B
CLASS="command"
>typeset</B
>, <B
CLASS="command"
>ulimit</B
> and <B
CLASS="command"
>unalias</B
>.</P
></LI
><LI
><P
>Special built-in commands:</P
><P
>When Bash is executing in POSIX mode, the special built-ins differ from other built-in commands in three respects:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Special built-ins are found before shell functions during command lookup.</P
></LI
><LI
><P
>If a special built-in returns an error status, a non-interactive shell exits.</P
></LI
><LI
><P
>Assignment statements preceding the command stay in effect in the shell environment after the command completes.</P
></LI
></OL
><P
>The POSIX special built-ins are <B
CLASS="command"
>:</B
>, <B
CLASS="command"
>.</B
>, <B
CLASS="command"
>break</B
>, <B
CLASS="command"
>continue</B
>, <B
CLASS="command"
>eval</B
>, <B
CLASS="command"
>exec</B
>, <B
CLASS="command"
>exit</B
>, <B
CLASS="command"
>export</B
>, <B
CLASS="command"
>readonly</B
>, <B
CLASS="command"
>return</B
>, <B
CLASS="command"
>set</B
>, <B
CLASS="command"
>shift</B
>, <B
CLASS="command"
>trap</B
> and <B
CLASS="command"
>unset</B
>.</P
></LI
></UL
><P
>Most of these built-ins will be discussed in the next chapters.  For those commands for which this is not the case, we refer to the Info pages.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_01_03_03"
></A
>1.3.3. Executing programs from a script</H2
><P
>When the program being executed is a shell script, bash will create a new bash process using a <EM
>fork</EM
>.  This subshell reads the lines from the shell script one line at a time.  Commands on each line are read, interpreted and executed as if they would have come directly from the keyboard.</P
><P
>While the subshell processes each line of the script, the parent shell waits for its child process to finish.  When there are no more lines in the shell script to read, the subshell terminates.  The parent shell awakes and displays a new prompt.</P
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="sect_01_04"
></A
>1.4. Building blocks</H1
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="sect_01_04_01"
></A
>1.4.1. Shell building blocks</H2
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="sect_01_04_01_01"
></A
>1.4.1.1. Shell syntax</H3
><P
>If input is not commented, the shell reads it and divides it into words and operators, employing quoting rules to define the meaning of each character of input.  Then these words and operators are translated into commands and other constructs, which return an exit status available for inspection or processing.  The above fork-and-exec scheme is only applied after the shell has analyzed input in the following way:</P
><P
></P
><UL
><LI
><P
>The shell reads its input from a file, from a string or from the user's terminal.</P
></LI
><LI
><P
>Input is broken up into words and operators, obeying the quoting rules, see <A
HREF="#chap_03"
>Chapter 3</A
>.  These tokens are separated by <EM
>metacharacters</EM
>.  Alias expansion is performed.</P
></LI
><LI
><P
>The shell <EM
>parses</EM
> (analyzes and substitutes) the tokens into simple and compound commands.</P
></LI
><LI
><P
>Bash performs various shell expansions, breaking the expanded tokens into lists of filenames and commands and arguments.</P
></LI
><LI
><P
>Redirection is performed if necessary, redirection operators and their operands are removed from the argument list.</P
></LI
><LI
><P
>Commands are executed.</P
></LI
><LI
><P
>Optionally the shell waits for the command to complete and collects its exit status.</P
></LI
></UL
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="sect_01_04_01_02"
></A
>1.4.1.2. Shell commands</H3
><P
>A simple shell command such as <B
CLASS="command"
>touch <TT
CLASS="filename"
>file1</TT
> <TT
CLASS="filename"
>file2</TT
> <TT
CLASS="filename"
>file3</TT
></B
> consists of the command itself followed by arguments, separated by spaces.</P
><P
>More complex shell commands are composed of simple commands arranged together in a variety of ways: in a pipeline in which the output of one command becomes the input of a second, in a loop or conditional construct, or in some other grouping.  A couple of examples:</P
><P
><B
CLASS="command"
>ls | more</B
> </P
><P
><B
CLASS="command"
>gunzip <TT
CLASS="filename"
>file.tar.gz</TT
> | tar <TT
CLASS="option"
>xvf</TT
> <TT
CLASS="parameter"
><I
>-</I
></TT
></B
> </P
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="sect_01_04_01_03"
></A
>1.4.1.3. Shell functions</H3
><P
>Shell functions are a way to group commands for later execution using a single name for the group.  They are executed just like a <SPAN
CLASS="QUOTE"
>"regular"</SPAN
> command.  When the name of a shell function is used as a simple command name, the list of commands associated with that function name is executed.</P
><P
>Shell functions are executed in the current shell context; no new process is created to interpret them.</P
><P
>Functions are explained in <A
HREF="#chap_11"
>Chapter 11</A
>.</P
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="sect_01_04_01_04"
></A
>1.4.1.4. Shell parameters</H3
><P
>A parameter is an entity that stores values.  It can be a name, a number or a special value.  For the shell's purpose, a variable is a parameter that stores a name.  A variable has a value and zero or more attributes.  Variables are created with the <B
CLASS="command"
>declare</B
> shell built-in command.</P
><P
>If no value is given, a variable is assigned the null string.  Variables can only be removed with the <B
CLASS="command"
>unset</B
> built-in.</P
><P
>Assigning variables is discussed in <A
HREF="#sect_03_02"
>Section 3.2</A
>, advanced use of variables in <A
HREF="#chap_10"
>Chapter 10</A
>.</P
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="sect_01_04_01_05"
></A
>1.4.1.5. Shell expansions</H3
><P
>Shell expansion is performed after each command line has been split into tokens.  These are the expansions performed:</P
><P
></P
><UL
><LI
><P
>Brace expansion</P
></LI
><LI
><P
>Tilde expansion</P
></LI
><LI
><P
>Parameter and variable expansion</P
></LI
><LI
><P
>Command substitution</P
></LI
><LI
><P
>Arithmetic expansion</P
></LI
><LI
><P
>Word splitting</P
></LI
><LI
><P
>Filename expansion</P
></LI
></UL
><P
>We'll discuss these expansion types in detail in <A
HREF="#sect_03_04"
>Section 3.4</A
>.</P
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="sect_01_04_01_06"
></A
>1.4.1.6. Redirections</H3
><P
>Before a command is executed, its input and output may be redirected using a special notation interpreted by the shell.  Redirection may also be used to open and close files for the current shell execution environment.</P
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="sect_01_04_01_07"
></A
>1.4.1.7. Executing commands</H3
><P
>When executing a command, the words that the parser has marked as variable assignments (preceding the command name) and redirections are saved for later reference.  Words that are not variable assignments or redirections are expanded; the first remaining word after expansion is taken to be the name of the command and the rest are arguments to that command.  Then redirections are performed, then strings assigned to variables are expanded.  If no command name results, variables will affect the current shell environment.</P
><P
>An important part of the tasks of the shell is to search for commands.  Bash does this as follows:</P
><P
></P
><UL
><LI
><P
>Check whether the command contains slashes.  If not, first check with the function list to see if it contains a command by the name we are looking for.</P
></LI
><LI
><P
>If command is not a function, check for it in the built-in list.</P
></LI
><LI
><P
>If command is neither a function nor a built-in, look for it analyzing the directories listed in <TT
CLASS="varname"
>PATH</TT
>.  Bash uses a <EM
>hash table</EM
> (data storage area in memory) to remember the full path names of executables so extensive <TT
CLASS="varname"
>PATH</TT
> searches can be avoided.</P
></LI
><LI
><P
>If the search is unsuccessful, bash prints an error message and returns an exit status of 127.</P
></LI
><LI
><P
>If the search was successful or if the command contains slashes, the shell executes the command in a separate execution environment.</P
></LI
><LI
><P
>If execution fails because the file is not executable and not a directory, it is assumed to be a shell script.</P
></LI
><LI
><P
>If the command was not begun asynchronously, the shell waits for the command to complete and collects its exit status.</P
></LI
></UL
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="sect_01_04_01_08"
></A
>1.4.1.8. Shell scripts</H3
><P
>When a file containing shell commands is used as the first non-option argument when invoking Bash (without <TT
CLASS="option"
>-c</TT
> or <TT
CLASS="option"
>-s</TT
>, this will create a non-interactive shell.  This shell first searches for the script file in the current directory, then looks in <TT
CLASS="varname"
>PATH</TT
> if the file cannot be found there.</P
></DIV
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="sect_01_05"
></A
>1.5. Developing good scripts</H1
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="sect_01_05_01"
></A
>1.5.1. Properties of good scripts</H2
><P
>This guide is mainly about the last shell building block, scripts.  Some general considerations before we continue:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>A script should run without errors.</P
></LI
><LI
><P
>It should perform the task for which it is intended.</P
></LI
><LI
><P
>Program logic is clearly defined and apparent.</P
></LI
><LI
><P
>A script does not do unnecessary work.</P
></LI
><LI
><P
>Scripts should be reusable.</P
></LI
></OL
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_01_05_02"
></A
>1.5.2. Structure</H2
><P
>The structure of a shell script is very flexible.  Even though in Bash a lot of freedom is granted, you must ensure correct logic, flow control and efficiency so that users executing the script can do so easily and correctly.</P
><P
>When starting on a new script, ask yourself the following questions:</P
><P
></P
><UL
><LI
><P
>Will I be needing any information from the user or from the user's environment?</P
></LI
><LI
><P
>How will I store that information?</P
></LI
><LI
><P
>Are there any files that need to be created?  Where and with which permissions and ownerships?</P
></LI
><LI
><P
>What commands will I use?  When using the script on different systems, do all these systems have these commands in the required versions?</P
></LI
><LI
><P
>Does the user need any notifications?  When and why?</P
></LI
></UL
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_01_05_03"
></A
>1.5.3. Terminology</H2
><P
>The table below gives an overview of programming terms that you need to be familiar with:</P
><DIV
CLASS="table"
><A
NAME="table_01_01"
></A
><P
><B
>Table 1-1. Overview of programming terms</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
>Term</TH
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
>What is it?</TH
></TR
></THEAD
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Command control</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Testing exit status of a command in order to determine whether a portion of the program should be executed.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Conditional branch</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Logical point in the program when a condition determines what happens next.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Logic flow</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>The overall design of the program.  Determines logical sequence of tasks so that the result is successful and controlled.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Loop</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Part of the program that is performed zero or more times.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>User input</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Information provided by an external source while the program is running, can be stored and recalled when needed.</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_01_05_04"
></A
>1.5.4. A word on order and logic</H2
><P
>In order to speed up the developing process, the logical order of a program should be thought over in advance.  This is your first step when developing a script.</P
><P
>A number of methods can be used; one of the most common is working with lists.  Itemizing the list of tasks involved in a program allows you to describe each process.  Individual tasks can be referenced by their item number.</P
><P
>Using your own spoken language to pin down the tasks to be executed by your program will help you to create an understandable form of your program.  Later, you can replace the everyday language statements with shell language words and constructs.</P
><P
>The example below shows such a logic flow design.  It describes the rotation of log files.  This example shows a possible repetitive loop, controlled by the number of base log files you want to rotate:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Do you want to rotate logs?</P
><P
></P
><OL
TYPE="a"
><LI
><P
>If yes:</P
><P
></P
><OL
TYPE="i"
><LI
><P
>Enter directory name containing the logs to be rotated.</P
></LI
><LI
><P
>Enter base name of the log file.</P
></LI
><LI
><P
>Enter number of days logs should be kept.</P
></LI
><LI
><P
>Make settings permanent in user's crontab file.</P
></LI
></OL
></LI
><LI
><P
>If no, go to step 3.</P
></LI
></OL
></LI
><LI
><P
>Do you want to rotate another set of logs?</P
><P
></P
><OL
TYPE="a"
><LI
><P
>If yes: repeat step 1.</P
></LI
><LI
><P
>If no: go to step 3.</P
></LI
></OL
></LI
><LI
><P
>Exit</P
></LI
></OL
><P
>The user should provide information for the program to do something.  Input from the user must be obtained and stored.  The user should be notified that his crontab will change.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_01_05_05"
></A
>1.5.5. An example Bash script: mysystem.sh</H2
><P
>The <TT
CLASS="filename"
>mysystem.sh</TT
> script below executes some well-known commands (<B
CLASS="command"
>date</B
>, <B
CLASS="command"
>w</B
>, <B
CLASS="command"
>uname</B
>, <B
CLASS="command"
>uptime</B
>) to display information about you and your machine.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>tom:~&#62;</TT
> <B
CLASS="command"
>cat <TT
CLASS="option"
>-n</TT
> <TT
CLASS="filename"
>mysystem.sh</TT
></B
>
     1  #!/bin/bash
     2  clear
     3  echo "This is information provided by mysystem.sh.  Program starts now."
     4
     5  echo "Hello, $USER"
     6  echo
     7
     8  echo "Today's date is `date`, this is week `date +"%V"`."
     9  echo
    10
    11  echo "These users are currently connected:"
    12  w | cut -d " " -f 1 - | grep -v USER | sort -u
    13  echo
    14
    15  echo "This is `uname -s` running on a `uname -m` processor."
    16  echo
    17
    18  echo "This is the uptime information:"
    19  uptime
    20  echo
    21
    22  echo "That's all folks!"
</PRE
></FONT
></TD
></TR
></TABLE
><P
>A script always starts with the same two characters, <SPAN
CLASS="QUOTE"
>"#!"</SPAN
>.  After that, the shell that will execute the commands following the first line is defined.  This script starts with clearing the screen on line 2.  Line 3 makes it print a message, informing the user about what is going to happen.  Line 5 greets the user.  Lines 6, 9, 13, 16 and 20 are only there for orderly output display purposes.  Line 8 prints the current date and the number of the week.  Line 11 is again an informative message, like lines 3, 18 and 22.  Line 12 formats the output of the <B
CLASS="command"
>w</B
>; line 15 shows operating system and CPU information.  Line 19 gives the uptime and load information.</P
><P
>Both <B
CLASS="command"
>echo</B
> and <B
CLASS="command"
>printf</B
> are Bash built-in commands.  The first always exits with a 0 status, and simply prints arguments followed by an end of line character on the standard output, while the latter allows for definition of a formatting string and gives a non-zero exit status code upon failure.</P
><P
>This is the same script using the <B
CLASS="command"
>printf</B
> built-in:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>tom:~&#62;</TT
> <B
CLASS="command"
>cat <TT
CLASS="filename"
>mysystem.sh</TT
></B
>
#!/bin/bash
clear
printf "This is information provided by mysystem.sh.  Program starts now.\n"

printf "Hello, $USER.\n\n"

printf "Today's date is `date`, this is week `date +"%V"`.\n\n"

printf "These users are currently connected:\n"
w | cut -d " " -f 1 - | grep -v USER | sort -u
printf "\n"

printf "This is `uname -s` running on a `uname -m` processor.\n\n"

printf "This is the uptime information:\n"
uptime
printf "\n"

printf "That's all folks!\n"
</PRE
></FONT
></TD
></TR
></TABLE
><P
>Creating user friendly scripts by means of inserting messages is treated in <A
HREF="#chap_08"
>Chapter 8</A
>.</P
><DIV
CLASS="note"
><P
></P
><TABLE
CLASS="note"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>Standard location of the Bourne Again shell</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This implies that the <B
CLASS="command"
>bash</B
> program is installed in <TT
CLASS="filename"
>/bin</TT
>.</P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="warning"
><P
></P
><TABLE
CLASS="warning"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="images/warning.gif"
HSPACE="5"
ALT="Warning"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>If stdout is not available</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>If you execute a script from cron, supply full path names and redirect output and errors.  Since the shell runs in non-interactive mode, any errors will cause the script to exit prematurely if you don't think about this.</P
></TD
></TR
></TABLE
></DIV
><P
>The following chapters will discuss the details of the above scripts.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_01_05_06"
></A
>1.5.6. Example init script</H2
><P
>An init script starts system services on UNIX and Linux machines.  The system log daemon, the power management daemon, the name and mail daemons are common examples.  These scripts, also known as startup scripts, are stored in a specific location on your system, such as <TT
CLASS="filename"
>/etc/rc.d/init.d</TT
> or <TT
CLASS="filename"
>/etc/init.d</TT
>.  Init, the initial process, reads its configuration files and decides which services to start or stop in each run level.  A run level is a configuration of processes; each system has a single user run level, for instance, for performing administrative tasks, for which the system has to be in an unused state as much as possible, such as recovering a critical file system from a backup.  Reboot and shutdown run levels are usually also configured.</P
><P
>The tasks to be executed upon starting a service or stopping it are listed in the startup scripts.  It is one of the system administrator's tasks to configure <B
CLASS="command"
>init</B
>, so that services are started and stopped at the correct moment.  When confronted with this task, you need a good understanding of the startup and shutdown procedures on your system.  We therefore advise that you read the man pages for <B
CLASS="command"
>init</B
> and <TT
CLASS="filename"
>inittab</TT
> before starting on your own initialization scripts.</P
><P
>Here is a very simple example, that will play a sound upon starting and stopping your machine:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;#!/bin/bash

# This script is for /etc/rc.d/init.d
# Link in rc3.d/S99audio-greeting and rc0.d/K01audio-greeting

case "$1" in
'start')
  cat /usr/share/audio/at_your_service.au &#62; /dev/audio
  ;;
'stop')
  cat /usr/share/audio/oh_no_not_again.au &#62; /dev/audio
  ;;
esac
exit 0
</PRE
></FONT
></TD
></TR
></TABLE
><P
>The <B
CLASS="command"
>case</B
> statement often used in this kind of script is described in <A
HREF="#sect_07_02_05"
>Section 7.2.5</A
>.</P
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="sect_01_06"
></A
>1.6. Summary</H1
><P
>Bash is the GNU shell, compatible with the Bourne shell and incorporating many useful features from other shells.  When the shell is started, it reads its configuration files.  The most important are:</P
><P
></P
><UL
><LI
><P
><TT
CLASS="filename"
>/etc/profile</TT
></P
></LI
><LI
><P
><TT
CLASS="filename"
>~/.bash_profile</TT
></P
></LI
><LI
><P
><TT
CLASS="filename"
>~/.bashrc</TT
></P
></LI
></UL
><P
>Bash behaves different when in interactive mode and also has a POSIX compliant and a restricted mode.</P
><P
>Shell commands can be split up in three groups: the shell functions, shell built-ins and existing commands in a directory on your system.  Bash supports additional built-ins not found in the plain Bourne shell.</P
><P
>Shell scripts consist of these commands arranged as shell syntax dictates.  Scripts are read and executed line per line and should have a logical structure.</P
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="sect_01_07"
></A
>1.7. Exercises</H1
><P
>These are some exercises to warm you up for the next chapter:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Where is the <B
CLASS="command"
>bash</B
> program located on your system?</P
></LI
><LI
><P
>Use the <TT
CLASS="option"
>--version</TT
> option to find out which version you are running.</P
></LI
><LI
><P
>Which shell configuration files are read when you login to your system using the graphical user interface and then opening a terminal window?</P
></LI
><LI
><P
>Are the following shells interactive shells?  Are they login shells?</P
><P
></P
><UL
><LI
><P
>A shell opened by clicking on the background of your graphical desktop, selecting <SPAN
CLASS="QUOTE"
>"Terminal"</SPAN
> or such from a menu.</P
></LI
><LI
><P
>A shell that you get after issuing the command <B
CLASS="command"
>ssh <TT
CLASS="parameter"
><I
>localhost</I
></TT
></B
>.</P
></LI
><LI
><P
>A shell that you get when logging in to the console in text mode.</P
></LI
><LI
><P
>A shell obtained by the command <B
CLASS="command"
>xterm &#38;</B
>.</P
></LI
><LI
><P
>A shell opened by the <B
CLASS="command"
>mysystem.sh</B
> script.</P
></LI
><LI
><P
>A shell that you get on a remote host, for which you didn't have to give the login and/or password because you use SSH and maybe SSH keys.</P
></LI
></UL
></LI
><LI
><P
>Can you explain why <B
CLASS="command"
>bash</B
> does not exit when you type <B
CLASS="keycap"
>Ctrl</B
>+<B
CLASS="keycap"
>C</B
> on the command line?</P
></LI
><LI
><P
>Display directory stack content.</P
></LI
><LI
><P
>If it is not yet the case, set your prompt so that it displays your location in the file system hierarchy, for instance add this line to <TT
CLASS="filename"
>~/.bashrc</TT
>:</P
><P
><B
CLASS="command"
>export <TT
CLASS="varname"
>PS1</TT
>="<TT
CLASS="parameter"
><I
>\u@\h \w&#62; </I
></TT
>"</B
> </P
></LI
><LI
><P
>Display hashed commands for your current shell session.</P
></LI
><LI
><P
>How many processes are currently running on your system?  Use <B
CLASS="command"
>ps</B
> and <B
CLASS="command"
>wc</B
>, the first line of output of <B
CLASS="command"
>ps</B
> is not a process!</P
></LI
><LI
><P
>How to display the system hostname?  Only the name, nothing more!</P
></LI
></OL
></DIV
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="chap_02"
></A
>Chapter 2. Writing and debugging scripts</H1
><BLOCKQUOTE
CLASS="ABSTRACT"
><DIV
CLASS="abstract"
><A
NAME="AEN1338"
></A
><P
></P
><P
>After going through this chapter, you will be able to:</P
><P
><P
></P
><UL
><LI
><P
>Write a simple script</P
></LI
><LI
><P
>Define the shell type that should execute the script</P
></LI
><LI
><P
>Put comments in a script</P
></LI
><LI
><P
>Change permissions on a script</P
></LI
><LI
><P
>Execute and debug a script</P
></LI
></UL
></P
><P
></P
></DIV
></BLOCKQUOTE
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="sect_02_01"
></A
>2.1. Creating and running a script</H1
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="sect_02_01_01"
></A
>2.1.1. Writing and naming</H2
><P
>A shell script is a sequence of commands for which you have a repeated use.  This sequence is typically executed by entering the name of the script on the command line.  Alternatively, you can use scripts to automate tasks using the cron facility.  Another use for scripts is in the UNIX boot and shutdown procedure, where operation of daemons and services are defined in init scripts.</P
><P
>To create a shell script, open a new empty file in your editor.  Any text editor will do: <B
CLASS="command"
>vim</B
>, <B
CLASS="command"
>emacs</B
>, <B
CLASS="command"
>gedit</B
>, <B
CLASS="command"
>dtpad</B
> et cetera are all valid.  You might want to chose a more advanced editor like <B
CLASS="command"
>vim</B
> or <B
CLASS="command"
>emacs</B
>, however, because these can be configured to recognize shell and Bash syntax and can be a great help in preventing those errors that beginners frequently make, such as forgetting brackets and semi-colons.</P
><DIV
CLASS="tip"
><P
></P
><TABLE
CLASS="tip"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="images/tip.gif"
HSPACE="5"
ALT="Tip"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>Syntax highlighting in vim</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>In order to activate syntax highlighting in <B
CLASS="command"
>vim</B
>, use the command</P
><P
><B
CLASS="command"
>:syntax enable</B
> </P
><P
>or</P
><P
><B
CLASS="command"
>:sy enable</B
> </P
><P
>or</P
><P
><B
CLASS="command"
>:syn enable</B
> </P
><P
>You can add this setting to your <TT
CLASS="filename"
>.vimrc</TT
> file to make it permanent.</P
></TD
></TR
></TABLE
></DIV
><P
>Put UNIX commands in the new empty file, like you would enter them on the command line.   As discussed in the previous chapter (see <A
HREF="#sect_01_03"
>Section 1.3</A
>), commands can be shell functions, shell built-ins, UNIX commands and other scripts.</P
><P
>Give your script a sensible name that gives a hint about what the script does.  Make sure that your script name does not conflict with existing commands.  In order to ensure that no confusion can rise, script names often end in <TT
CLASS="filename"
>.sh</TT
>; even so, there might be other scripts on your system with the same name as the one you chose.  Check using <B
CLASS="command"
>which</B
>, <B
CLASS="command"
>whereis</B
> and other commands for finding information about programs and files:</P
><P
><B
CLASS="command"
>which <TT
CLASS="option"
>-a</TT
> <TT
CLASS="filename"
>script_name</TT
></B
> </P
><P
><B
CLASS="command"
>whereis <TT
CLASS="filename"
>script_name</TT
></B
> </P
><P
><B
CLASS="command"
>locate <TT
CLASS="filename"
>script_name</TT
></B
> </P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_02_01_02"
></A
>2.1.2. script1.sh</H2
><P
>In this example we use the <B
CLASS="command"
>echo</B
> Bash built-in to inform the user about what is going to happen, before the task that will create the output is executed.  It is strongly advised to inform users about what a script is doing, in order to prevent them from becoming nervous <EM
>because the script is not doing anything</EM
>.  We will return to the subject of notifying users in <A
HREF="#chap_08"
>Chapter 8</A
>.</P
><DIV
CLASS="figure"
><A
NAME="AEN1409"
></A
><P
><B
>Figure 2-1. script1.sh</B
></P
><DIV
CLASS="mediaobject"
><P
><IMG
SRC="images/script1.sh.png"></P
></DIV
></DIV
><P
>Write this script for yourself as well.  It might be a good idea to create a directory <TT
CLASS="filename"
>~/scripts</TT
> to hold your scripts.  Add the directory to the contents of the <TT
CLASS="varname"
>PATH</TT
> variable:</P
><P
><B
CLASS="command"
>export <TT
CLASS="varname"
>PATH</TT
>="<TT
CLASS="varname"
>$PATH</TT
>:<TT
CLASS="filename"
>~/scripts</TT
>"</B
> </P
><P
>If you are just getting started with Bash, use a text editor that uses different colours for different shell constructs.  Syntax highlighting is supported by <B
CLASS="command"
>vim</B
>, <B
CLASS="command"
>gvim</B
>, <B
CLASS="command"
>(x)emacs</B
>, <B
CLASS="command"
>kwrite</B
> and many other editors; check the documentation of your favorite editor.</P
><DIV
CLASS="note"
><P
></P
><TABLE
CLASS="note"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>Different prompts</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The prompts throughout this course vary depending on the author's mood.  This resembles much more real life situations than the standard educational <EM
>$</EM
> prompt.  The only convention we stick to, is that the <EM
>root</EM
> prompt ends in a hash mark (#).</P
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_02_01_03"
></A
>2.1.3. Executing the script</H2
><P
>The script should have execute permissions for the correct owners in order to be runnable.  When setting permissions, check that you really obtained the permissions that you want.  When this is done, the script can run like any other command:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>willy:~/scripts&#62;</TT
> <B
CLASS="command"
>chmod <TT
CLASS="option"
>u+x</TT
> <TT
CLASS="filename"
>script1.sh</TT
></B
>

<TT
CLASS="prompt"
>willy:~/scripts&#62;</TT
> <B
CLASS="command"
>ls <TT
CLASS="option"
>-l</TT
> <TT
CLASS="filename"
>script1.sh</TT
></B
>
-rwxrw-r--    1 willy	willy		456 Dec 24 17:11 script1.sh

<TT
CLASS="prompt"
>willy:~&#62;</TT
> <B
CLASS="command"
>script1.sh</B
>
The script starts now.
Hi, willy!

I will now fetch you a list of connected users:

  3:38pm  up 18 days,  5:37,  4 users,  load average: 0.12, 0.22, 0.15
USER     TTY      FROM              LOGIN@   IDLE   JCPU   PCPU  WHAT
root     tty2     -                Sat 2pm  4:25m  0.24s  0.05s  -bash
willy	 :0       -                Sat 2pm   ?     0.00s   ?     -
willy    pts/3    -                Sat 2pm  3:33m 36.39s 36.39s  BitchX willy ir
willy    pts/2    -                Sat 2pm  3:33m  0.13s  0.06s  /usr/bin/screen

I'm setting two variables now.
This is a string: black
And this is a number: 9

I'm giving you back your prompt now.

<TT
CLASS="prompt"
>willy:~/scripts&#62;</TT
> <B
CLASS="command"
>echo <TT
CLASS="varname"
>$COLOUR</TT
></B
>

<TT
CLASS="prompt"
>willy:~/scripts&#62;</TT
> <B
CLASS="command"
>echo <TT
CLASS="varname"
>$VALUE</TT
></B
>

<TT
CLASS="prompt"
>willy:~/scripts&#62;</TT
>
</PRE
></FONT
></TD
></TR
></TABLE
><P
>This is the most common way to execute a script.  It is preferred to execute the script like this in a subshell.  The variables, functions and aliases created in this subshell are only known to the particular bash session of that subshell.  When that shell exits and the parent regains control, everything is cleaned up and all changes to the state of the shell made by the script, are forgotten.</P
><P
>If you did not put the <TT
CLASS="filename"
>scripts</TT
> directory in your <TT
CLASS="varname"
>PATH</TT
>, and <TT
CLASS="filename"
>.</TT
> (the current directory) is not in the <TT
CLASS="varname"
>PATH</TT
> either, you can activate the script like this:</P
><P
><B
CLASS="command"
>./script_name.sh</B
> </P
><P
>A script can also explicitly be executed by a given shell, but generally we only do this if we want to obtain special behavior, such as checking if the script works with another shell or printing traces for debugging:</P
><P
><B
CLASS="command"
>rbash <TT
CLASS="filename"
>script_name.sh</TT
></B
> </P
><P
><B
CLASS="command"
>sh <TT
CLASS="filename"
>script_name.sh</TT
></B
> </P
><P
><B
CLASS="command"
>bash <TT
CLASS="option"
>-x</TT
> <TT
CLASS="filename"
>script_name.sh</TT
></B
> </P
><P
>The specified shell will start as a subshell of your current shell and execute the script.  This is done when you want the script to start up with specific options or under specific conditions which are not specified in the script.</P
><P
>If you don't want to start a new shell but execute the script in the current shell, you <EM
>source</EM
> it:</P
><P
><B
CLASS="command"
>source <TT
CLASS="filename"
>script_name.sh</TT
></B
> </P
><DIV
CLASS="tip"
><P
></P
><TABLE
CLASS="tip"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="images/tip.gif"
HSPACE="5"
ALT="Tip"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>source = .</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The Bash <B
CLASS="command"
>source</B
> built-in is a synonym for the Bourne shell <B
CLASS="command"
>.</B
> (dot) command.</P
></TD
></TR
></TABLE
></DIV
><P
>The script does not need execute permission in this case.  Commands are executed in the current shell context, so any changes made to your environment will be visible when the script finishes execution:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>willy:~/scripts&#62;</TT
> <B
CLASS="command"
>source <TT
CLASS="filename"
>script1.sh</TT
></B
>
--output ommitted--

<TT
CLASS="prompt"
>willy:~/scripts&#62;</TT
> <B
CLASS="command"
>echo <TT
CLASS="varname"
>$VALUE</TT
></B
>
9

<TT
CLASS="prompt"
>willy:~/scripts&#62;</TT
>
</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="sect_02_02"
></A
>2.2. Script basics</H1
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="sect_02_02_01"
></A
>2.2.1. Which shell will run the script?</H2
><P
>When running a script in a subshell, you should define which shell should run the script.  The shell type in which you wrote the script might not be the default on your system, so commands you entered might result in errors when executed by the wrong shell.</P
><P
>The first line of the script determines the shell to start.  The first two characters of the first line should be <EM
>#!</EM
>, then follows the path to the shell that should interpret the commands that follow.  Blank lines are also considered to be lines, so don't start your script with an empty line.</P
><P
>For the purpose of this course, all scripts will start with the line</P
><P
><B
CLASS="command"
>#!/bin/bash</B
> </P
><P
>As noted before, this implies that the Bash executable can be found in <TT
CLASS="filename"
>/bin</TT
>.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_02_02_02"
></A
>2.2.2. Adding comments</H2
><P
>You should be aware of the fact that you might not be the only person reading your code.  A lot of users and system administrators run scripts that were written by other people.  If they want to see how you did it, comments are useful to enlighten the reader.</P
><P
>Comments also make your own life easier.  Say that you had to read a lot of man pages in order to achieve a particular result with some command that you used in your script.   You won't remember how it worked if you need to change your script after a few weeks or months, unless you have commented what you did, how you did it and/or why you did it.</P
><P
>Take the <TT
CLASS="filename"
>script1.sh</TT
> example and copy it to <TT
CLASS="filename"
>commented-script1.sh</TT
>, which we edit so that the comments reflect what the script does.  Everything the shell encounters after a hash mark on a line is ignored and only visible upon opening the shell script file:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;#!/bin/bash
# This script clears the terminal, displays a greeting and gives information
# about currently connected users.  The two example variables are set and displayed.

clear				# clear terminal window

echo "The script starts now."

echo "Hi, $USER!"		# dollar sign is used to get content of variable
echo

echo "I will now fetch you a list of connected users:"
echo							
w				# show who is logged on and
echo				# what they are doing

echo "I'm setting two variables now."
COLOUR="black"					# set a local shell variable
VALUE="9"					# set a local shell variable
echo "This is a string: $COLOUR"		# display content of variable 
echo "And this is a number: $VALUE"		# display content of variable
echo

echo "I'm giving you back your prompt now."
echo
</PRE
></FONT
></TD
></TR
></TABLE
><P
>In a decent script, the first lines are usually comment about what to expect.  Then each big chunk of commands will be commented as needed for clarity's sake.  Linux init scripts, as an example, in your system's <TT
CLASS="filename"
>init.d</TT
> directory, are usually well commented since they have to be readable and editable by everyone running Linux.</P
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="sect_02_03"
></A
>2.3. Debugging Bash scripts</H1
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="sect_02_03_01"
></A
>2.3.1. Debugging on the entire script</H2
><P
>When things don't go according to plan, you need to determine what exactly causes the script to fail.  Bash provides extensive debugging features.  The most common is to start up the subshell with the <TT
CLASS="option"
>-x</TT
> option, which will run the entire script in debug mode.  Traces of each command plus its arguments are printed to standard output after the commands have been expanded but before they are executed.</P
><P
>This is the <TT
CLASS="filename"
>commented-script1.sh</TT
> script ran in debug mode.  Note again that the added comments are not visible in the output of the script.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>willy:~/scripts&#62;</TT
> <B
CLASS="command"
>bash <TT
CLASS="option"
>-x</TT
> <TT
CLASS="filename"
>script1.sh</TT
></B
>
+ clear

+ echo 'The script starts now.'
The script starts now.
+ echo 'Hi, willy!'
Hi, willy!
+ echo

+ echo 'I will now fetch you a list of connected users:'
I will now fetch you a list of connected users:
+ echo

+ w
  4:50pm  up 18 days,  6:49,  4 users,  load average: 0.58, 0.62, 0.40
USER     TTY      FROM              LOGIN@   IDLE   JCPU   PCPU  WHAT
root     tty2     -                Sat 2pm  5:36m  0.24s  0.05s  -bash
willy	 :0       -                Sat 2pm   ?     0.00s   ?     -
willy	 pts/3    -                Sat 2pm 43:13  36.82s 36.82s  BitchX willy ir
willy    pts/2    -                Sat 2pm 43:13   0.13s  0.06s  /usr/bin/screen
+ echo

+ echo 'I'\''m setting two variables now.'
I'm setting two variables now.
+ COLOUR=black
+ VALUE=9
+ echo 'This is a string: '
This is a string:
+ echo 'And this is a number: '
And this is a number:
+ echo

+ echo 'I'\''m giving you back your prompt now.'
I'm giving you back your prompt now.
+ echo
</PRE
></FONT
></TD
></TR
></TABLE
><P
>There is now a full-fledged debugger for Bash, available at <A
HREF="http://bashdb.sourceforge.net"
TARGET="_top"
>SourceForge</A
>.  These debugging features are available in most modern versions of Bash, starting from 3.x.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_02_03_02"
></A
>2.3.2. Debugging on part(s) of the script</H2
><P
>Using the <B
CLASS="command"
>set</B
> Bash built-in you can run in normal mode those portions of the script of which you are sure they are without fault, and display debugging information only for troublesome zones.  Say we are not sure what the <B
CLASS="command"
>w</B
> command will do in the example <TT
CLASS="filename"
>commented-script1.sh</TT
>, then we could enclose it in the script like this:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;set -x			# activate debugging from here
w
set +x			# stop debugging from here
</PRE
></FONT
></TD
></TR
></TABLE
><P
>Output then looks like this:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>willy: ~/scripts&#62;</TT
> <B
CLASS="command"
>script1.sh</B
>
The script starts now.
Hi, willy!

I will now fetch you a list of connected users:

+ w
  5:00pm  up 18 days,  7:00,  4 users,  load average: 0.79, 0.39, 0.33
USER     TTY      FROM              LOGIN@   IDLE   JCPU   PCPU  WHAT
root     tty2     -                Sat 2pm  5:47m  0.24s  0.05s  -bash
willy    :0       -                Sat 2pm   ?     0.00s   ?     -
willy    pts/3    -                Sat 2pm 54:02  36.88s 36.88s  BitchX willyke
willy    pts/2    -                Sat 2pm 54:02   0.13s  0.06s  /usr/bin/screen
+ set +x

I'm setting two variables now.
This is a string:
And this is a number:

I'm giving you back your prompt now.

<TT
CLASS="prompt"
>willy: ~/scripts&#62;</TT
>
</PRE
></FONT
></TD
></TR
></TABLE
><P
>You can switch debugging mode on and off as many times as you want within the same script.</P
><P
>The table below gives an overview of other useful Bash options:</P
><DIV
CLASS="table"
><A
NAME="table_02_01"
></A
><P
><B
>Table 2-1. Overview of set debugging options</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
>Short notation</TH
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
>Long notation</TH
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
>Result</TH
></TR
></THEAD
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>set -f</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>set -o noglob</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Disable file name generation using metacharacters (globbing).</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>set -v</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>set -o verbose</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Prints shell input lines as they are read.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>set -x</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>set -o xtrace</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Print command traces before executing command.</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The dash is used to activate a shell option and a plus to deactivate it.  Don't let this confuse you!</P
><P
>In the example below, we demonstrate these options on the command line:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>willy:~/scripts&#62;</TT
> <B
CLASS="command"
>set <TT
CLASS="option"
>-v</TT
></B
>

<TT
CLASS="prompt"
>willy:~/scripts&#62;</TT
> <B
CLASS="command"
>ls</B
>
ls 
commented-scripts.sh	script1.sh

<TT
CLASS="prompt"
>willy:~/scripts&#62;</TT
> <B
CLASS="command"
>set <TT
CLASS="option"
>+v</TT
></B
>
set +v

<TT
CLASS="prompt"
>willy:~/scripts&#62;</TT
> <B
CLASS="command"
>ls <TT
CLASS="parameter"
><I
>*</I
></TT
></B
>
commented-scripts.sh    script1.sh

<TT
CLASS="prompt"
>willy:~/scripts&#62;</TT
> <B
CLASS="command"
>set <TT
CLASS="option"
>-f</TT
></B
>

<TT
CLASS="prompt"
>willy:~/scripts&#62;</TT
> <B
CLASS="command"
>ls <TT
CLASS="filename"
>*</TT
></B
>
ls: *: No such file or directory

<TT
CLASS="prompt"
>willy:~/scripts&#62;</TT
> <B
CLASS="command"
>touch <TT
CLASS="filename"
>*</TT
></B
>

<TT
CLASS="prompt"
>willy:~/scripts&#62;</TT
> <B
CLASS="command"
>ls</B
>
*   commented-scripts.sh    script1.sh

<TT
CLASS="prompt"
>willy:~/scripts&#62;</TT
> <B
CLASS="command"
>rm <TT
CLASS="filename"
>*</TT
></B
>

<TT
CLASS="prompt"
>willy:~/scripts&#62;</TT
> <B
CLASS="command"
>ls</B
>
commented-scripts.sh    script1.sh
</PRE
></FONT
></TD
></TR
></TABLE
><P
>Alternatively, these modes can be specified in the script itself, by adding the desired options to the first line shell declaration.  Options can be combined, as is usually the case with UNIX commands:</P
><P
><B
CLASS="command"
>#!/bin/bash <TT
CLASS="option"
>-xv</TT
></B
> </P
><P
>Once you found the buggy part of your script, you can add <B
CLASS="command"
>echo</B
> statements before each command of which you are unsure, so that you will see exactly where and why things don't work.  In the example <TT
CLASS="filename"
>commented-script1.sh</TT
> script, it could be done like this, still assuming that the displaying of users gives us problems:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;echo "debug message: now attempting to start w command"; w
</PRE
></FONT
></TD
></TR
></TABLE
><P
>In more advanced scripts, the <B
CLASS="command"
>echo</B
> can be inserted to display the content of variables at different stages in the script, so that flaws can be detected:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;echo "Variable VARNAME is now set to $VARNAME."
</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="sect_02_05"
></A
>2.4. Summary</H1
><P
>A shell script is a reusable series of commands put in an executable text file.  Any text editor can be used to write scripts.</P
><P
>Scripts start with <EM
>#!</EM
> followed by the path to the shell executing the commands from the script.  Comments are added to a script for your own future reference, and also to make it understandable for other users.  It is better to have too many explanations than not enough.</P
><P
>Debugging a script can be done using shell options.  Shell options can be used for partial debugging or for analyzing the entire script.  Inserting <B
CLASS="command"
>echo</B
> commands at strategic locations is also a common troubleshooting technique.</P
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="sect_02_06"
></A
>2.5. Exercises</H1
><P
>This exercise will help you to create your first script.</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Write a script using your favorite editor.  The script should display the path to your homedirectory and the terminal type that you are using.  Additionally it shows all the services started up in runlevel 3 on your system.  (hint: use <TT
CLASS="varname"
>HOME</TT
>, <TT
CLASS="varname"
>TERM</TT
> and <B
CLASS="command"
>ls <TT
CLASS="filename"
>/etc/rc3.d/S*</TT
></B
>)</P
></LI
><LI
><P
>Add comments in your script.</P
></LI
><LI
><P
>Add information for the users of your script.</P
></LI
><LI
><P
>Change permissions on your script so that you can run it.</P
></LI
><LI
><P
>Run the script in normal mode and in debug mode.  It should run without errors.</P
></LI
><LI
><P
>Make errors in your script: see what happens if you misspell commands, if you leave out the first line or put something unintelligible there, or if you misspell shell variable names or write them in lower case characters after they have been declared in capitals.  Check what the debug comments say about this.</P
></LI
></OL
></DIV
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="chap_03"
></A
>Chapter 3. The Bash environment</H1
><BLOCKQUOTE
CLASS="ABSTRACT"
><DIV
CLASS="abstract"
><A
NAME="AEN1676"
></A
><P
></P
><P
>In this chapter we will discuss the various ways in which the Bash environment can be influenced:</P
><P
><P
></P
><UL
><LI
><P
>Editing shell initialization files</P
></LI
><LI
><P
>Using variables</P
></LI
><LI
><P
>Using different quote styles</P
></LI
><LI
><P
>Perform arithmetic calculations</P
></LI
><LI
><P
>Assigning aliases</P
></LI
><LI
><P
>Using expansion and substitution</P
></LI
></UL
></P
><P
></P
></DIV
></BLOCKQUOTE
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="sect_03_01"
></A
>3.1. Shell initialization files</H1
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="sect_03_01_01"
></A
>3.1.1. System-wide configuration files</H2
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="sect_03_01_01_01"
></A
>3.1.1.1. /etc/profile</H3
><P
>When invoked interactively with the <TT
CLASS="option"
>--login</TT
> option or when invoked as <B
CLASS="command"
>sh</B
>, Bash reads the <TT
CLASS="filename"
>/etc/profile</TT
> instructions.  These usually set the shell variables <TT
CLASS="varname"
>PATH</TT
>, <TT
CLASS="varname"
>USER</TT
>, <TT
CLASS="varname"
>MAIL</TT
>, <TT
CLASS="varname"
>HOSTNAME</TT
> and <TT
CLASS="varname"
>HISTSIZE</TT
>.</P
><P
>On some systems, the <B
CLASS="command"
>umask</B
> value is configured in <TT
CLASS="filename"
>/etc/profile</TT
>; on other systems this file holds pointers to other configuration files such as:</P
><P
></P
><UL
><LI
><P
><TT
CLASS="filename"
>/etc/inputrc</TT
>, the system-wide Readline initialization file where you can configure the command line bell-style.</P
></LI
><LI
><P
>the <TT
CLASS="filename"
>/etc/profile.d</TT
> directory, which contains files configuring system-wide behavior of specific programs.</P
></LI
></UL
><P
>All settings that you want to apply to all your users' environments should be in this file.  It might look like this:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;# /etc/profile

# System wide environment and startup programs, for login setup

PATH=$PATH:/usr/X11R6/bin

# No core files by default
ulimit -S -c 0 &#62; /dev/null 2&#62;&#38;1

USER="`id -un`"
LOGNAME=$USER
MAIL="/var/spool/mail/$USER"

HOSTNAME=`/bin/hostname`
HISTSIZE=1000

# Keyboard, bell, display style: the readline config file:
if [ -z "$INPUTRC" -a ! -f "$HOME/.inputrc" ]; then
    INPUTRC=/etc/inputrc
fi

PS1="\u@\h \W"

export PATH USER LOGNAME MAIL HOSTNAME HISTSIZE INPUTRC PS1

# Source initialization files for specific programs (ls, vim, less, ...)
for i in /etc/profile.d/*.sh ; do
    if [ -r "$i" ]; then
        . $i
    fi
done

# Settings for program initialization
source /etc/java.conf
export NPX_PLUGIN_PATH="$JRE_HOME/plugin/ns4plugin/:/usr/lib/netscape/plugins"

PAGER="/usr/bin/less"

unset i
</PRE
></FONT
></TD
></TR
></TABLE
><P
>This configuration file sets some basic shell environment variables as well as some variables required by users running Java and/or Java applications in their web browser.  See <A
HREF="#sect_03_02"
>Section 3.2</A
>.</P
><P
>See <A
HREF="#chap_07"
>Chapter 7</A
> for more on the conditional <B
CLASS="command"
>if</B
> used in this file; <A
HREF="#chap_09"
>Chapter 9</A
> discusses loops such as the <B
CLASS="command"
>for</B
> construct.</P
><P
>The Bash source contains sample <TT
CLASS="filename"
>profile</TT
> files for general or individual use.  These and the one in the example above need changes in order for them to work in your environment!</P
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="sect_03_01_01_02"
></A
>3.1.1.2. /etc/bashrc</H3
><P
>On systems offering multiple types of shells, it might be better to put Bash-specific configurations in this file, since <TT
CLASS="filename"
>/etc/profile</TT
> is also read by other shells, such as the Bourne shell.  Errors generated by shells that don't understand the Bash syntax are prevented by splitting the configuration files for the different types of shells.  In such cases, the user's <TT
CLASS="filename"
>~/.bashrc</TT
> might point to <TT
CLASS="filename"
>/etc/bashrc</TT
> in order to include it in the shell initialization process upon login.</P
><P
>You might also find that <TT
CLASS="filename"
>/etc/profile</TT
> on your system only holds shell environment and program startup settings, while <TT
CLASS="filename"
>/etc/bashrc</TT
> contains system-wide definitions for shell functions and aliases.  The <TT
CLASS="filename"
>/etc/bashrc</TT
> file might be referred to in <TT
CLASS="filename"
>/etc/profile</TT
> or in individual user shell initialization files.</P
><P
>The source contains sample <TT
CLASS="filename"
>bashrc</TT
> files, or you might find a copy in <TT
CLASS="filename"
>/usr/share/doc/bash-2.05b/startup-files</TT
>.  This is part of the <TT
CLASS="filename"
>bashrc</TT
> that comes with the Bash documentation:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;alias ll='ls -l'
alias dir='ls -ba'
alias c='clear'
alias ls='ls --color'

alias mroe='more'
alias pdw='pwd'
alias sl='ls --color'

pskill()
{
        local pid

        pid=$(ps -ax | grep $1 | grep -v grep | gawk '{ print $1 }')
        echo -n "killing $1 (process $pid)..."
        kill -9 $pid
        echo "slaughtered."
}

</PRE
></FONT
></TD
></TR
></TABLE
><P
>Apart from general aliases, it contains useful aliases which make commands work even if you misspell them.  We will discuss aliases in <A
HREF="#sect_03_05_02"
>Section 3.5.2</A
>.  This file contains a function, <B
CLASS="command"
>pskill</B
>; functions will be studied in detail in <A
HREF="#chap_11"
>Chapter 11</A
>.</P
></DIV
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_03_01_02"
></A
>3.1.2. Individual user configuration files</H2
><DIV
CLASS="note"
><P
></P
><TABLE
CLASS="note"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>I don't have these files?!</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>These files might not be in your home directory by default; create them if needed.</P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="sect_03_01_02_01"
></A
>3.1.2.1. ~/.bash_profile</H3
><P
>This is the preferred configuration file for configuring user environments individually.  In this file, users can add extra configuration options or change default settings:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>franky~&#62;</TT
> <B
CLASS="command"
>cat <TT
CLASS="filename"
>.bash_profile</TT
></B
>
#################################################################
#                                                               #
#   .bash_profile file                                          #
#                                                               #
#   Executed from the bash shell when you log in.               #
#                                                               #
#################################################################

source ~/.bashrc
source ~/.bash_login
case "$OS" in
  IRIX)
    stty sane dec
    stty erase
    ;;
#  SunOS)
#    stty erase
#    ;;
  *)
    stty sane
    ;;
esac
</PRE
></FONT
></TD
></TR
></TABLE
><P
>This user configures the backspace character for login on different operating systems.  Apart from that, the user's <TT
CLASS="filename"
>.bashrc</TT
> and <TT
CLASS="filename"
>.bash_login</TT
> are read.</P
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="sect_03_01_02_02"
></A
>3.1.2.2. ~/.bash_login</H3
><P
>This file contains specific settings that are normally only executed when you log in to the system.  In the example, we use it to configure the <B
CLASS="command"
>umask</B
> value and to show a list of connected users upon login.  This user also gets the calendar for the current month:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;#######################################################################
#                                                                     #
#   Bash_login file                                                   #
#                                                                     #
#   commands to perform from the bash shell at login time             #
#   (sourced from .bash_profile)                                      #
#                                                                     #
#######################################################################
#   file protection
umask 002       # all to me, read to group and others
#   miscellaneous
w
cal `date +"%m"` `date +"%Y"`
</PRE
></FONT
></TD
></TR
></TABLE
><P
>In the absence of <TT
CLASS="filename"
>~/.bash_profile</TT
>, this file will be read.</P
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="sect_03_01_02_03"
></A
>3.1.2.3. ~/.profile</H3
><P
>In the absence of <TT
CLASS="filename"
>~/.bash_profile</TT
> and <TT
CLASS="filename"
>~/.bash_login</TT
>, <TT
CLASS="filename"
>~/.profile</TT
> is read.  It can hold the same configurations, which are then also accessible by other shells.  Mind that other shells might not understand the Bash syntax.</P
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="sect_03_01_02_04"
></A
>3.1.2.4. ~/.bashrc</H3
><P
>Today, it is more common to use a non-login shell, for instance when logged in graphically using X terminal windows.  Upon opening such a window, the user does not have to provide a user name or password; no authentication is done.  Bash searches for <TT
CLASS="filename"
>~/.bashrc</TT
> when this happens, so it is referred to in the files read upon login as well, which means you don't have to enter the same settings in multiple files.</P
><P
>In this user's <TT
CLASS="filename"
>.bashrc</TT
> a couple of aliases are defined and variables for specific programs are set after the system-wide <TT
CLASS="filename"
>/etc/bashrc</TT
> is read:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>franky ~&#62;</TT
> <B
CLASS="command"
>cat <TT
CLASS="filename"
>.bashrc</TT
></B
>
# /home/franky/.bashrc

# Source global definitions
if [ -f /etc/bashrc ]; then
       . /etc/bashrc

fi

# shell options

set -o noclobber

# my shell variables

export PS1="\[\033[1;44m\]\u \w\[\033[0m\] "
export PATH="$PATH:~/bin:~/scripts"

# my aliases

alias cdrecord='cdrecord -dev 0,0,0 -speed=8'
alias ss='ssh octarine'
alias ll='ls -la'

# mozilla fix

MOZILLA_FIVE_HOME=/usr/lib/mozilla
LD_LIBRARY_PATH=/usr/lib/mozilla:/usr/lib/mozilla/plugins
MOZ_DIST_BIN=/usr/lib/mozilla
MOZ_PROGRAM=/usr/lib/mozilla/mozilla-bin
export MOZILLA_FIVE_HOME LD_LIBRARY_PATH MOZ_DIST_BIN MOZ_PROGRAM

# font fix
alias xt='xterm -bg black -fg white &#38;'

# BitchX settings
export IRCNAME="frnk"

# THE END
<TT
CLASS="prompt"
>franky ~&#62;</TT
>
</PRE
></FONT
></TD
></TR
></TABLE
><P
>More examples can be found in the Bash package.  Remember that sample files might need changes in order to work in your environment.</P
><P
>Aliases are discussed in <A
HREF="#sect_03_05"
>Section 3.5</A
>.</P
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="sect_03_01_02_05"
></A
>3.1.2.5. ~/.bash_logout</H3
><P
>This file contains specific instructions for the logout procedure.  In the example, the terminal window is cleared upon logout.  This is useful for remote connections, which will leave a clean window after closing them.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>franky ~&#62;</TT
> <B
CLASS="command"
>cat <TT
CLASS="filename"
>.bash_logout</TT
></B
>
#######################################################################
#                                                                     #
#   Bash_logout file                                                  #
#                                                                     #
#   commands to perform from the bash shell at logout time            #
#                                                                     #
#######################################################################
clear
<TT
CLASS="prompt"
>franky ~&#62;</TT
>
</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_03_01_03"
></A
>3.1.3. Changing shell configuration files</H2
><P
>When making changes to any of the above files, users have to either reconnect to the system or <B
CLASS="command"
>source</B
> the altered file for the changes to take effect.  By interpreting the script this way, changes are applied to the current shell session:</P
><DIV
CLASS="figure"
><A
NAME="AEN1878"
></A
><P
><B
>Figure 3-1. Different prompts for different users</B
></P
><DIV
CLASS="mediaobject"
><P
><IMG
SRC="images/prompt.png"></P
></DIV
></DIV
><P
>Most shell scripts execute in a private environment: variables are not inherited by child processes unless they are exported by the parent shell.  Sourcing a file containing shell commands is a way of applying changes to your own environment and setting variables in the current shell.</P
><P
>This example also demonstrates the use of different prompt settings by different users.  In this case, red means danger.  When you have a green prompt, don't worry too much.</P
><P
>Note that <B
CLASS="command"
>source <TT
CLASS="filename"
>resourcefile</TT
></B
> is the same as <B
CLASS="command"
>. <TT
CLASS="filename"
>resourcefile</TT
></B
>.</P
><P
>Should you get lost in all these configuration files, and find yourself confronted with settings of which the origin is not clear, use <B
CLASS="command"
>echo</B
> statements, just like for debugging scripts; see <A
HREF="#sect_02_03_02"
>Section 2.3.2</A
>.  You might add lines like this:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;echo "Now executing .bash_profile.."
</PRE
></FONT
></TD
></TR
></TABLE
><P
>or like this:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;echo "Now setting PS1 in .bashrc:"
export PS1="[some value]"
echo "PS1 is now set to $PS1"
</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="sect_03_02"
></A
>3.2. Variables</H1
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="sect_03_02_01"
></A
>3.2.1. Types of variables</H2
><P
>As seen in the examples above, shell variables are in uppercase
characters by convention.  Bash keeps a list of two types of variables:</P
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="sect_03_02_01_01"
></A
>3.2.1.1. Global variables</H3
><P
>Global variables or environment variables are available in all shells.  The <B
CLASS="command"
>env</B
> or <B
CLASS="command"
>printenv</B
> commands can be used to display environment variables.  These programs come with the <EM
>sh-utils</EM
> package.</P
><P
>Below is a typical output:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>franky ~&#62;</TT
> <B
CLASS="command"
>printenv</B
>
CC=gcc
CDPATH=.:~:/usr/local:/usr:/
CFLAGS=-O2 -fomit-frame-pointer
COLORTERM=gnome-terminal
CXXFLAGS=-O2 -fomit-frame-pointer
DISPLAY=:0
DOMAIN=hq.garrels.be
e=
TOR=vi
FCEDIT=vi
FIGNORE=.o:~
G_BROKEN_FILENAMES=1
GDK_USE_XFT=1
GDMSESSION=Default
GNOME_DESKTOP_SESSION_ID=Default
GTK_RC_FILES=/etc/gtk/gtkrc:/nethome/franky/.gtkrc-1.2-gnome2
GWMCOLOR=darkgreen
GWMTERM=xterm
HISTFILESIZE=5000
history_control=ignoredups
HISTSIZE=2000
HOME=/nethome/franky
HOSTNAME=octarine.hq.garrels.be
INPUTRC=/etc/inputrc
IRCNAME=franky
JAVA_HOME=/usr/java/j2sdk1.4.0
LANG=en_US
LDFLAGS=-s
LD_LIBRARY_PATH=/usr/lib/mozilla:/usr/lib/mozilla/plugins
LESSCHARSET=latin1
LESS=-edfMQ
LESSOPEN=|/usr/bin/lesspipe.sh %s
LEX=flex
LOCAL_MACHINE=octarine
LOGNAME=franky
LS_COLORS=no=00:fi=00:di=01;34:ln=01;36:pi=40;33:so=01;35:bd=40;33;01:cd=40;33;01:or=01;05;37;41:mi=01;05;37;41:ex=01;32:*.cmd=01;32:*.exe=01;32:*.com=01;32:*.btm=01;32:*.bat=01;32:*.sh=01;32:*.csh=01;32:*.tar=01;31:*.tgz=01;31:*.arj=01;31:*.taz=01;31:*.lzh=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.gz=01;31:*.bz2=01;31:*.bz=01;31:*.tz=01;31:*.rpm=01;31:*.cpio=01;31:*.jpg=01;35:*.gif=01;35:*.bmp=01;35:*.xbm=01;35:*.xpm=01;35:*.png=01;35:*.tif=01;35:
MACHINES=octarine
MAILCHECK=60
MAIL=/var/mail/franky
MANPATH=/usr/man:/usr/share/man/:/usr/local/man:/usr/X11R6/man
MEAN_MACHINES=octarine
MOZ_DIST_BIN=/usr/lib/mozilla
MOZILLA_FIVE_HOME=/usr/lib/mozilla
MOZ_PROGRAM=/usr/lib/mozilla/mozilla-bin
MTOOLS_FAT_COMPATIBILITY=1
MYMALLOC=0
NNTPPORT=119
NNTPSERVER=news
NPX_PLUGIN_PATH=/plugin/ns4plugin/:/usr/lib/netscape/plugins
OLDPWD=/nethome/franky
OS=Linux
PAGER=less
PATH=/nethome/franky/bin.Linux:/nethome/franky/bin:/usr/local/bin:/usr/local/sbin:/usr/X11R6/bin:/usr/bin:/usr/sbin:/bin:/sbin:.
PS1=\[\033[1;44m\]franky is in \w\[\033[0m\]
PS2=More input&#62;
PWD=/nethome/franky
SESSION_MANAGER=local/octarine.hq.garrels.be:/tmp/.ICE-unix/22106
SHELL=/bin/bash
SHELL_LOGIN=--login
SHLVL=2
SSH_AGENT_PID=22161
SSH_ASKPASS=/usr/libexec/openssh/gnome-ssh-askpass
SSH_AUTH_SOCK=/tmp/ssh-XXmhQ4fC/agent.22106
START_WM=twm
TERM=xterm
TYPE=type
USERNAME=franky
USER=franky
_=/usr/bin/printenv
VISUAL=vi
WINDOWID=20971661
XAPPLRESDIR=/nethome/franky/app-defaults
XAUTHORITY=/nethome/franky/.Xauthority
XENVIRONMENT=/nethome/franky/.Xdefaults
XFILESEARCHPATH=/usr/X11R6/lib/X11/%L/%T/%N%C%S:/usr/X11R6/lib/X11/%l/%T/%N%C%S:/usr/X11R6/lib/X11/%T/%N%C%S:/usr/X11R6/lib/X11/%L/%T/%N%S:/usr/X11R6/lib/X11/%l/%T/%N%S:/usr/X11R6/lib/X11/%T/%N%S
XKEYSYMDB=/usr/X11R6/lib/X11/XKeysymDB
XMODIFIERS=@im=none
XTERMID=
XWINHOME=/usr/X11R6
X=X11R6
YACC=bison -y
</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="sect_03_02_01_02"
></A
>3.2.1.2. Local variables</H3
><P
>Local variables are only available in the current shell.  Using the <B
CLASS="command"
>set</B
> built-in command without any options will display a list of all variables (including environment variables) and functions.  The output will be sorted according to the current locale and displayed in a reusable format.</P
><P
>Below is a diff file made by comparing <B
CLASS="command"
>printenv</B
> and <B
CLASS="command"
>set</B
> output, after leaving out the functions which are also displayed by the <B
CLASS="command"
>set</B
> command:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>franky ~&#62;</TT
> <B
CLASS="command"
>diff <TT
CLASS="filename"
>set.sorted</TT
> <TT
CLASS="filename"
>printenv.sorted</TT
></B
> | <B
CLASS="command"
>grep <TT
CLASS="parameter"
><I
>"&#60;"</I
></TT
></B
> | <B
CLASS="command"
>awk <TT
CLASS="parameter"
><I
>'{ print $2 }'</I
></TT
></B
>
BASE=/nethome/franky/.Shell/hq.garrels.be/octarine.aliases
BASH=/bin/bash
BASH_VERSINFO=([0]="2"
BASH_VERSION='2.05b.0(1)-release'
COLUMNS=80
DIRSTACK=()
DO_FORTUNE=
EUID=504
GROUPS=()
HERE=/home/franky
HISTFILE=/nethome/franky/.bash_history
HOSTTYPE=i686
IFS=$'
LINES=24
MACHTYPE=i686-pc-linux-gnu
OPTERR=1
OPTIND=1
OSTYPE=linux-gnu
PIPESTATUS=([0]="0")
PPID=10099
PS4='+
PWD_REAL='pwd
SHELLOPTS=braceexpand:emacs:hashall:histexpand:history:interactive-comments:monitor
THERE=/home/franky
UID=504
</PRE
></FONT
></TD
></TR
></TABLE
><DIV
CLASS="note"
><P
></P
><TABLE
CLASS="note"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>Awk</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>the GNU Awk programming language is explained in <A
HREF="#chap_06"
>Chapter 6</A
>.</P
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="sect_03_02_01_03"
></A
>3.2.1.3. Variables by content</H3
><P
>Apart from dividing variables in local and global variables, we can also divide them in categories according to the sort of content the variable contains.  In this respect, variables come in 4 types:</P
><P
></P
><UL
><LI
><P
>String variables</P
></LI
><LI
><P
>Integer variables</P
></LI
><LI
><P
>Constant variables</P
></LI
><LI
><P
>Array variables</P
></LI
></UL
><P
>We'll discuss these types in <A
HREF="#chap_10"
>Chapter 10</A
>.  For now, we will work with integer and string values for our variables.</P
></DIV
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_03_02_02"
></A
>3.2.2. Creating variables</H2
><P
>Variables are case sensitive and capitalized by default.  Giving local variables a lowercase name is a convention which is sometimes applied.  However, you are free to use the names you want or to mix cases.  Variables can also contain digits, but a name starting with a digit is not allowed:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>prompt&#62;</TT
> <B
CLASS="command"
>export <TT
CLASS="varname"
>1number</TT
>=<TT
CLASS="parameter"
><I
>1</I
></TT
></B
>
bash: export: `1number=1': not a valid identifier
</PRE
></FONT
></TD
></TR
></TABLE
><P
>To set a variable in the shell, use</P
><P
><B
CLASS="command"
><TT
CLASS="varname"
>VARNAME</TT
>="value"</B
> </P
><P
>Putting spaces around the equal sign will cause errors.  It is a good habit to quote content strings when assigning values to variables: this will reduce the chance that you make errors.</P
><P
>Some examples using upper and lower cases, numbers and spaces:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>franky ~&#62;</TT
> <B
CLASS="command"
><TT
CLASS="varname"
>MYVAR1</TT
>=<TT
CLASS="parameter"
><I
>"2"</I
></TT
></B
>

<TT
CLASS="prompt"
>franky ~&#62;</TT
> <B
CLASS="command"
>echo <TT
CLASS="varname"
>$MYVAR1</TT
></B
>
2

<TT
CLASS="prompt"
>franky ~&#62;</TT
> <B
CLASS="command"
><TT
CLASS="varname"
>first_name</TT
>=<TT
CLASS="parameter"
><I
>"Franky"</I
></TT
></B
>

<TT
CLASS="prompt"
>franky ~&#62;</TT
> <B
CLASS="command"
>echo <TT
CLASS="varname"
>$first_name</TT
></B
>
Franky

<TT
CLASS="prompt"
>franky ~&#62;</TT
> <B
CLASS="command"
><TT
CLASS="varname"
>full_name</TT
>=<TT
CLASS="parameter"
><I
>"Franky M. Singh"</I
></TT
></B
>

<TT
CLASS="prompt"
>franky ~&#62;</TT
> <B
CLASS="command"
>echo <TT
CLASS="varname"
>$full_name</TT
></B
>
Franky M. Singh

<TT
CLASS="prompt"
>franky ~&#62;</TT
> <B
CLASS="command"
><TT
CLASS="varname"
>MYVAR-2</TT
>=<TT
CLASS="parameter"
><I
>"2"</I
></TT
></B
>
bash: MYVAR-2=2: command not found

<TT
CLASS="prompt"
>franky ~&#62;</TT
> <B
CLASS="command"
><TT
CLASS="varname"
>MYVAR1</TT
> =<TT
CLASS="parameter"
><I
>"2"</I
></TT
></B
>
bash: MYVAR1: command not found

<TT
CLASS="prompt"
>franky ~&#62;</TT
> <B
CLASS="command"
><TT
CLASS="varname"
>MYVAR1</TT
>= <TT
CLASS="parameter"
><I
>"2"</I
></TT
></B
>
bash: 2: command not found

<TT
CLASS="prompt"
>franky ~&#62;</TT
> <B
CLASS="command"
>unset <TT
CLASS="varname"
>MYVAR1</TT
> <TT
CLASS="varname"
>first_name</TT
> <TT
CLASS="varname"
>full_name</TT
></B
>

<TT
CLASS="prompt"
>franky ~&#62;</TT
> <B
CLASS="command"
>echo <TT
CLASS="varname"
>$MYVAR1</TT
> <TT
CLASS="varname"
>$first_name</TT
> <TT
CLASS="varname"
>$full_name</TT
></B
>
&#60;--no output--&#62;

<TT
CLASS="prompt"
>franky ~&#62;</TT
>
</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_03_02_03"
></A
>3.2.3. Exporting variables</H2
><P
>A variable created like the ones in the example above is only available to the current shell.  It is a local variable: child processes of the current shell will not be aware of this variable.  In order to pass variables to a subshell, we need to <EM
>export</EM
> them using the <B
CLASS="command"
>export</B
> built-in command.  Variables that are exported are referred to as environment variables.  Setting and exporting is usually done in one step:</P
><P
><B
CLASS="command"
>export <TT
CLASS="varname"
>VARNAME</TT
>="<TT
CLASS="parameter"
><I
>value</I
></TT
>"</B
> </P
><P
>A subshell can change variables it inherited from the parent, but the changes made by the child don't affect the parent.  This is demonstrated in the example:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>franky ~&#62;</TT
> <B
CLASS="command"
><TT
CLASS="varname"
>full_name</TT
>=<TT
CLASS="parameter"
><I
>"Franky M. Singh"</I
></TT
></B
>

<TT
CLASS="prompt"
>franky ~&#62;</TT
> <B
CLASS="command"
>bash</B
>

<TT
CLASS="prompt"
>franky ~&#62;</TT
> <B
CLASS="command"
>echo <TT
CLASS="varname"
>$full_name</TT
></B
>


<TT
CLASS="prompt"
>franky ~&#62;</TT
> <B
CLASS="command"
>exit</B
>

<TT
CLASS="prompt"
>franky ~&#62;</TT
> <B
CLASS="command"
>export <TT
CLASS="varname"
>full_name</TT
></B
>

<TT
CLASS="prompt"
>franky ~&#62;</TT
> <B
CLASS="command"
>bash</B
>

<TT
CLASS="prompt"
>franky ~&#62;</TT
> <B
CLASS="command"
>echo <TT
CLASS="varname"
>$full_name</TT
></B
>
Franky M. Singh

<TT
CLASS="prompt"
>franky ~&#62;</TT
> <B
CLASS="command"
>export <TT
CLASS="varname"
>full_name</TT
>=<TT
CLASS="parameter"
><I
>"Charles the Great"</I
></TT
></B
>

<TT
CLASS="prompt"
>franky ~&#62;</TT
> <B
CLASS="command"
>echo <TT
CLASS="varname"
>$full_name</TT
></B
>
Charles the Great

<TT
CLASS="prompt"
>franky ~&#62;</TT
> <B
CLASS="command"
>exit</B
>

<TT
CLASS="prompt"
>franky ~&#62;</TT
> <B
CLASS="command"
>echo <TT
CLASS="varname"
>$full_name</TT
></B
>
Franky M. Singh

<TT
CLASS="prompt"
>franky ~&#62;</TT
>
</PRE
></FONT
></TD
></TR
></TABLE
><P
>When first trying to read the value of <TT
CLASS="varname"
>full_name</TT
> in a subshell, it is not there (<B
CLASS="command"
>echo</B
> shows a null string).  The subshell quits, and <TT
CLASS="varname"
>full_name</TT
> is exported in the parent - a variable can be exported after it has been assigned a value.  Then a new subshell is started, in which the variable exported from the parent is visible.  The variable is changed to hold another name, but the value for this variable in the parent stays the same.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_03_02_04"
></A
>3.2.4. Reserved variables</H2
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="sect_03_02_04_01"
></A
>3.2.4.1. Bourne shell reserved variables</H3
><P
>Bash uses certain shell variables in the same way as the Bourne shell.  In some cases, Bash assigns a default value to the variable.  The table below gives an overview of these plain shell variables:</P
><DIV
CLASS="table"
><A
NAME="table_03_01"
></A
><P
><B
>Table 3-1. Reserved Bourne shell variables</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
>Variable name</TH
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
>Definition</TH
></TR
></THEAD
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>CDPATH</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>A colon-separated list of directories used as a search path for the <B
CLASS="command"
>cd</B
> built-in command.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>HOME</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>The current user's home directory; the default for the <B
CLASS="command"
>cd</B
> built-in.  The value of this variable is also used by tilde expansion.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>IFS</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>A list of characters that separate fields; used when the shell splits words as part of expansion.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>MAIL</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>If this parameter is set to a file name and the <TT
CLASS="varname"
>MAILPATH</TT
> variable is not set, Bash informs the user of the arrival of mail in the specified file.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>MAILPATH</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>A colon-separated list of file names which the shell periodically checks for new mail.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>OPTARG</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>The value of the last option argument processed by the <B
CLASS="command"
>getopts</B
> built-in.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>OPTIND</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>The index of the last option argument processed by the <B
CLASS="command"
>getopts</B
> built-in.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>PATH</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>A colon-separated list of directories in which the shell looks for commands.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>PS1</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>The primary prompt string.  The default value is <SPAN
CLASS="QUOTE"
>"'\s-\v\$ '"</SPAN
>.  </TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>PS2</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>The secondary prompt string.  The default value is <SPAN
CLASS="QUOTE"
>"'&#62; '"</SPAN
>.</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="sect_03_02_04_02"
></A
>3.2.4.2. Bash reserved variables</H3
><P
>These variables are set or used by Bash, but other shells do not normally treat them specially.</P
><DIV
CLASS="table"
><A
NAME="table_03_02"
></A
><P
><B
>Table 3-2. Reserved Bash variables</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
>Variable name</TH
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
>Definition</TH
></TR
></THEAD
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>auto_resume</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>This variable controls how the shell interacts with the user and job control.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>BASH</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>The full pathname used to execute the current instance of Bash.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>BASH_ENV</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>If this variable is set when Bash is invoked to execute a shell script, its value is expanded and used as the name of a startup file to read before executing the script.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>BASH_VERSION</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>The version number of the current instance of Bash.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>BASH_VERSINFO</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>A read-only array variable whose members hold version information for this instance of Bash.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>COLUMNS</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Used by the <B
CLASS="command"
>select</B
> built-in to determine the terminal width when printing selection lists.  Automatically set upon receipt of a <EM
>SIGWINCH</EM
> signal.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>COMP_CWORD</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>An index into <TT
CLASS="varname"
>${COMP_WORDS}</TT
> of the word containing the current cursor position.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>COMP_LINE</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>The current command line.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>COMP_POINT</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>The index of the current cursor position relative to the beginning of the current command.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>COMP_WORDS</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>An array variable consisting of the individual words in the current command line.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>COMPREPLY</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>An array variable from which Bash reads the possible completions generated by a shell function invoked by the programmable completion facility.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>DIRSTACK</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>An array variable containing the current contents of the directory stack.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>EUID</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>The numeric effective user ID of the current user.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>FCEDIT</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>The editor used as a default by the <TT
CLASS="option"
>-e</TT
> option to the <B
CLASS="command"
>fc</B
> built-in command.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>FIGNORE</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>A colon-separated list of suffixes to ignore when performing file name completion.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>FUNCNAME</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>The name of any currently-executing shell function.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>GLOBIGNORE</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>A colon-separated list of patterns defining the set of file names to be ignored by file name expansion.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>GROUPS</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>An array variable containing the list of groups of which the current user is a member.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>histchars</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Up to three characters which control history expansion, quick substitution, and <EM
>tokenization</EM
>.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>HISTCMD</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>The history number, or index in the history list, of the current command.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>HISTCONTROL</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Defines whether a command is added to the history file.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>HISTFILE</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>The name of the file to which the command history is saved.  The default value is <TT
CLASS="filename"
>~/.bash_history</TT
>.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>HISTFILESIZE</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>The maximum number of lines contained in the history file, defaults to 500.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>HISTIGNORE</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>A colon-separated list of patterns used to decide which command lines should be saved in the history list.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>HISTSIZE</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>The maximum number of commands to remember on the history list, default is 500.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>HOSTFILE</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Contains the name of a file in the same format as <TT
CLASS="filename"
>/etc/hosts</TT
> that should be read when the shell needs to complete a hostname.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>HOSTNAME</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>The name of the current host.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>HOSTTYPE</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>A string describing the machine Bash is running on.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>IGNOREEOF</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Controls the action of the shell on receipt of an <EM
>EOF</EM
> character as the sole input.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>INPUTRC</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>The name of the Readline initialization file, overriding the default <TT
CLASS="filename"
>/etc/inputrc</TT
>.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>LANG</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Used to determine the locale category for any category not specifically selected with a variable starting with <TT
CLASS="varname"
>LC_</TT
>.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>LC_ALL</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>This variable overrides the value of <TT
CLASS="varname"
>LANG</TT
> and any other <TT
CLASS="varname"
>LC_</TT
> variable specifying a locale category.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>LC_COLLATE</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>This variable determines the collation order used when sorting the results of file name expansion, and determines the behavior of range expressions, equivalence classes, and collating sequences within file name expansion and pattern matching.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>LC_CTYPE</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>This variable determines the interpretation of characters and the behavior of character classes within file name expansion and pattern matching.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>LC_MESSAGES</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>This variable determines the locale used to translate double-quoted strings preceded by a <SPAN
CLASS="QUOTE"
>"$"</SPAN
> sign.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>LC_NUMERIC</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>This variable determines the locale category used for number formatting.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>LINENO</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>The line number in the script or shell function currently executing.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>LINES</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Used by the <B
CLASS="command"
>select</B
> built-in to determine the column length for printing selection lists.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>MACHTYPE</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>A string that fully describes the system type on which Bash is executing, in the standard GNU CPU-COMPANY-SYSTEM format.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>MAILCHECK</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>How often (in seconds) that the shell should check for mail in the files specified in the <TT
CLASS="varname"
>MAILPATH</TT
> or <TT
CLASS="varname"
>MAIL</TT
> variables.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>OLDPWD</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>The previous working directory as set by the <B
CLASS="command"
>cd</B
> built-in.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>OPTERR</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>If set to the value 1, Bash displays error messages generated by the <B
CLASS="command"
>getopts</B
> built-in.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>OSTYPE</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>A string describing the operating system Bash is running on.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>PIPESTATUS</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>An array variable containing a list of exit status values from the processes in the most recently executed foreground pipeline (which may contain only a single command).</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>POSIXLY_CORRECT</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>If this variable is in the environment when <B
CLASS="command"
>bash</B
> starts, the shell enters POSIX mode.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>PPID</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>The process ID of the shell's parent process.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>PROMPT_COMMAND</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>If set, the value is interpreted as a command to execute before the printing of each primary prompt (<TT
CLASS="varname"
>PS1</TT
>).</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>PS3</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>The value of this variable is used as the prompt for the <B
CLASS="command"
>select</B
> command.  Defaults to <SPAN
CLASS="QUOTE"
>"'#? '"</SPAN
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>PS4</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>The value is the prompt printed before the command line is echoed when the <TT
CLASS="option"
>-x</TT
> option is set; defaults to <SPAN
CLASS="QUOTE"
>"'+ '"</SPAN
>.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>PWD</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>The current working directory as set by the <B
CLASS="command"
>cd</B
> built-in command.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>RANDOM</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Each time this parameter is referenced, a random integer between 0 and 32767 is generated.  Assigning a value to this variable seeds the random number generator.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>REPLY</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>The default variable for the <B
CLASS="command"
>read</B
> built-in.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>SECONDS</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>This variable expands to the number of seconds since the shell was started.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>SHELLOPTS</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>A colon-separated list of enabled shell options.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>SHLVL</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Incremented by one each time a new instance of Bash is started.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>TIMEFORMAT</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>The value of this parameter is used as a format string specifying
     how the timing information for pipelines prefixed with the <B
CLASS="command"
>time</B
> reserved word should be displayed.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>TMOUT</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>If set to a value greater than zero, <TT
CLASS="varname"
>TMOUT</TT
> is treated as the default timeout for the <B
CLASS="command"
>read</B
> built-in.  In an interative shell, the value is interpreted as the number of seconds to wait for input after issuing the primary prompt when the shell is interactive.  Bash terminates after that number of seconds if input does not arrive.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>UID</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>The numeric, real user ID of the current user.</TD
></TR
></TBODY
></TABLE
></DIV
><P
>Check the Bash man, info or doc pages for extended information.  Some variables are read-only, some are set automatically and some lose their meaning when set to a different value than the default.</P
></DIV
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_03_02_05"
></A
>3.2.5. Special parameters</H2
><P
>The shell treats several parameters specially.  These parameters may only be referenced; assignment to them is not allowed.</P
><DIV
CLASS="table"
><A
NAME="table_03_03"
></A
><P
><B
>Table 3-3. Special bash variables</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
>Character</TH
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
>Definition</TH
></TR
></THEAD
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><TT
CLASS="varname"
>$*</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Expands to the positional parameters, starting from one.  When the expansion occurs within double quotes, it expands to a single word with the value of each parameter separated by the first character of the <TT
CLASS="varname"
>IFS</TT
> special variable.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><TT
CLASS="varname"
>$@</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Expands to the positional parameters, starting from one.  When the expansion occurs within double quotes, each parameter expands to a separate word.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><TT
CLASS="varname"
>$#</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Expands to the number of positional parameters in decimal.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><TT
CLASS="varname"
>$?</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Expands to the exit status of the most recently executed foreground pipeline.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><TT
CLASS="varname"
>$-</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>A hyphen expands to the current option flags as specified upon invocation, by the <B
CLASS="command"
>set</B
> built-in command, or those set by the shell itself (such as the <TT
CLASS="option"
>-i</TT
>).</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><TT
CLASS="varname"
>$$</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Expands to the process ID of the shell.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><TT
CLASS="varname"
>$!</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Expands to the process ID of the most recently executed background (asynchronous) command.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><TT
CLASS="varname"
>$0</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Expands to the name of the shell or shell script.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><TT
CLASS="varname"
>$_</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>The underscore variable is set at shell startup and contains the absolute file name of the shell or script being executed as passed in the argument list.  Subsequently, it expands to the last argument to the previous command, after expansion.  It is also set to the full pathname of each command executed and placed in the environment exported to that command.  When checking mail, this parameter holds the name of the mail file.
</TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="note"
><P
></P
><TABLE
CLASS="note"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>$* vs. $@</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The implementation of <SPAN
CLASS="QUOTE"
>"$*"</SPAN
> has always been a problem and realistically should have been replaced with the behavior of <SPAN
CLASS="QUOTE"
>"$@"</SPAN
>.  In almost every case where coders use <SPAN
CLASS="QUOTE"
>"$*"</SPAN
>, they mean <SPAN
CLASS="QUOTE"
>"$@"</SPAN
>.  <SPAN
CLASS="QUOTE"
>"$*"</SPAN
> Can cause bugs and even security holes in your software.</P
></TD
></TR
></TABLE
></DIV
><P
>The positional parameters are the words following the name of a shell script.  They are put into the variables <TT
CLASS="varname"
>$1</TT
>, <TT
CLASS="varname"
>$2</TT
>, <TT
CLASS="varname"
>$3</TT
> and so on.  As long as needed, variables are added to an internal array.  <TT
CLASS="varname"
>$#</TT
> holds the total number of parameters, as is demonstrated with this simple script:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;#!/bin/bash

# positional.sh
# This script reads 3 positional parameters and prints them out.

POSPAR1="$1"
POSPAR2="$2"
POSPAR3="$3"

echo "$1 is the first positional parameter, \$1."
echo "$2 is the second positional parameter, \$2."
echo "$3 is the third positional parameter, \$3."
echo
echo "The total number of positional parameters is $#."
</PRE
></FONT
></TD
></TR
></TABLE
><P
>Upon execution one could give any numbers of arguments:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>franky ~&#62;</TT
> <B
CLASS="command"
>positional.sh <TT
CLASS="parameter"
><I
>one two three four five</I
></TT
></B
>
one is the first positional parameter, $1.
two is the second positional parameter, $2.
three is the third positional parameter, $3.

The total number of positional parameters is 5.

<TT
CLASS="prompt"
>franky ~&#62;</TT
> <B
CLASS="command"
>positional.sh <TT
CLASS="parameter"
><I
>one two</I
></TT
></B
>
one is the first positional parameter, $1.
two is the second positional parameter, $2.
 is the third positional parameter, $3.

The total number of positional parameters is 2.
</PRE
></FONT
></TD
></TR
></TABLE
><P
>More on evaluating these parameters is in <A
HREF="#chap_07"
>Chapter 7</A
> and <A
HREF="#sect_09_07"
>Section 9.7</A
>.</P
><P
>Some examples on the other special parameters:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>franky ~&#62;</TT
> <B
CLASS="command"
>grep <TT
CLASS="parameter"
><I
>dictionary</I
></TT
> <TT
CLASS="filename"
>/usr/share/dict/words</TT
></B
>
dictionary

<TT
CLASS="prompt"
>franky ~&#62;</TT
> <B
CLASS="command"
>echo <TT
CLASS="varname"
>$_</TT
></B
>
/usr/share/dict/words

<TT
CLASS="prompt"
>franky ~&#62;</TT
> <B
CLASS="command"
>echo <TT
CLASS="varname"
>$$</TT
></B
>
10662

<TT
CLASS="prompt"
>franky ~&#62;</TT
> <B
CLASS="command"
>mozilla &#38;</B
>
[1] 11064

<TT
CLASS="prompt"
>franky ~&#62;</TT
> <B
CLASS="command"
>echo <TT
CLASS="varname"
>$!</TT
></B
>
11064

<TT
CLASS="prompt"
>franky ~&#62;</TT
> <B
CLASS="command"
>echo <TT
CLASS="varname"
>$0</TT
></B
>
bash

<TT
CLASS="prompt"
>franky ~&#62;</TT
> <B
CLASS="command"
>echo <TT
CLASS="varname"
>$?</TT
></B
>
0

<TT
CLASS="prompt"
>franky ~&#62;</TT
> <B
CLASS="command"
>ls <TT
CLASS="filename"
>doesnotexist</TT
></B
>
ls: doesnotexist: No such file or directory

<TT
CLASS="prompt"
>franky ~&#62;</TT
> <B
CLASS="command"
>echo <TT
CLASS="varname"
>$?</TT
></B
>
1

<TT
CLASS="prompt"
>franky ~&#62;</TT
>
</PRE
></FONT
></TD
></TR
></TABLE
><P
>User <EM
>franky</EM
> starts entering the <B
CLASS="command"
>grep</B
> command, which results in the assignment of the <TT
CLASS="varname"
>_</TT
> variable.  The process ID of his shell is 10662.  After putting a job in the background, the <TT
CLASS="varname"
>!</TT
> holds the process ID of the backgrounded job.  The shell running is <B
CLASS="command"
>bash</B
>.  When a mistake is made, <TT
CLASS="varname"
>?</TT
> holds an exit code different from 0 (zero).</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_03_02_06"
></A
>3.2.6. Script recycling with variables</H2
><P
>Apart from making the script more readable, variables will also enable you to faster apply a script in another environment or for another purpose.  Consider the following example, a very simple script that makes a backup of <EM
>franky</EM
>'s home directory to a remote server:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;#!/bin/bash

# This script makes a backup of my home directory.

cd /home

# This creates the archive
tar cf /var/tmp/home_franky.tar franky &#62; /dev/null 2&#62;&#38;1

# First remove the old bzip2 file.  Redirect errors because this generates some if the archive
# does not exist.  Then create a new compressed file.
rm /var/tmp/home_franky.tar.bz2 2&#62; /dev/null
bzip2 /var/tmp/home_franky.tar

# Copy the file to another host - we have ssh keys for making this work without intervention.
scp /var/tmp/home_franky.tar.bz2 bordeaux:/opt/backup/franky &#62; /dev/null 2&#62;&#38;1

# Create a timestamp in a logfile.
date &#62;&#62; /home/franky/log/home_backup.log
echo backup succeeded &#62;&#62; /home/franky/log/home_backup.log
</PRE
></FONT
></TD
></TR
></TABLE
><P
>First of all, you are more likely to make errors if you name files and directories manually each time you need them.  Secondly, suppose <EM
>franky</EM
> wants to give this script to <EM
>carol</EM
>, then carol will have to do quite some editing before she can use the script to back up her home directory.  The same is true if <EM
>franky</EM
> wants to use this script for backing up other directories.  For easy recycling, make all files, directories, usernames, servernames etcetera variable.  Thus, you only need to edit a value once, without having to go through the entire script to check where a parameter occurs.  This is an example:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;#!/bin/bash
                                                                                                 
# This script makes a backup of my home directory.

# Change the values of the variables to make the script work for you:
BACKUPDIR=/home
BACKUPFILES=franky
TARFILE=/var/tmp/home_franky.tar
BZIPFILE=/var/tmp/home_franky.tar.bz2
SERVER=bordeaux
REMOTEDIR=/opt/backup/franky
LOGFILE=/home/franky/log/home_backup.log

cd $BACKUPDIR

# This creates the archive
tar cf $TARFILE $BACKUPFILES &#62; /dev/null 2&#62;&#38;1
                                                                                                 
# First remove the old bzip2 file.  Redirect errors because this generates some if the archive 
# does not exist.  Then create a new compressed file.
rm $BZIPFILE 2&#62; /dev/null
bzip2 $TARFILE

# Copy the file to another host - we have ssh keys for making this work without intervention.
scp $BZIPFILE $SERVER:$REMOTEDIR &#62; /dev/null 2&#62;&#38;1

# Create a timestamp in a logfile.
date &#62;&#62; $LOGFILE
echo backup succeeded &#62;&#62; $LOGFILE
</PRE
></FONT
></TD
></TR
></TABLE
><DIV
CLASS="note"
><P
></P
><TABLE
CLASS="note"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>Large directories and low bandwidth</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The above is purely an example that everybody can understand, using a small directory and a host on the same subnet.  Depending on your bandwidth, the size of the directory and the location of the remote server, it can take an awful lot of time to make backups using this mechanism.  For larger directories and lower bandwidth, use <B
CLASS="command"
>rsync</B
> to keep the directories at both ends synchronized.</P
></TD
></TR
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="sect_03_03"
></A
>3.3. Quoting characters</H1
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="sect_03_03_01"
></A
>3.3.1. Why?</H2
><P
>A lot of keys have special meanings in some context or other.  Quoting is used to remove the special meaning of characters or words: quotes can disable special treatment for special characters, they can prevent reserved words from being recognized as such and they can disable parameter expansion.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_03_03_02"
></A
>3.3.2. Escape characters</H2
><P
>Escape characters are used to remove the special meaning from a single character.  A non-quoted backslash, \, is used as an escape character in Bash.  It preserves the literal value of the next character that follows, with the exception of <EM
>newline</EM
>.  If a newline character appears immediately after the backslash, it marks the continuation of a line when it is longer that the width of the terminal; the backslash is removed from the input stream and effectively ignored.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>franky ~&#62;</TT
> <B
CLASS="command"
><TT
CLASS="varname"
>date</TT
>=<TT
CLASS="parameter"
><I
>20021226</I
></TT
></B
>

<TT
CLASS="prompt"
>franky ~&#62;</TT
> <B
CLASS="command"
>echo <TT
CLASS="varname"
>$date</TT
></B
>
20021226

<TT
CLASS="prompt"
>franky ~&#62;</TT
> <B
CLASS="command"
>echo <TT
CLASS="parameter"
><I
>\$date</I
></TT
></B
>
$date
</PRE
></FONT
></TD
></TR
></TABLE
><P
>In this example, the variable <TT
CLASS="varname"
>date</TT
> is created and set to hold a value.  The first <B
CLASS="command"
>echo</B
> displays the value of the variable, but for the second, the dollar sign is escaped.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_03_03_03"
></A
>3.3.3. Single quotes</H2
><P
>Single quotes ('') are used to preserve the literal value of each character enclosed within the quotes.  A single quote may not occur between single quotes, even when preceded by a backslash.</P
><P
>We continue with the previous example:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>franky ~&#62;</TT
> <B
CLASS="command"
>echo <TT
CLASS="parameter"
><I
>'$date'</I
></TT
></B
>
$date
</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_03_03_04"
></A
>3.3.4. Double quotes</H2
><P
>Using double quotes the literal value of all characters enclosed is preserved, except for the dollar sign, the backticks (backward single quotes, ``) and the backslash.</P
><P
>The dollar sign and the backticks retain their special meaning within the double quotes.</P
><P
>The backslash retains its meaning only when followed by dollar, backtick, double quote, backslash or newline.  Within double quotes, the backslashes are removed from the input stream when followed by one of these characters.  Backslashes preceding characters that don't have a special meaning are left unmodified for processing by the shell interpreter.</P
><P
>A double quote may be quoted within double quotes by preceding it with a backslash.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>franky ~&#62;</TT
> <B
CLASS="command"
>echo <TT
CLASS="varname"
>"$date"</TT
></B
>
20021226

<TT
CLASS="prompt"
>franky ~&#62;</TT
> <B
CLASS="command"
>echo <TT
CLASS="parameter"
><I
>"`date`"</I
></TT
></B
>
Sun Apr 20 11:22:06 CEST 2003

<TT
CLASS="prompt"
>franky ~&#62;</TT
> <B
CLASS="command"
>echo <TT
CLASS="parameter"
><I
>"I'd say: \"Go for it!\""</I
></TT
></B
>
I'd say: "Go for it!"

<TT
CLASS="prompt"
>franky ~&#62;</TT
> <B
CLASS="command"
>echo <TT
CLASS="parameter"
><I
>"\"</I
></TT
></B
>
<TT
CLASS="prompt"
>More input&#62;</TT
><B
CLASS="command"
>"</B
>

<TT
CLASS="prompt"
>franky ~&#62;</TT
> <B
CLASS="command"
>echo <TT
CLASS="parameter"
><I
>"\\"</I
></TT
></B
>
\
</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_03_03_05"
></A
>3.3.5. ANSI-C quoting</H2
><P
>Words in the form <SPAN
CLASS="QUOTE"
>"$'STRING'"</SPAN
> are treated in a special way.  The word expands to a string, with backslash-escaped characters replaced as specified by the ANSI-C standard.  Backslash escape sequences can be found in the Bash documentation.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_03_03_06"
></A
>3.3.6. Locales</H2
><P
>A double-quoted string preceded by a dollar sign will cause the string to be translated according to the current locale.  If the current locale is <SPAN
CLASS="QUOTE"
>"C"</SPAN
> or <SPAN
CLASS="QUOTE"
>"POSIX"</SPAN
>, the dollar sign is ignored.  If the string is translated and replaced, the replacement is double-quoted.</P
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="sect_03_04"
></A
>3.4. Shell expansion</H1
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="sect_03_04_0"
></A
>3.4.1. General</H2
><P
>After the command has been split into <EM
>tokens</EM
> (see <A
HREF="#sect_01_04_01_01"
>Section 1.4.1.1</A
>), these tokens or words are expanded or resolved.  There are eight kinds of expansion performed, which we will discuss in the next sections, in the order that they are expanded.</P
><P
>After all expansions, quote removal is performed.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_03_04_01"
></A
>3.4.2. Brace expansion</H2
><P
>Brace expansion is a mechanism by which arbitrary strings may be generated.  Patterns to be brace-expanded take the form of an optional <EM
>PREAMBLE</EM
>, followed by a series of comma-separated strings between a pair of braces, followed by an optional <EM
>POSTSCRIPT</EM
>.  The preamble is prefixed to each string contained within the braces, and the postscript is then appended to each resulting string, expanding left to right.</P
><P
>Brace expansions may be nested.  The results of each expanded string are not sorted; left to right order is preserved:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>franky ~&#62;</TT
> <B
CLASS="command"
>echo <TT
CLASS="parameter"
><I
>sp{el,il,al}l</I
></TT
></B
>
spell spill spall
</PRE
></FONT
></TD
></TR
></TABLE
><P
>Brace expansion is performed before any other expansions, and any characters special to other expansions are preserved in the result.  It is strictly textual.  Bash does not apply any syntactic interpretation to the context of the expansion or the text between the braces.  To avoid conflicts with parameter expansion, the string <SPAN
CLASS="QUOTE"
>"${"</SPAN
> is not considered eligible for brace expansion.</P
><P
>A correctly-formed brace expansion must contain unquoted opening and closing braces, and at least one unquoted comma.  Any incorrectly formed brace expansion is left unchanged.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_03_04_02"
></A
>3.4.3. Tilde expansion</H2
><P
>If a word begins with an unquoted tilde character (<SPAN
CLASS="QUOTE"
>"~"</SPAN
>), all of the characters up to the first unquoted slash (or all characters, if there is no unquoted slash) are considered a <EM
>tilde-prefix</EM
>.  If none of the characters in the tilde-prefix are quoted, the characters in the tilde-prefix following the tilde are treated as a possible login name.  If this login name is the null string, the tilde is replaced with the value of the <TT
CLASS="varname"
>HOME</TT
> shell variable.  If <TT
CLASS="varname"
>HOME</TT
> is unset, the home directory of the user executing the shell is substituted instead.  Otherwise, the tilde-prefix is replaced with the home directory associated with the specified login name.</P
><P
>If the tilde-prefix is <SPAN
CLASS="QUOTE"
>"~+"</SPAN
>, the value of the shell variable <TT
CLASS="varname"
>PWD</TT
> replaces the tilde-prefix.  If the tilde-prefix is <SPAN
CLASS="QUOTE"
>"~-"</SPAN
>, the value of the shell variable <TT
CLASS="varname"
>OLDPWD</TT
>, if it is set, is substituted.</P
><P
>If the characters following the tilde in the tilde-prefix consist of a number N, optionally prefixed by a <SPAN
CLASS="QUOTE"
>"+"</SPAN
> or a <SPAN
CLASS="QUOTE"
>"-"</SPAN
>, the tilde-prefix is replaced with the corresponding element from the directory stack, as it would be displayed by the <B
CLASS="command"
>dirs</B
> built-in invoked with the characters following tilde in the tilde-prefix as an argument.  If the tilde-prefix, without the tilde, consists of a number without a leading <SPAN
CLASS="QUOTE"
>"+"</SPAN
> or <SPAN
CLASS="QUOTE"
>"-"</SPAN
>, <SPAN
CLASS="QUOTE"
>"+"</SPAN
> is assumed.</P
><P
>If the login name is invalid, or the tilde expansion fails, the word
is left unchanged.</P
><P
>Each variable assignment is checked for unquoted tilde-prefixes immediately following a <SPAN
CLASS="QUOTE"
>":"</SPAN
> or <SPAN
CLASS="QUOTE"
>"="</SPAN
>.  In these cases, tilde expansion is also performed.  Consequently, one may use file names with tildes in assignments to <TT
CLASS="varname"
>PATH</TT
>, <TT
CLASS="varname"
>MAILPATH</TT
>, and <TT
CLASS="varname"
>CDPATH</TT
>, and the shell assigns the expanded value.</P
><P
>Example:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>franky ~&#62;</TT
> <B
CLASS="command"
>export <TT
CLASS="varname"
>PATH</TT
>=<TT
CLASS="parameter"
><I
>"$PATH:~/testdir"</I
></TT
></B
>
</PRE
></FONT
></TD
></TR
></TABLE
><P
><TT
CLASS="filename"
>~/testdir</TT
> will be expanded to <TT
CLASS="varname"
>$HOME</TT
><TT
CLASS="filename"
>/testdir</TT
>, so if <TT
CLASS="varname"
>$HOME</TT
> is <TT
CLASS="filename"
>/var/home/franky</TT
>, the directory <TT
CLASS="filename"
>/var/home/franky/testdir</TT
> will be added to the content of the <TT
CLASS="varname"
>PATH</TT
> variable.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_03_04_03"
></A
>3.4.4. Shell parameter and variable expansion</H2
><P
>The <SPAN
CLASS="QUOTE"
>"$"</SPAN
> character introduces parameter expansion, command substitution, or arithmetic expansion.  The parameter name or symbol to be expanded may be enclosed in braces, which are optional but serve to protect the variable to be expanded from characters immediately following it which could be interpreted as part of the name.</P
><P
>When braces are used, the matching ending brace is the first <SPAN
CLASS="QUOTE"
>"}"</SPAN
> not escaped by a backslash or within a quoted string, and not within an embedded arithmetic expansion, command substitution, or parameter expansion.</P
><P
>The basic form of parameter expansion is <SPAN
CLASS="QUOTE"
>"${PARAMETER}"</SPAN
>.  The value of <SPAN
CLASS="QUOTE"
>"PARAMETER"</SPAN
> is substituted.  The braces are required when <SPAN
CLASS="QUOTE"
>"PARAMETER"</SPAN
> is a positional parameter with more than one digit, or when <SPAN
CLASS="QUOTE"
>"PARAMETER"</SPAN
> is followed by a character that is not to be interpreted as part of its name.</P
><P
>If the first character of <SPAN
CLASS="QUOTE"
>"PARAMETER"</SPAN
> is an exclamation point,  Bash uses the value of the variable formed from the rest of <SPAN
CLASS="QUOTE"
>"PARAMETER"</SPAN
> as the name of the variable; this variable is then expanded and that value is used in the rest of the substitution, rather than the value of <SPAN
CLASS="QUOTE"
>"PARAMETER"</SPAN
> itself.  This is known as <EM
>indirect expansion</EM
>.</P
><P
>You are certainly familiar with straight parameter expansion, since it happens all the time, even in the simplest of cases, such as the one above or the following:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>franky ~&#62;</TT
> <B
CLASS="command"
>echo <TT
CLASS="varname"
>$SHELL</TT
></B
>
/bin/bash
</PRE
></FONT
></TD
></TR
></TABLE
><P
>The following is an example of indirect expansion:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>franky ~&#62;</TT
> <B
CLASS="command"
>echo <TT
CLASS="varname"
>${!N*}</TT
></B
>
NNTPPORT NNTPSERVER NPX_PLUGIN_PATH
</PRE
></FONT
></TD
></TR
></TABLE
><P
>Note that this is not the same as <B
CLASS="command"
>echo <TT
CLASS="varname"
>$N*</TT
></B
>.</P
><P
>The following construct allows for creation of the named variable if it does not yet exist:</P
><P
><B
CLASS="command"
>${<TT
CLASS="varname"
>VAR</TT
>:=<TT
CLASS="parameter"
><I
>value</I
></TT
>}</B
> </P
><P
>Example:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>franky ~&#62;</TT
> <B
CLASS="command"
>echo <TT
CLASS="varname"
>$FRANKY</TT
></B
>

<TT
CLASS="prompt"
>franky ~&#62;</TT
> <B
CLASS="command"
>echo <TT
CLASS="parameter"
><I
>${FRANKY:=Franky}</I
></TT
></B
>
Franky
</PRE
></FONT
></TD
></TR
></TABLE
><P
>Special parameters, among others the positional parameters, may not be assigned this way, however.</P
><P
>We will further discuss the use of the curly braces for treatment of variables in <A
HREF="#chap_10"
>Chapter 10</A
>.  More information can also be found in the Bash info pages.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_03_04_04"
></A
>3.4.5. Command substitution</H2
><P
>Command substitution allows the output of a command to replace the
command itself.  Command substitution occurs when a command is enclosed like this:</P
><P
><B
CLASS="command"
>$(command)</B
> </P
><P
>or like this using backticks:</P
><P
><B
CLASS="command"
>`command`</B
> </P
><P
>Bash performs the expansion by executing COMMAND and replacing the command substitution with the standard output of the command, with any trailing newlines deleted.  Embedded newlines are not deleted, but they may be removed during word splitting.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>franky ~&#62;</TT
> <B
CLASS="command"
>echo <TT
CLASS="parameter"
><I
>`date`</I
></TT
></B
>
Thu Feb 6 10:06:20 CET 2003
</PRE
></FONT
></TD
></TR
></TABLE
><P
>When the old-style backquoted form of substitution is used, backslash retains its literal meaning except when followed by <SPAN
CLASS="QUOTE"
>"$"</SPAN
>, <SPAN
CLASS="QUOTE"
>"`"</SPAN
>, or <SPAN
CLASS="QUOTE"
>"\"</SPAN
>.  The first backticks not preceded by a backslash terminates the command substitution.  When using the <SPAN
CLASS="QUOTE"
>"$(COMMAND)"</SPAN
> form, all characters between the parentheses make up the command; none are treated specially.</P
><P
>Command substitutions may be nested.  To nest when using the backquoted form, escape the inner backticks with backslashes.</P
><P
>If the substitution appears within double quotes, word splitting and file name expansion are not performed on the results.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_03_04_05"
></A
>3.4.6. Arithmetic expansion</H2
><P
>Arithmetic expansion allows the evaluation of an arithmetic expression and the substitution of the result.  The format for arithmetic expansion is:</P
><P
><B
CLASS="command"
>$(( EXPRESSION ))</B
> </P
><P
>The expression is treated as if it were within double quotes, but a double quote inside the parentheses is not treated specially.  All tokens in the expression undergo parameter expansion, command substitution, and quote removal.  Arithmetic substitutions may be nested.</P
><P
>Evaluation of arithmetic expressions is done in fixed-width integers with no check for overflow - although division by zero is trapped and recognized as an error.  The operators are roughly the same as in the C programming language.  In order of decreasing precedence, the list looks like this:</P
><DIV
CLASS="table"
><A
NAME="table_03_04"
></A
><P
><B
>Table 3-4. Arithmetic operators</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
>Operator</TH
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
>Meaning</TH
></TR
></THEAD
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>VAR++ and VAR--</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>variable post-increment and post-decrement</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>++VAR and --VAR</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>variable pre-increment and pre-decrement</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>- and +</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>unary minus and plus</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>! and ~</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>logical and bitwise negation</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>**</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>exponentiation</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>*, / and %</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>multiplication, division, remainder</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>+ and -</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>addition, subtraction</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>&#60;&#60; and &#62;&#62;</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>left and right bitwise shifts</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>&#60;=, &#62;=, &#60; and &#62;</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>comparison operators</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>== and !=</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>equality and inequality</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>&#38;</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>bitwise AND</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>^</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>bitwise exclusive OR</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>|</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>bitwise OR</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>&#38;&#38;</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>logical AND</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>||</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>logical OR</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>expr ? expr : expr</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>conditional evaluation</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>=, *=, /=, %=, +=, -=, &#60;&#60;=, &#62;&#62;=, &#38;=, ^= and |=</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>assignments</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>,</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>separator between expressions</TD
></TR
></TBODY
></TABLE
></DIV
><P
>Shell variables are allowed as operands; parameter expansion is performed before the expression is evaluated.  Within an expression, shell variables may also be referenced by name without using the parameter expansion syntax.  The value of a variable is evaluated as an arithmetic expression when it is referenced.  A shell variable need not have its integer attribute turned on to be used in an expression.</P
><P
>Constants with a leading 0 (zero) are interpreted as octal numbers.  A
leading <SPAN
CLASS="QUOTE"
>"0x"</SPAN
> or <SPAN
CLASS="QUOTE"
>"0X"</SPAN
> denotes hexadecimal.  Otherwise, numbers take the form <SPAN
CLASS="QUOTE"
>"[BASE'#']N"</SPAN
>, where <SPAN
CLASS="QUOTE"
>"BASE"</SPAN
> is a decimal number between 2 and 64 representing the arithmetic base, and N is a number in that base.  If <SPAN
CLASS="QUOTE"
>"BASE'#'"</SPAN
> is omitted, then base 10 is used.  The digits greater than 9 are represented by the lowercase letters, the uppercase letters, <SPAN
CLASS="QUOTE"
>"@"</SPAN
>, and <SPAN
CLASS="QUOTE"
>"_"</SPAN
>, in that order.  If <SPAN
CLASS="QUOTE"
>"BASE"</SPAN
> is less than or equal to 36, lowercase and uppercase letters may be used interchangably to represent numbers between 10 and 35.</P
><P
>Operators are evaluated in order of precedence.  Sub-expressions in parentheses are evaluated first and may override the precedence rules above.</P
><P
>Wherever possible, Bash users should try to use the syntax with square brackets:</P
><P
><B
CLASS="command"
>$[ EXPRESSION ]</B
> </P
><P
>However, this will only calculate the result of <EM
>EXPRESSION</EM
>, and do no tests:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>franky ~&#62;</TT
> <B
CLASS="command"
>echo <TT
CLASS="parameter"
><I
>$[365*24]</I
></TT
></B
>
8760
</PRE
></FONT
></TD
></TR
></TABLE
><P
>See <A
HREF="#sect_07_01_02_02"
>Section 7.1.2.2</A
>, among others, for practical examples in scripts.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_03_04_06"
></A
>3.4.7. Process substitution</H2
><P
>Process substitution is supported on systems that support named pipes (FIFOs) or the <TT
CLASS="filename"
>/dev/fd</TT
> method of naming open files.  It takes the form of</P
><P
><B
CLASS="command"
>&#60;(LIST)</B
> </P
><P
>or</P
><P
><B
CLASS="command"
>&#62;(LIST)</B
> </P
><P
>The process <TT
CLASS="varname"
>LIST</TT
> is run with its input or output connected to a FIFO or some file in <TT
CLASS="filename"
>/dev/fd</TT
>.  The name of this file is passed as an argument to the current command as the result of the expansion.  If the <SPAN
CLASS="QUOTE"
>"&#62;(LIST)"</SPAN
> form is used, writing to the file will provide input for <TT
CLASS="varname"
>LIST</TT
>.  If the <SPAN
CLASS="QUOTE"
>"&#60;(LIST)"</SPAN
> form is used, the file passed as an argument should be read to obtain the output of <TT
CLASS="varname"
>LIST</TT
>.  Note that no space may appear between the &#60; or &#62; signs and the left parenthesis, otherwise the construct would be interpreted as a redirection.</P
><P
>When available, process substitution is performed simultaneously with parameter and variable expansion, command substitution, and arithmetic expansion.</P
><P
>More information in <A
HREF="#sect_08_02_03"
>Section 8.2.3</A
>.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_03_04_07"
></A
>3.4.8. Word splitting</H2
><P
>The shell scans the results of parameter expansion, command substitution, and arithmetic expansion that did not occur within double quotes for word splitting.</P
><P
>The shell treats each character of <TT
CLASS="varname"
>$IFS</TT
> as a delimiter, and splits the results of the other expansions into words on these characters.  If <TT
CLASS="varname"
>IFS</TT
> is unset, or its value is exactly <SPAN
CLASS="QUOTE"
>"'&#60;space&#62;&#60;tab&#62;&#60;newline&#62;'"</SPAN
>, the default, then any sequence of <TT
CLASS="varname"
>IFS</TT
> characters serves to delimit words.  If <TT
CLASS="varname"
>IFS</TT
> has a value other than the default, then sequences of the whitespace characters <SPAN
CLASS="QUOTE"
>"space"</SPAN
> and <SPAN
CLASS="QUOTE"
>"Tab"</SPAN
> are ignored at the beginning and end of the word, as long as the whitespace character is in the value of <TT
CLASS="varname"
>IFS</TT
> (an <TT
CLASS="varname"
>IFS</TT
> whitespace character).  Any character in <TT
CLASS="varname"
>IFS</TT
> that is not <TT
CLASS="varname"
>IFS</TT
> whitespace, along with any adjacent <TT
CLASS="varname"
>IF</TT
> whitespace characters, delimits a field.  A sequence of <TT
CLASS="varname"
>IFS</TT
> whitespace characters is also treated as a delimiter.  If the value of <TT
CLASS="varname"
>IFS</TT
> is null, no word splitting occurs.</P
><P
>Explicit null arguments (<SPAN
CLASS="QUOTE"
>""""</SPAN
> or <SPAN
CLASS="QUOTE"
>"''"</SPAN
>) are retained.  Unquoted implicit null arguments, resulting from the expansion of parameters that have no values, are removed.  If a parameter with no value is expanded within double quotes, a null argument results and is retained.</P
><DIV
CLASS="note"
><P
></P
><TABLE
CLASS="note"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>Expansion and word splitting</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>If no expansion occurs, no splitting is performed.</P
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_03_04_08"
></A
>3.4.9. File name expansion</H2
><P
>After word splitting, unless the <TT
CLASS="option"
>-f</TT
> option has been set (see <A
HREF="#sect_02_03_02"
>Section 2.3.2</A
>), Bash scans each word for the characters <SPAN
CLASS="QUOTE"
>"*"</SPAN
>, <SPAN
CLASS="QUOTE"
>"?"</SPAN
>, and <SPAN
CLASS="QUOTE"
>"["</SPAN
>.  If one of these characters appears, then the word is regarded as a <EM
>PATTERN</EM
>, and replaced with an alphabetically sorted list of file names matching the pattern. If no matching file names are found, and the shell option <TT
CLASS="option"
>nullglob</TT
> is disabled, the word is left unchanged.  If the <TT
CLASS="option"
>nullglob</TT
> option is set, and no matches are found, the word is removed.  If the shell option <TT
CLASS="option"
>nocaseglob</TT
> is enabled, the match is performed without regard to the case of alphabetic characters.</P
><P
>When a pattern is used for file name generation, the character <SPAN
CLASS="QUOTE"
>"."</SPAN
> at the start of a file name or immediately following a slash must be matched explicitly, unless the shell option <TT
CLASS="option"
>dotglob</TT
> is set.  When matching a file name, the slash character must always be matched explicitly.  In other cases, the <SPAN
CLASS="QUOTE"
>"."</SPAN
> character is not treated specially.</P
><P
>The <TT
CLASS="varname"
>GLOBIGNORE</TT
> shell variable may be used to restrict the set of file names matching a pattern.  If <TT
CLASS="varname"
>GLOBIGNORE</TT
> is set, each matching file name that also matches one of the patterns in <TT
CLASS="varname"
>GLOBIGNORE</TT
> is removed from the list of matches.  The file names <TT
CLASS="filename"
>.</TT
> and <TT
CLASS="filename"
>..</TT
> are always ignored, even when <TT
CLASS="varname"
>GLOBIGNORE</TT
> is set.  However, setting <TT
CLASS="varname"
>GLOBIGNORE</TT
> has the effect of enabling the <TT
CLASS="option"
>dotglob</TT
> shell option, so all other file names beginning with a <SPAN
CLASS="QUOTE"
>"."</SPAN
> will match.  To get the old behavior of ignoring file names beginning with a <SPAN
CLASS="QUOTE"
>"."</SPAN
>, make <SPAN
CLASS="QUOTE"
>".*"</SPAN
> one of the patterns in <TT
CLASS="varname"
>GLOBIGNORE</TT
>.  The <TT
CLASS="option"
>dotglob</TT
> option is disabled when <TT
CLASS="varname"
>GLOBIGNORE</TT
> is unset.</P
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="sect_03_05"
></A
>3.5. Aliases</H1
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="sect_03_05_01"
></A
>3.5.1. What are aliases?</H2
><P
>An alias allows a string to be substituted for a word when it is used as the first word of a simple command.  The shell maintains a list of aliases that may be set and unset with the <B
CLASS="command"
>alias</B
> and <B
CLASS="command"
>unalias</B
> built-in commands.  Issue the <B
CLASS="command"
>alias</B
> without options to display a list of aliases known to the current shell.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>franky: ~&#62;</TT
> <B
CLASS="command"
>alias</B
>
alias ..='cd ..'
alias ...='cd ../..'
alias ....='cd ../../..'
alias PAGER='less -r'
alias Txterm='export TERM=xterm'
alias XARGS='xargs -r'
alias cdrecord='cdrecord -dev 0,0,0 -speed=8'
alias e='vi'
alias egrep='grep -E'
alias ewformat='fdformat -n /dev/fd0u1743; ewfsck'
alias fgrep='grep -F'
alias ftp='ncftp -d15'
alias h='history 10'
alias fformat='fdformat /dev/fd0H1440'
alias j='jobs -l'
alias ksane='setterm -reset'
alias ls='ls -F --color=auto'
alias m='less'
alias md='mkdir'
alias od='od -Ax -ta -txC'
alias p='pstree -p'
alias ping='ping -vc1'
alias sb='ssh blubber'
alias sl='ls'
alias ss='ssh octarine'
alias tar='gtar'
alias tmp='cd /tmp'
alias unaliasall='unalias -a'
alias vi='eval `resize`;vi'
alias vt100='export TERM=vt100'
alias which='type'
alias xt='xterm -bg black -fg white &#38;'

<TT
CLASS="prompt"
>franky ~&#62;</TT
>
</PRE
></FONT
></TD
></TR
></TABLE
><P
>Aliases are useful for specifying the default version of a command that exists in several versions on your system, or to specify default options to a command.  Another use for aliases is for correcting incorrect spelling.</P
><P
>The first word of each simple command, if unquoted, is checked to see if it has an alias.  If so, that word is replaced by the text of the alias.  The alias name and the replacement text may contain any valid shell input, including shell metacharacters, with the exception that the alias name may not contain <SPAN
CLASS="QUOTE"
>"="</SPAN
>.  The first word of the replacement text is tested for aliases, but a word that is identical to an alias being expanded is not expanded a second time.  This means that one may alias <B
CLASS="command"
>ls</B
> to <B
CLASS="command"
>ls <TT
CLASS="option"
>-F</TT
></B
>, for instance, and Bash will not try to recursively expand the replacement text. If the last character of the alias value is a space or tab character, then the next command word following the alias is also checked for alias expansion.</P
><P
>Aliases are not expanded when the shell is not interactive, unless
the <TT
CLASS="option"
>expand_aliases</TT
> option is set using the <B
CLASS="command"
>shopt</B
> shell built-in.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_03_05_02"
></A
>3.5.2. Creating and removing aliases</H2
><P
>Aliases are created using the <B
CLASS="command"
>alias</B
> shell built-in.  For permanent use, enter the <B
CLASS="command"
>alias</B
> in one of your shell initialization files; if you just enter the alias on the command line, it is only recognized within the current shell.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>franky ~&#62;</TT
> <B
CLASS="command"
>alias <TT
CLASS="parameter"
><I
>dh='df -h'</I
></TT
></B
>

<TT
CLASS="prompt"
>franky ~&#62;</TT
> <B
CLASS="command"
>dh</B
>
Filesystem            Size  Used Avail Use% Mounted on
/dev/hda7             1.3G  272M 1018M  22% /
/dev/hda1             121M  9.4M  105M   9% /boot
/dev/hda2              13G  8.7G  3.7G  70% /home
/dev/hda3              13G  5.3G  7.1G  43% /opt
none                  243M     0  243M   0% /dev/shm
/dev/hda6             3.9G  3.2G  572M  85% /usr
/dev/hda5             5.2G  4.3G  725M  86% /var

<TT
CLASS="prompt"
>franky ~&#62;</TT
> <B
CLASS="command"
>unalias <TT
CLASS="parameter"
><I
>dh</I
></TT
></B
>

<TT
CLASS="prompt"
>franky ~&#62;</TT
> <B
CLASS="command"
>dh</B
>
bash: dh: command not found

<TT
CLASS="prompt"
>franky ~&#62;</TT
>
</PRE
></FONT
></TD
></TR
></TABLE
><P
>Bash always reads at least one complete line of input before executing any of the commands on that line.  Aliases are expanded when a command is read, not when it is executed.  Therefore, an alias definition appearing on the same line as another command does not take effect until the next line of input is read.  The commands following the alias definition on that line are not affected by the new alias.  This behavior is also an issue when functions are executed. Aliases are expanded when a function definition is read, not when the function is executed, because a function definition is itself a compound command.  As a consequence, aliases defined in a function are not available until after that function is executed.  To be safe, always put alias definitions on a separate line, and do not use <B
CLASS="command"
>alias</B
> in compound commands.</P
><P
>Aliases are not inherited by child processes.  Bourne shell (<B
CLASS="command"
>sh</B
>) does not recognize aliases.</P
><P
>More about functions is in <A
HREF="#chap_11"
>Chapter 11</A
>.</P
><DIV
CLASS="tip"
><P
></P
><TABLE
CLASS="tip"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="images/tip.gif"
HSPACE="5"
ALT="Tip"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>Functions are faster</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Aliases are looked up after functions and thus resolving is slower.  While aliases are easier to understand, shell functions are preferred over aliases for almost every purpose.</P
></TD
></TR
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="sect_03_06"
></A
>3.6. More Bash options</H1
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="sect_03_06_01"
></A
>3.6.1. Displaying options</H2
><P
>We already discussed a couple of Bash options that are useful for debugging your scripts.  In this section, we will take a more in-depth view of the Bash options.</P
><P
>Use the <TT
CLASS="option"
>-o</TT
> option to <B
CLASS="command"
>set</B
> to display all shell options:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>willy:~&#62;</TT
> <B
CLASS="command"
>set <TT
CLASS="option"
>-o</TT
></B
>
allexport		off
braceexpand		on
emacs			on
errexit			off
hashall			on
histexpand		on
history			on
ignoreeof		off
interactive-comments	on
keyword			off
monitor			on
noclobber		off
noexec			off
noglob			off
nolog			off
notify			off
nounset			off
onecmd			off
physical		off
posix			off
privileged		off
verbose			off
vi			off
xtrace			off
</PRE
></FONT
></TD
></TR
></TABLE
><P
>See the Bash Info pages, section <SPAN
CLASS="guimenu"
>Shell Built-in Commands</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>The Set Built-in</SPAN
> for a description of each option.  A lot of options have one-character shorthands: the <TT
CLASS="option"
>xtrace</TT
> option, for instance, is equal to specifying <B
CLASS="command"
>set <TT
CLASS="option"
>-x</TT
></B
>.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_03_06_02"
></A
>3.6.2. Changing options</H2
><P
>Shell options can either be set different from the default upon calling the shell, or be set during shell operation.  They may also be included in the shell resource configuration files.</P
><P
>The following command executes a script in POSIX-compatible mode:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>willy:~/scripts&#62;</TT
> <B
CLASS="command"
>bash <TT
CLASS="option"
>--posix</TT
> <TT
CLASS="filename"
>script.sh</TT
></B
>
</PRE
></FONT
></TD
></TR
></TABLE
><P
>For changing the current environment temporarily, or for use in a script,
we would rather use <B
CLASS="command"
>set</B
>.  Use <EM
>-</EM
> (dash) for enabling an option, <EM
>+</EM
> for disabling:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>willy:~/test&#62;</TT
> <B
CLASS="command"
>set <TT
CLASS="option"
>-o</TT
> <TT
CLASS="parameter"
><I
>noclobber</I
></TT
></B
>

<TT
CLASS="prompt"
>willy:~/test&#62;</TT
> <B
CLASS="command"
>touch <TT
CLASS="filename"
>test</TT
></B
>

<TT
CLASS="prompt"
>willy:~/test&#62;</TT
> <B
CLASS="command"
>date &#62; <TT
CLASS="filename"
>test</TT
></B
>
bash: test: cannot overwrite existing file

<TT
CLASS="prompt"
>willy:~/test&#62;</TT
> <B
CLASS="command"
>set <TT
CLASS="option"
>+o</TT
> <TT
CLASS="parameter"
><I
>noclobber</I
></TT
></B
>

<TT
CLASS="prompt"
>willy:~/test&#62;</TT
> <B
CLASS="command"
>date &#62; <TT
CLASS="filename"
>test</TT
></B
>
</PRE
></FONT
></TD
></TR
></TABLE
><P
>The above example demonstrates the <TT
CLASS="option"
>noclobber</TT
> option, which prevents existing files from being overwritten by redirection operations.  The same goes for one-character options, for instance <TT
CLASS="option"
>-u</TT
>, which will treat unset variables as an error when set, and exits a non-interactive shell upon
encountering such errors:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>willy:~&#62;</TT
> <B
CLASS="command"
>echo <TT
CLASS="varname"
>$VAR</TT
></B
>


<TT
CLASS="prompt"
>willy:~&#62;</TT
> <B
CLASS="command"
>set <TT
CLASS="option"
>-u</TT
></B
>

<TT
CLASS="prompt"
>willy:~&#62;</TT
> <B
CLASS="command"
>echo <TT
CLASS="varname"
>$VAR</TT
></B
>
bash: VAR: unbound variable
</PRE
></FONT
></TD
></TR
></TABLE
><P
>This option is also useful for detecting incorrect content assignment to variables: the same error will also occur, for instance, when assigning a character string to a variable that was declared explicitly as one holding only integer values.</P
><P
>One last example follows, demonstrating the <TT
CLASS="option"
>noglob</TT
> option, which prevents special characters from being expanded:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>willy:~/testdir&#62;</TT
> <B
CLASS="command"
>set <TT
CLASS="option"
>-o</TT
> <TT
CLASS="parameter"
><I
>noglob</I
></TT
></B
>

<TT
CLASS="prompt"
>willy:~/testdir&#62;</TT
> <B
CLASS="command"
>touch <TT
CLASS="filename"
>*</TT
></B
>

<TT
CLASS="prompt"
>willy:~/testdir&#62;</TT
> <B
CLASS="command"
>ls <TT
CLASS="option"
>-l</TT
> <TT
CLASS="filename"
>*</TT
></B
>
-rw-rw-r--    1 willy    willy		0 Feb 27 13:37 *
</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="sect_03_07"
></A
>3.7. Summary</H1
><P
>The Bash environment can be configured globally and on a per user basis.  Various configuration files are used to fine-tune the behavior of the shell.</P
><P
>These files contain shell options, settings for variables, function definitions and various other building blocks for creating ourselves a cosy environment.</P
><P
>Except for the reserved Bourne shell, Bash and special parameters, variable names can be chosen more or less freely.</P
><P
>Because a lot of characters have double or even triple meanings, depending on the environment, Bash uses a system of quoting to take away special meaning from one or multiple characters when special treatment is not wanted.</P
><P
>Bash uses various methods of expanding command line entries in order to determine which commands to execute.</P
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="sect_03_08"
></A
>3.8. Exercises</H1
><P
>For this exercise, you will need to read the <B
CLASS="command"
>useradd</B
> man pages, because we are going to use the <TT
CLASS="filename"
>/etc/skel</TT
> directory to hold default shell configuration files, which are copied to the home directory of each newly added user.</P
><P
>First we will do some general exercises on setting and displaying variables.</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Create 3 variables, <TT
CLASS="varname"
>VAR1</TT
>, <TT
CLASS="varname"
>VAR2</TT
> and <TT
CLASS="varname"
>VAR3</TT
>; initialize them to hold the values <SPAN
CLASS="QUOTE"
>"thirteen"</SPAN
>, <SPAN
CLASS="QUOTE"
>"13"</SPAN
> and <SPAN
CLASS="QUOTE"
>"Happy Birthday"</SPAN
> respectively.</P
></LI
><LI
><P
>Display the values of all three variables.</P
></LI
><LI
><P
>Are these local or global variables?</P
></LI
><LI
><P
>Remove <TT
CLASS="varname"
>VAR3</TT
>.</P
></LI
><LI
><P
>Can you see the two remaining variables in a new terminal window?</P
></LI
><LI
><P
>Edit <TT
CLASS="filename"
>/etc/profile</TT
> so that all users are greeted upon login (test this).</P
></LI
><LI
><P
>For the <EM
>root</EM
> account, set the prompt to something like <SPAN
CLASS="QUOTE"
>"Danger!! root is doing stuff in \w"</SPAN
>, preferably in a bright color such as red or pink or in reverse video mode.</P
></LI
><LI
><P
>Make sure that newly created users also get a nice personalized prompt which informs them on which system in which directory they are working.  Test your changes by adding a new user and logging in as that user.</P
></LI
><LI
><P
>Write a script in which you assign two integer values to two variables.  The script should calculate the surface of a rectangle which has these proportions.  It should be aired with comments and generate elegant output.</P
></LI
></OL
><P
>Don't forget to <B
CLASS="command"
>chmod</B
> your scripts!</P
></DIV
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="chap_04"
></A
>Chapter 4. Regular expressions</H1
><BLOCKQUOTE
CLASS="ABSTRACT"
><DIV
CLASS="abstract"
><A
NAME="AEN3160"
></A
><P
></P
><P
>In this chapter we discuss:</P
><P
><P
></P
><UL
><LI
><P
>Using regular expressions</P
></LI
><LI
><P
>Regular expression metacharacters</P
></LI
><LI
><P
>Finding patterns in files or output</P
></LI
><LI
><P
>Character ranges and classes in Bash</P
></LI
></UL
></P
><P
></P
></DIV
></BLOCKQUOTE
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="sect_04_01"
></A
>4.1. Regular expressions</H1
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="sect_04_01_01"
></A
>4.1.1. What are regular expressions?</H2
><P
>A <EM
>regular expression</EM
> is a pattern that describes a set of strings.  Regular expressions are constructed analogously to arithmetic expressions by using various operators to combine smaller expressions.</P
><P
>The fundamental building blocks are the regular expressions that match a single character.  Most characters, including all letters and digits, are regular expressions that match themselves.  Any metacharacter with special meaning may be quoted by preceding it with a backslash.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_04_01_02"
></A
>4.1.2. Regular expression metacharacters</H2
><P
>A regular expression may be followed by one of several repetition operators (metacharacters):</P
><DIV
CLASS="table"
><A
NAME="table_04_01"
></A
><P
><B
>Table 4-1. Regular expression operators</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
>Operator</TH
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
>Effect</TH
></TR
></THEAD
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>.</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Matches any single character.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>?</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>The preceding item is optional and will be matched, at most, once.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>*</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>The preceding item will be matched zero or more times.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>+</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>The preceding item will be matched one or more times.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>{N}</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>The preceding item is matched exactly N times.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>{N,}</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>The preceding item is matched N or more times.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>{N,M}</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>The preceding item is matched at least N times, but not more than M times.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>-</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>represents the range if it's not first or last in a list or the ending point of a range in a list.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>^</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Matches the empty string at the beginning of a line; also represents the characters not in the range of a list.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>$</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Matches the empty string at the end of a line.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>\b</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Matches the empty string at the edge of a word.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>\B</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Matches the empty string provided it's not at the edge of a word.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>\&#60;</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Match the empty string at the beginning of word.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>\&#62;</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Match the empty string at the end of word.</TD
></TR
></TBODY
></TABLE
></DIV
><P
>Two regular expressions may be concatenated; the resulting regular expression matches any string formed by concatenating two substrings that respectively match the concatenated subexpressions.</P
><P
>Two regular expressions may be joined by the infix operator <SPAN
CLASS="QUOTE"
>"|"</SPAN
>; the resulting regular expression matches any string matching either subexpression.</P
><P
>Repetition takes precedence over concatenation, which in turn takes precedence over alternation.  A whole subexpression may be enclosed in parentheses to override these precedence rules.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_04_01_03"
></A
>4.1.3. Basic versus extended regular expressions</H2
><P
>In basic regular expressions the metacharacters <SPAN
CLASS="QUOTE"
>"?"</SPAN
>, <SPAN
CLASS="QUOTE"
>"+"</SPAN
>, <SPAN
CLASS="QUOTE"
>"{"</SPAN
>, <SPAN
CLASS="QUOTE"
>"|"</SPAN
>, <SPAN
CLASS="QUOTE"
>"("</SPAN
>, and <SPAN
CLASS="QUOTE"
>")"</SPAN
> lose their special meaning; instead use the backslashed versions <SPAN
CLASS="QUOTE"
>"\?"</SPAN
>, <SPAN
CLASS="QUOTE"
>"\+"</SPAN
>, <SPAN
CLASS="QUOTE"
>"\{"</SPAN
>, <SPAN
CLASS="QUOTE"
>"\|"</SPAN
>, <SPAN
CLASS="QUOTE"
>"\("</SPAN
>, and <SPAN
CLASS="QUOTE"
>"\)"</SPAN
>.</P
><P
>Check in your system documentation whether commands using regular expressions support extended expressions.</P
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="sect_04_02"
></A
>4.2. Examples using grep</H1
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="sect_04_02_01"
></A
>4.2.1. What is grep?</H2
><P
><B
CLASS="command"
>grep</B
> searches the input files for lines containing a match to a given pattern list.  When it finds a match in a line, it copies the line to standard output (by default), or whatever other sort of output you have requested with options.</P
><P
>Though <B
CLASS="command"
>grep</B
> expects to do the matching on text, it has no limits on input line length other than available memory, and it can match arbitrary characters within a line.  If the final byte of an input file is not a <EM
>newline</EM
>, <B
CLASS="command"
>grep</B
> silently supplies one.  Since newline is also a separator for the list of patterns, there is no way to match newline characters in a text.</P
><P
>Some examples:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>cathy ~&#62;</TT
> <B
CLASS="command"
>grep <TT
CLASS="parameter"
><I
>root</I
></TT
> <TT
CLASS="filename"
>/etc/passwd</TT
></B
>
root:x:0:0:root:/root:/bin/bash
operator:x:11:0:operator:/root:/sbin/nologin

<TT
CLASS="prompt"
>cathy ~&#62;</TT
> <B
CLASS="command"
>grep <TT
CLASS="option"
>-n</TT
> <TT
CLASS="parameter"
><I
>root</I
></TT
> <TT
CLASS="filename"
>/etc/passwd</TT
></B
>
1:root:x:0:0:root:/root:/bin/bash
12:operator:x:11:0:operator:/root:/sbin/nologin

<TT
CLASS="prompt"
>cathy ~&#62;</TT
> <B
CLASS="command"
>grep <TT
CLASS="option"
>-v</TT
> <TT
CLASS="parameter"
><I
>bash</I
></TT
> <TT
CLASS="filename"
>/etc/passwd </TT
></B
>| <B
CLASS="command"
>grep <TT
CLASS="option"
>-v</TT
> <TT
CLASS="parameter"
><I
>nologin</I
></TT
></B
>
sync:x:5:0:sync:/sbin:/bin/sync
shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown
halt:x:7:0:halt:/sbin:/sbin/halt
news:x:9:13:news:/var/spool/news:
mailnull:x:47:47::/var/spool/mqueue:/dev/null
xfs:x:43:43:X Font Server:/etc/X11/fs:/bin/false
rpc:x:32:32:Portmapper RPC user:/:/bin/false
nscd:x:28:28:NSCD Daemon:/:/bin/false
named:x:25:25:Named:/var/named:/bin/false
squid:x:23:23::/var/spool/squid:/dev/null
ldap:x:55:55:LDAP User:/var/lib/ldap:/bin/false
apache:x:48:48:Apache:/var/www:/bin/false

<TT
CLASS="prompt"
>cathy ~&#62;</TT
> <B
CLASS="command"
>grep <TT
CLASS="option"
>-c</TT
> <TT
CLASS="parameter"
><I
>false</I
></TT
> <TT
CLASS="filename"
>/etc/passwd</TT
></B
>
7

<TT
CLASS="prompt"
>cathy ~&#62;</TT
> <B
CLASS="command"
>grep <TT
CLASS="option"
>-i</TT
> <TT
CLASS="parameter"
><I
>ps</I
></TT
> <TT
CLASS="filename"
>~/.bash*</TT
></B
> | <B
CLASS="command"
>grep <TT
CLASS="option"
>-v</TT
> <TT
CLASS="parameter"
><I
>history</I
></TT
></B
>
/home/cathy/.bashrc:PS1="\[\033[1;44m\]$USER is in \w\[\033[0m\] "

</PRE
></FONT
></TD
></TR
></TABLE
><P
>With the first command, user <EM
>cathy</EM
> displays the lines from <TT
CLASS="filename"
>/etc/passwd</TT
> containing the string <EM
>root</EM
>.</P
><P
>Then she displays the line numbers containing this search string.</P
><P
>With the third command she checks which users are not using <B
CLASS="command"
>bash</B
>, but accounts with the <B
CLASS="command"
>nologin</B
> shell are not displayed.</P
><P
>Then she counts the number of accounts that have <TT
CLASS="filename"
>/bin/false</TT
> as the shell.</P
><P
>The last command displays the lines from all the files in her home directory starting with <TT
CLASS="filename"
>~/.bash</TT
>, excluding matches containing the string <EM
>history</EM
>, so as to exclude matches from <TT
CLASS="filename"
>~/.bash_history</TT
> which might contain the same string, in upper or lower cases.  Note that the search is for the <EM
>string</EM
> <SPAN
CLASS="QUOTE"
>"ps"</SPAN
>, and not for the <EM
>command</EM
> <B
CLASS="command"
>ps</B
>.</P
><P
>Now let's see what else we can do with grep, using regular expressions.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_04_02_02"
></A
>4.2.2. Grep and regular expressions</H2
><DIV
CLASS="note"
><P
></P
><TABLE
CLASS="note"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>If you are not on Linux</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>We use GNU <B
CLASS="command"
>grep</B
> in these examples, which supports extended regular expressions.  GNU <B
CLASS="command"
>grep</B
> is the default on Linux systems.  If you are working on proprietary systems, check with the <TT
CLASS="option"
>-V</TT
> option which version you are using.  GNU <B
CLASS="command"
>grep</B
> can be downloaded from <A
HREF="http://gnu.org/directory/"
TARGET="_top"
>http://gnu.org/directory/</A
>.</P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="sect_04_02_02_01"
></A
>4.2.2.1. Line and word anchors</H3
><P
>From the previous example, we now exclusively want to display lines starting with the string <SPAN
CLASS="QUOTE"
>"root"</SPAN
>:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>cathy ~&#62;</TT
> <B
CLASS="command"
>grep <TT
CLASS="parameter"
><I
>^root</I
></TT
> <TT
CLASS="filename"
>/etc/passwd</TT
></B
>
root:x:0:0:root:/root:/bin/bash
</PRE
></FONT
></TD
></TR
></TABLE
><P
>If we want to see which accounts have no shell assigned whatsoever, we search for lines ending in <SPAN
CLASS="QUOTE"
>":"</SPAN
>:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>cathy ~&#62;</TT
> <B
CLASS="command"
>grep <TT
CLASS="parameter"
><I
>:$</I
></TT
> <TT
CLASS="filename"
>/etc/passwd</TT
></B
>
news:x:9:13:news:/var/spool/news:
</PRE
></FONT
></TD
></TR
></TABLE
><P
>To check that <TT
CLASS="varname"
>PATH</TT
> is exported in <TT
CLASS="filename"
>~/.bashrc</TT
>, first select <SPAN
CLASS="QUOTE"
>"export"</SPAN
> lines and then search for lines starting with the string <SPAN
CLASS="QUOTE"
>"PATH"</SPAN
>, so as not to display <TT
CLASS="varname"
>MANPATH</TT
> and other possible paths:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>cathy ~&#62;</TT
> <B
CLASS="command"
>grep <TT
CLASS="parameter"
><I
>export</I
></TT
> <TT
CLASS="filename"
>~/.bashrc</TT
></B
> | <B
CLASS="command"
>grep <TT
CLASS="parameter"
><I
>'\&#60;PATH'</I
></TT
></B
>
  export PATH="/bin:/usr/lib/mh:/lib:/usr/bin:/usr/local/bin:/usr/ucb:/usr/dbin:$PATH"
</PRE
></FONT
></TD
></TR
></TABLE
><P
>Similarly, <EM
>\&#62;</EM
> matches the end of a word.</P
><P
>If you want to find a string that is a separate word (enclosed by spaces), it is better use the <TT
CLASS="option"
>-w</TT
>, as in this example where we are displaying information for the root partition:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>cathy ~&#62;</TT
> <B
CLASS="command"
>grep <TT
CLASS="option"
>-w</TT
> <TT
CLASS="parameter"
><I
>/</I
></TT
> <TT
CLASS="filename"
>/etc/fstab</TT
></B
>
LABEL=/                 /                       ext3    defaults        1 1
</PRE
></FONT
></TD
></TR
></TABLE
><P
>If this option is not used, all the lines from the file system table will be displayed.</P
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="sect_04_02_02_02"
></A
>4.2.2.2. Character classes</H3
><P
>A <EM
>bracket expression</EM
> is a list of characters enclosed by <SPAN
CLASS="QUOTE"
>"["</SPAN
> and <SPAN
CLASS="QUOTE"
>"]"</SPAN
>.  It matches any single character in that list; if the first character of the list is the caret, <SPAN
CLASS="QUOTE"
>"^"</SPAN
>, then it matches any character NOT in the list.  For example, the regular expression <SPAN
CLASS="QUOTE"
>"[0123456789]"</SPAN
> matches any single digit.</P
><P
>Within a bracket expression, a <EM
>range expression</EM
> consists of two characters separated by a hyphen.  It matches any single character that sorts between the two characters, inclusive, using the locale's collating sequence and character set.  For example, in the default C locale, <SPAN
CLASS="QUOTE"
>"[a-d]"</SPAN
> is equivalent to <SPAN
CLASS="QUOTE"
>"[abcd]"</SPAN
>.  Many locales sort characters in dictionary order, and in these locales <SPAN
CLASS="QUOTE"
>"[a-d]"</SPAN
> is typically not equivalent to <SPAN
CLASS="QUOTE"
>"[abcd]"</SPAN
>; it might be equivalent to <SPAN
CLASS="QUOTE"
>"[aBbCcDd]"</SPAN
>, for example.  To obtain the traditional interpretation of bracket expressions, you can use the C locale by setting the <TT
CLASS="varname"
>LC_ALL</TT
> environment variable to the value <SPAN
CLASS="QUOTE"
>"C"</SPAN
>.</P
><P
>Finally, certain named classes of characters are predefined within bracket expressions.  See the <B
CLASS="command"
>grep</B
> man or info pages for more information about these predefined expressions.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>cathy ~&#62;</TT
> <B
CLASS="command"
>grep <TT
CLASS="parameter"
><I
>[yf]</I
></TT
> <TT
CLASS="filename"
>/etc/group</TT
></B
>
sys:x:3:root,bin,adm
tty:x:5:
mail:x:12:mail,postfix
ftp:x:50:
nobody:x:99:
floppy:x:19:
xfs:x:43:
nfsnobody:x:65534:
postfix:x:89:
</PRE
></FONT
></TD
></TR
></TABLE
><P
>In the example, all the lines containing either a <SPAN
CLASS="QUOTE"
>"y"</SPAN
> or <SPAN
CLASS="QUOTE"
>"f"</SPAN
> character are displayed.</P
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="sect_04_02_02_04"
></A
>4.2.2.3. Wildcards</H3
><P
>Use the <SPAN
CLASS="QUOTE"
>"."</SPAN
> for a single character match.  If you want to get a list of all five-character English dictionary words starting with <SPAN
CLASS="QUOTE"
>"c"</SPAN
> and ending in <SPAN
CLASS="QUOTE"
>"h"</SPAN
> (handy for solving crosswords):</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>cathy ~&#62;</TT
> <B
CLASS="command"
>grep <TT
CLASS="parameter"
><I
>'\&#60;c...h\&#62;'</I
></TT
> <TT
CLASS="filename"
>/usr/share/dict/words</TT
></B
>
catch
clash
cloth
coach
couch
cough
crash
crush
</PRE
></FONT
></TD
></TR
></TABLE
><P
>If you want to display lines containing the literal dot character, use the <TT
CLASS="option"
>-F</TT
> option to <B
CLASS="command"
>grep</B
>.</P
><P
>For matching multiple characters, use the asterisk.  This example selects all words starting with <SPAN
CLASS="QUOTE"
>"c"</SPAN
> and ending in <SPAN
CLASS="QUOTE"
>"h"</SPAN
> from the system's dictionary:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>cathy ~&#62;</TT
> <B
CLASS="command"
>grep <TT
CLASS="parameter"
><I
>'\&#60;c.*h\&#62;'</I
></TT
> <TT
CLASS="filename"
>/usr/share/dict/words</TT
></B
>
caliph
cash
catch
cheesecloth
cheetah
--output omitted--
</PRE
></FONT
></TD
></TR
></TABLE
><P
>If you want to find the literal asterisk character in a file or output, use single quotes.  Cathy in the example below first tries finding the asterisk character in <TT
CLASS="filename"
>/etc/profile</TT
> without using quotes, which does not return any lines.  Using quotes, output is generated:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>cathy ~&#62;</TT
> <B
CLASS="command"
>grep <TT
CLASS="parameter"
><I
>*</I
></TT
> <TT
CLASS="filename"
>/etc/profile</TT
></B
>

<TT
CLASS="prompt"
>cathy ~&#62;</TT
> <B
CLASS="command"
>grep <TT
CLASS="parameter"
><I
>'*'</I
></TT
> <TT
CLASS="filename"
>/etc/profile</TT
></B
>
for i in /etc/profile.d/*.sh ; do
</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="sect_04_03"
></A
>4.3. Pattern matching using Bash features</H1
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="sect_04_03_01"
></A
>4.3.1. Character ranges</H2
><P
>Apart from <B
CLASS="command"
>grep</B
> and regular expressions, there's a good deal of pattern matching that you can do directly in the shell, without having to use an external program.</P
><P
>As you already know, the asterisk (*) and the question mark (?) match any string or any single character, respectively.  Quote these special characters to match them literally:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>cathy ~&#62;</TT
> <B
CLASS="command"
>touch <TT
CLASS="filename"
>"*"</TT
></B
>

<TT
CLASS="prompt"
>cathy ~&#62;</TT
> <B
CLASS="command"
>ls <TT
CLASS="filename"
>"*"</TT
></B
>
*
</PRE
></FONT
></TD
></TR
></TABLE
><P
>But you can also use the square braces to match any enclosed character or range of characters, if pairs of characters are separated by a hyphen.  An example:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>cathy ~&#62;</TT
> <B
CLASS="command"
>ls <TT
CLASS="option"
>-ld</TT
> <TT
CLASS="filename"
>[a-cx-z]*</TT
></B
>
drwxr-xr-x    2 cathy	 cathy		4096 Jul 20  2002 app-defaults/
drwxrwxr-x    4 cathy    cathy          4096 May 25  2002 arabic/
drwxrwxr-x    2 cathy    cathy          4096 Mar  4 18:30 bin/
drwxr-xr-x    7 cathy    cathy          4096 Sep  2  2001 crossover/
drwxrwxr-x    3 cathy    cathy          4096 Mar 22  2002 xml/
</PRE
></FONT
></TD
></TR
></TABLE
><P
>This lists all files in <EM
>cathy</EM
>'s home directory, starting with <SPAN
CLASS="QUOTE"
>"a"</SPAN
>, <SPAN
CLASS="QUOTE"
>"b"</SPAN
>, <SPAN
CLASS="QUOTE"
>"c"</SPAN
>, <SPAN
CLASS="QUOTE"
>"x"</SPAN
>, <SPAN
CLASS="QUOTE"
>"y"</SPAN
> or <SPAN
CLASS="QUOTE"
>"z"</SPAN
>.</P
><P
>If the first character within the braces is <SPAN
CLASS="QUOTE"
>"!"</SPAN
> or <SPAN
CLASS="QUOTE"
>"^"</SPAN
>, any character not enclosed will be matched.  To match the dash (<SPAN
CLASS="QUOTE"
>"-"</SPAN
>), include it as the first or last character in the set.  The sorting depends on the current locale and of the value of the <TT
CLASS="varname"
>LC_COLLATE</TT
> variable, if it is set.  Mind that other locales might interpret <SPAN
CLASS="QUOTE"
>"[a-cx-z]"</SPAN
> as <SPAN
CLASS="QUOTE"
>"[aBbCcXxYyZz]"</SPAN
> if sorting is done in dictionary order.  If you want to be sure to have the traditional interpretation of ranges, force this behavior by setting <TT
CLASS="varname"
>LC_COLLATE</TT
> or <TT
CLASS="varname"
>LC_ALL</TT
> to <SPAN
CLASS="QUOTE"
>"C"</SPAN
>.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_04_03_02"
></A
>4.3.2. Character classes</H2
><P
>Character classes can be specified within the square braces, using the syntax <B
CLASS="command"
>[:CLASS:]</B
>, where CLASS is defined in the POSIX standard and has one of the values</P
><P
><SPAN
CLASS="QUOTE"
>"alnum"</SPAN
>, <SPAN
CLASS="QUOTE"
>"alpha"</SPAN
>, <SPAN
CLASS="QUOTE"
>"ascii"</SPAN
>, <SPAN
CLASS="QUOTE"
>"blank"</SPAN
>, <SPAN
CLASS="QUOTE"
>"cntrl"</SPAN
>, <SPAN
CLASS="QUOTE"
>"digit"</SPAN
>, <SPAN
CLASS="QUOTE"
>"graph"</SPAN
>, <SPAN
CLASS="QUOTE"
>"lower"</SPAN
>, <SPAN
CLASS="QUOTE"
>"print"</SPAN
>, <SPAN
CLASS="QUOTE"
>"punct"</SPAN
>, <SPAN
CLASS="QUOTE"
>"space"</SPAN
>, <SPAN
CLASS="QUOTE"
>"upper"</SPAN
>, <SPAN
CLASS="QUOTE"
>"word"</SPAN
> or <SPAN
CLASS="QUOTE"
>"xdigit"</SPAN
>.</P
><P
>Some examples:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>cathy ~&#62;</TT
> <B
CLASS="command"
>ls <TT
CLASS="option"
>-ld</TT
> <TT
CLASS="filename"
>[[:digit:]]*</TT
></B
>
drwxrwxr-x    2 cathy	cathy		4096 Apr 20 13:45 2/

<TT
CLASS="prompt"
>cathy ~&#62;</TT
> <B
CLASS="command"
>ls <TT
CLASS="option"
>-ld</TT
> <TT
CLASS="filename"
>[[:upper:]]*</TT
></B
>
drwxrwxr--    3 cathy   cathy           4096 Sep 30  2001 Nautilus/
drwxrwxr-x    4 cathy   cathy           4096 Jul 11  2002 OpenOffice.org1.0/
-rw-rw-r--    1 cathy   cathy         997376 Apr 18 15:39 Schedule.sdc
</PRE
></FONT
></TD
></TR
></TABLE
><P
>When the <TT
CLASS="option"
>extglob</TT
> shell option is enabled (using the <B
CLASS="command"
>shopt</B
> built-in), several extended pattern matching operators are recognized.  Read more in the Bash info pages, section <SPAN
CLASS="guimenu"
>Basic shell features</SPAN
>-&gt;<SPAN
CLASS="guisubmenu"
>Shell Expansions</SPAN
>-&gt;<SPAN
CLASS="guisubmenu"
>Filename Expansion</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Pattern Matching</SPAN
>.</P
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="sect_04_04"
></A
>4.4. Summary</H1
><P
>Regular expressions are powerful tools for selecting particular lines from files or output.  A lot of UNIX commands use regular expressions: <B
CLASS="command"
>vim</B
>, <B
CLASS="command"
>perl</B
>, the <SPAN
CLASS="application"
>PostgreSQL</SPAN
> database and so on.  They can be made available in any language or application using external libraries, and they even found their way to non-UNIX systems.  For instance, regular expressions are used in the Excell spreadsheet that comes with the MicroSoft Windows Office suite.  In this chapter we got the feel of the <B
CLASS="command"
>grep</B
> command, which is indispensable in any UNIX environment.</P
><DIV
CLASS="note"
><P
></P
><TABLE
CLASS="note"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The <B
CLASS="command"
>grep</B
> command can do much more than the few tasks we discussed here; we only used it as an example for regular expressions.  The GNU <B
CLASS="command"
>grep</B
> version comes with plenty of documentation, which you are strongly advised to read!</P
></TD
></TR
></TABLE
></DIV
><P
>Bash has built-in features for matching patterns and can recognize character classes and ranges.</P
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="sect_04_05"
></A
>4.5. Exercises</H1
><P
>These exercises will help you master regular expressions.</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Display a list of all the users on your system who log in with the Bash shell as a default.</P
></LI
><LI
><P
>From the <TT
CLASS="filename"
>/etc/group</TT
> directory, display all lines starting with the string <SPAN
CLASS="QUOTE"
>"daemon"</SPAN
>.</P
></LI
><LI
><P
>Print all the lines from the same file that don't contain the string.</P
></LI
><LI
><P
>Display localhost information from the <TT
CLASS="filename"
>/etc/hosts</TT
> file, display the line number(s) matching the search string and count the number of occurrences of the string.</P
></LI
><LI
><P
>Display a list of <TT
CLASS="filename"
>/usr/share/doc</TT
> subdirectories containing information about shells.</P
></LI
><LI
><P
>How many <TT
CLASS="filename"
>README</TT
> files do these subdirectories contain?  Don't count anything in the form of <SPAN
CLASS="QUOTE"
>"README.a_string"</SPAN
>.</P
></LI
><LI
><P
>Make a list of files in your home directory that were changed less that 10 hours ago, using <B
CLASS="command"
>grep</B
>, but leave out directories.</P
></LI
><LI
><P
>Put these commands in a shell script that will generate comprehensible output.</P
></LI
><LI
><P
>Can you find an alternative for <B
CLASS="command"
>wc <TT
CLASS="option"
>-l</TT
></B
>, using <B
CLASS="command"
>grep</B
>?</P
></LI
><LI
><P
>Using the file system table (<TT
CLASS="filename"
>/etc/fstab</TT
> for instance), list local disk devices.</P
></LI
><LI
><P
>Make a script that checks whether a user exists in <TT
CLASS="filename"
>/etc/passwd</TT
>.  For now, you can specify the user name in the script, you don't have to work with arguments and conditionals at this stage.</P
></LI
><LI
><P
>Display configuration files in <TT
CLASS="filename"
>/etc</TT
> that contain numbers in their names.</P
></LI
></OL
></DIV
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="chap_05"
></A
>Chapter 5. The GNU sed stream editor</H1
><BLOCKQUOTE
CLASS="ABSTRACT"
><DIV
CLASS="abstract"
><A
NAME="AEN3619"
></A
><P
></P
><P
>At the end of this chapter you will know about the following topics:</P
><P
><P
></P
><UL
><LI
><P
>What is <B
CLASS="command"
>sed</B
>?</P
></LI
><LI
><P
>Interactive use of <B
CLASS="command"
>sed</B
></P
></LI
><LI
><P
>Regular expressions and stream editing</P
></LI
><LI
><P
>Using <B
CLASS="command"
>sed</B
> commands in scripts</P
></LI
></UL
></P
><P
>&#13;<DIV
CLASS="note"
><P
></P
><TABLE
CLASS="note"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>This is an introduction</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>These explanations are far from complete and certainly not meant to be used as the definite user manual for <B
CLASS="command"
>sed</B
>.  This chapter is only included in order to show some more interesting topics in the next chapters, and because every power user should have a basic knowledge of things that can be done with this editor.</P
><P
>For detailed information, refer to the <B
CLASS="command"
>sed</B
> info and man pages.</P
></TD
></TR
></TABLE
></DIV
>
</P
><P
></P
></DIV
></BLOCKQUOTE
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="sect_05_01"
></A
>5.1. Introduction</H1
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="sect_05_01_01"
></A
>5.1.1. What is sed?</H2
><P
>A <SPAN
CLASS="application"
>Stream EDitor</SPAN
> is used to perform basic transformations on text read from a file or a pipe.  The result is sent to standard output.  The syntax for the <B
CLASS="command"
>sed</B
> command has no output file specification, but results can be saved to a file using output redirection.  The editor does not modify the original input.</P
><P
>What distinguishes <B
CLASS="command"
>sed</B
> from other editors, such as <B
CLASS="command"
>vi</B
> and <B
CLASS="command"
>ed</B
>, is its ability to filter text that it gets from a pipeline feed.  You do not need to interact with the editor while it is running; that is why <B
CLASS="command"
>sed</B
> is sometimes called a <EM
>batch editor</EM
>.  This feature allows use of editing commands in scripts, greatly easing repetitive editing tasks.  When facing replacement of text in a large number of files, <B
CLASS="command"
>sed</B
> is a great help.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_05_01_02"
></A
>5.1.2. sed commands</H2
><P
>The <B
CLASS="command"
>sed</B
> program can perform text pattern substitutions and deletions using regular expressions, like the ones used with the <B
CLASS="command"
>grep</B
> command; see <A
HREF="#sect_04_02"
>Section 4.2</A
>.</P
><P
>The editing commands are similar to the ones used in the <B
CLASS="command"
>vi</B
> editor:</P
><DIV
CLASS="table"
><A
NAME="tab_05_01"
></A
><P
><B
>Table 5-1. Sed editing commands</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
>Command</TH
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
>Result</TH
></TR
></THEAD
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>a\</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Append text below current line.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>c\</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Change text in the current line with new text.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>d</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Delete text.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>i\</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Insert text above current line.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>p</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Print text.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>r</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Read a file.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>s</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Search and replace text.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>w</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Write to a file.</TD
></TR
></TBODY
></TABLE
></DIV
><P
>Apart from editing commands, you can give options to <B
CLASS="command"
>sed</B
>.  An overview is in the table below:</P
><DIV
CLASS="table"
><A
NAME="tab_05_02"
></A
><P
><B
>Table 5-2. Sed options</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
>Option</TH
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
>Effect</TH
></TR
></THEAD
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><TT
CLASS="option"
>-e SCRIPT</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Add the commands in SCRIPT to the set of commands to be run while processing the input.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><TT
CLASS="option"
>-f</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Add the commands contained in the file SCRIPT-FILE to the set of commands to be run while processing the input.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><TT
CLASS="option"
>-n</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Silent mode.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><TT
CLASS="option"
>-V</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Print version information and exit.</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The <B
CLASS="command"
>sed</B
> info pages contain more information; we only list the most frequently used commands and options here.</P
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="sect_05_02"
></A
>5.2. Interactive editing</H1
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="sect_05_02_01"
></A
>5.2.1. Printing lines containing a pattern</H2
><P
>This is something you can do with <B
CLASS="command"
>grep</B
>, of course, but you can't do a <SPAN
CLASS="QUOTE"
>"find and replace"</SPAN
> using that command.  This is just to get you started.</P
><P
>This is our example text file:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>sandy ~&#62;</TT
> <B
CLASS="command"
>cat <TT
CLASS="option"
>-n</TT
> <TT
CLASS="filename"
>example</TT
></B
>
     1  This is the first line of an example text.
     2  It is a text with erors.
     3  Lots of erors.
     4  So much erors, all these erors are making me sick.
     5  This is a line not containing any errors.
     6  This is the last line.

<TT
CLASS="prompt"
>sandy ~&#62;</TT
>
</PRE
></FONT
></TD
></TR
></TABLE
><P
>We want <B
CLASS="command"
>sed</B
> to find all the lines containing our search pattern, in this case <SPAN
CLASS="QUOTE"
>"erors"</SPAN
>.  We use the <B
CLASS="command"
>p</B
> to obtain the result:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>sandy ~&#62;</TT
> <B
CLASS="command"
>sed  <TT
CLASS="parameter"
><I
>'/erors/p'</I
></TT
> <TT
CLASS="filename"
>example</TT
></B
>
This is the first line of an example text.
It is a text with erors.
It is a text with erors.
Lots of erors.
Lots of erors.
So much erors, all these erors are making me sick.
So much erors, all these erors are making me sick.
This is a line not containing any errors.
This is the last line.

<TT
CLASS="prompt"
>sandy ~&#62;</TT
>
</PRE
></FONT
></TD
></TR
></TABLE
><P
>As you notice, <B
CLASS="command"
>sed</B
> prints the entire file, but the lines containing the search string are printed twice.  This is not what we want.  In order to only print those lines matching our pattern, use the <TT
CLASS="option"
>-n</TT
> option:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>sandy ~&#62;</TT
> <B
CLASS="command"
>sed <TT
CLASS="option"
>-n</TT
> <TT
CLASS="parameter"
><I
>'/erors/p'</I
></TT
> <TT
CLASS="filename"
>example</TT
></B
>
It is a text with erors.
Lots of erors.
So much erors, all these erors are making me sick.

<TT
CLASS="prompt"
>sandy ~&#62;</TT
>
</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_05_02_02"
></A
>5.2.2. Deleting lines of input containing a pattern</H2
><P
>We use the same example text file.  Now we only want to see the lines <EM
>not</EM
> containing the search string:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>sandy ~&#62;</TT
> <B
CLASS="command"
>sed <TT
CLASS="parameter"
><I
>'/erors/d'</I
></TT
> <TT
CLASS="filename"
>example</TT
></B
>
This is the first line of an example text.
This is a line not containing any errors.
This is the last line.

<TT
CLASS="prompt"
>sandy ~&#62;</TT
>
</PRE
></FONT
></TD
></TR
></TABLE
><P
>The <B
CLASS="command"
>d</B
> command results in excluding lines from being displayed.</P
><P
>Matching lines starting with a given pattern and ending in a second pattern are showed like this:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>sandy ~&#62;</TT
> <B
CLASS="command"
>sed <TT
CLASS="option"
>-n</TT
> <TT
CLASS="parameter"
><I
>'/^This.*errors.$/p'</I
></TT
> <TT
CLASS="filename"
>example</TT
></B
>
This is a line not containing any errors.

<TT
CLASS="prompt"
>sandy ~&#62;</TT
>
</PRE
></FONT
></TD
></TR
></TABLE
><P
>Note that the last dot needs to be escaped in order to actually match.  In our example the expression just matches any character, including the last dot.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_05_02_03"
></A
>5.2.3. Ranges of lines</H2
><P
>This time we want to take out the lines containing the errors.  In the example these are lines 2 to 4.  Specify this range to address, together with the <B
CLASS="command"
>d</B
> command:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>sandy ~&#62;</TT
> <B
CLASS="command"
>sed <TT
CLASS="parameter"
><I
>'2,4d'</I
></TT
> <TT
CLASS="filename"
>example</TT
></B
>
This is the first line of an example text.
This is a line not containing any errors.
This is the last line.

<TT
CLASS="prompt"
>sandy ~&#62;</TT
>
</PRE
></FONT
></TD
></TR
></TABLE
><P
>To print the file starting from a certain line until the end of the file, use a command similar to this:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>sandy ~&#62;</TT
> <B
CLASS="command"
>sed <TT
CLASS="parameter"
><I
>'3,$d'</I
></TT
> <TT
CLASS="filename"
>example</TT
></B
>
This is the first line of an example text.
It is a text with erors.

<TT
CLASS="prompt"
>sandy ~&#62;</TT
>
</PRE
></FONT
></TD
></TR
></TABLE
><P
>This only prints the first two lines of the example file.</P
><P
>The following command prints the first line containing the pattern <SPAN
CLASS="QUOTE"
>"a text"</SPAN
>, up to and including the next line containing the pattern <SPAN
CLASS="QUOTE"
>"a line"</SPAN
>:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>sandy ~&#62;</TT
> <B
CLASS="command"
>sed <TT
CLASS="option"
>-n</TT
> <TT
CLASS="parameter"
><I
>'/a text/,/This/p'</I
></TT
> <TT
CLASS="filename"
>example</TT
></B
>
It is a text with erors.
Lots of erors.
So much erors, all these erors are making me sick.
This is a line not containing any errors.

<TT
CLASS="prompt"
>sandy ~&#62;</TT
>
</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_05_02_04"
></A
>5.2.4. Find and replace with sed</H2
><P
>In the example file, we will now search and replace the errors instead of only (de)selecting the lines containing the search string.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>sandy ~&#62;</TT
> <B
CLASS="command"
>sed <TT
CLASS="parameter"
><I
>'s/erors/errors/'</I
></TT
> <TT
CLASS="filename"
>example</TT
></B
>
This is the first line of an example text.
It is a text with errors.
Lots of errors.
So much errors, all these erors are making me sick.
This is a line not containing any errors.
This is the last line.

<TT
CLASS="prompt"
>sandy ~&#62;</TT
>
</PRE
></FONT
></TD
></TR
></TABLE
><P
>As you can see, this is not exactly the desired effect: in line 4, only the first occurrence of the search string has been replaced, and there is still an 'eror' left.  Use the <B
CLASS="command"
>g</B
> command to indicate to <B
CLASS="command"
>sed</B
> that it should examine the entire line instead of stopping at the first occurrence of your string:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>sandy ~&#62;</TT
> <B
CLASS="command"
>sed <TT
CLASS="parameter"
><I
>'s/erors/errors/g'</I
></TT
> <TT
CLASS="filename"
>example</TT
></B
>
This is the first line of an example text.
It is a text with errors.
Lots of errors.
So much errors, all these errors are making me sick.
This is a line not containing any errors.
This is the last line.

<TT
CLASS="prompt"
>sandy ~&#62;</TT
>
</PRE
></FONT
></TD
></TR
></TABLE
><P
>To insert a string at the beginning of each line of a file, for instance for quoting:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>sandy ~&#62;</TT
> <B
CLASS="command"
>sed <TT
CLASS="parameter"
><I
>'s/^/&#62; /'</I
></TT
> <TT
CLASS="filename"
>example</TT
></B
>
&#62; This is the first line of an example text.
&#62; It is a text with erors.
&#62; Lots of erors.
&#62; So much erors, all these erors are making me sick.
&#62; This is a line not containing any errors.
&#62; This is the last line.

<TT
CLASS="prompt"
>sandy ~&#62;</TT
>
</PRE
></FONT
></TD
></TR
></TABLE
><P
>Insert some string at the end of each line:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>sandy ~&#62;</TT
> <B
CLASS="command"
>sed <TT
CLASS="parameter"
><I
>'s/$/EOL/'</I
></TT
> <TT
CLASS="filename"
>example</TT
></B
>
This is the first line of an example text.EOL
It is a text with erors.EOL
Lots of erors.EOL
So much erors, all these erors are making me sick.EOL
This is a line not containing any errors.EOL
This is the last line.EOL

<TT
CLASS="prompt"
>sandy ~&#62;</TT
>
</PRE
></FONT
></TD
></TR
></TABLE
><P
>Multiple find and replace commands are separated with individual <TT
CLASS="option"
>-e</TT
> options:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>sandy ~&#62;</TT
> <B
CLASS="command"
>sed <TT
CLASS="option"
>-e</TT
> <TT
CLASS="parameter"
><I
>'s/erors/errors/g'</I
></TT
> <TT
CLASS="option"
>-e</TT
> <TT
CLASS="parameter"
><I
>'s/last/final/g'</I
></TT
> <TT
CLASS="filename"
>example</TT
></B
>
This is the first line of an example text.
It is a text with errors.
Lots of errors.
So much errors, all these errors are making me sick.
This is a line not containing any errors.
This is the final line.

<TT
CLASS="prompt"
>sandy ~&#62;</TT
>
</PRE
></FONT
></TD
></TR
></TABLE
><P
>Keep in mind that by default <B
CLASS="command"
>sed</B
> prints its results to the standard output, most likely your terminal window.  If you want to save the output to a file, redirect it:</P
><P
><B
CLASS="command"
>sed <TT
CLASS="option"
>option</TT
> <TT
CLASS="function"
>'some/expression'</TT
> <TT
CLASS="filename"
>file_to_process</TT
> &#62; <TT
CLASS="filename"
>sed_output_in_a_file</TT
></B
> </P
><DIV
CLASS="tip"
><P
></P
><TABLE
CLASS="tip"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="images/tip.gif"
HSPACE="5"
ALT="Tip"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>More examples</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Plenty of <B
CLASS="command"
>sed</B
> examples can be found in the startup scripts for your machine, which are usually in <TT
CLASS="filename"
>/etc/init.d</TT
> or <TT
CLASS="filename"
>/etc/rc.d/init.d</TT
>.  Change into the directory containing the initscripts on your system and issue the following command:</P
><P
><B
CLASS="command"
>grep <TT
CLASS="parameter"
><I
>sed</I
></TT
> <TT
CLASS="filename"
>*</TT
></B
> </P
></TD
></TR
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="sect_05_03"
></A
>5.3. Non-interactive editing</H1
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="sect_05_03_01"
></A
>5.3.1. Reading sed commands from a file</H2
><P
>Multiple <B
CLASS="command"
>sed</B
> commands can be put in a file and executed using the <TT
CLASS="option"
>-f</TT
> option.  When creating such a file, make sure that:</P
><P
></P
><UL
><LI
><P
>No trailing white spaces exist at the end of lines.</P
></LI
><LI
><P
>No quotes are used.</P
></LI
><LI
><P
>When entering text to add or replace, all except the last line end in a backslash.</P
></LI
></UL
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_05_03_02"
></A
>5.3.2. Writing output files</H2
><P
>Writing output is done using the output redirection operator <B
CLASS="command"
>&#62;</B
>.  This is an example script used to create very simple HTML files from plain text files.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>sandy ~&#62;</TT
> <B
CLASS="command"
>cat <TT
CLASS="filename"
>script.sed</TT
></B
>
1i\
&#60;html&#62;\
&#60;head&#62;&#60;title&#62;sed generated html&#60;/title&#62;&#60;/head&#62;\
&#60;body bgcolor="#ffffff"&#62;\
&#60;pre&#62;
$a\
&#60;/pre&#62;\
&#60;/body&#62;\
&#60;/html&#62;

<TT
CLASS="prompt"
>sandy ~&#62;</TT
> <B
CLASS="command"
>cat <TT
CLASS="filename"
>txt2html.sh</TT
></B
>
#!/bin/bash

# This is a simple script that you can use for converting text into HTML.
# First we take out all newline characters, so that the appending only happens
# once, then we replace the newlines.

echo "converting $1..."

SCRIPT="/home/sandy/scripts/script.sed"
NAME="$1"
TEMPFILE="/var/tmp/sed.$PID.tmp"
sed "s/\n/^M/" $1 | sed -f $SCRIPT | sed "s/^M/\n/" &#62; $TEMPFILE
mv $TEMPFILE $NAME

echo "done."

<TT
CLASS="prompt"
>sandy ~&#62;</TT
>
</PRE
></FONT
></TD
></TR
></TABLE
><P
><TT
CLASS="varname"
>$1</TT
> holds the first argument to a given command, in this case the name of the file to convert:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>sandy ~&#62;</TT
> <B
CLASS="command"
>cat <TT
CLASS="filename"
>test</TT
></B
>
line1
line2
line3
</PRE
></FONT
></TD
></TR
></TABLE
><P
>More on positional parameters in <A
HREF="#chap_07"
>Chapter 7</A
>.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>sandy ~&#62;</TT
> <B
CLASS="command"
>txt2html.sh <TT
CLASS="filename"
>test</TT
></B
>
converting test...
done.

<TT
CLASS="prompt"
>sandy ~&#62;</TT
> <B
CLASS="command"
>cat <TT
CLASS="filename"
>test</TT
></B
>
&#60;html&#62;
&#60;head&#62;&#60;title&#62;sed generated html&#60;/title&#62;&#60;/head&#62;
&#60;body bgcolor="#ffffff"&#62;
&#60;pre&#62;
line1
line2
line3
&#60;/pre&#62;
&#60;/body&#62;
&#60;/html&#62;

<TT
CLASS="prompt"
>sandy ~&#62;</TT
>
</PRE
></FONT
></TD
></TR
></TABLE
><P
>This is not really how it is done; this example just demonstrates <B
CLASS="command"
>sed</B
> capabilities.  See <A
HREF="#sect_06_03"
>Section 6.3</A
> for a more decent solution to this problem, using <B
CLASS="command"
>awk</B
> <EM
>BEGIN</EM
> and <EM
>END</EM
> constructs.</P
><DIV
CLASS="note"
><P
></P
><TABLE
CLASS="note"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>Easy sed</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Advanced editors, supporting syntax highlighting, can recognize <B
CLASS="command"
>sed</B
> syntax.  This can be a great help if you tend to forget backslashes and such.</P
></TD
></TR
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="sect_05_04"
></A
>5.4. Summary</H1
><P
>The <B
CLASS="command"
>sed</B
> stream editor is a powerful command line tool, which can handle streams of data: it can take input lines from a pipe.  This makes it fit for non-interactive use.  The <B
CLASS="command"
>sed</B
> editor uses <B
CLASS="command"
>vi</B
>-like commands and accepts regular expressions.</P
><P
>The <B
CLASS="command"
>sed</B
> tool can read commands from the command line or from a script.  It is often used to perform find-and-replace actions on lines containing a pattern.</P
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="sect_05_05"
></A
>5.5. Exercises</H1
><P
>These exercises are meant to further demonstrate what <B
CLASS="command"
>sed</B
> can do.</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Print a list of files in your <TT
CLASS="filename"
>scripts</TT
> directory, ending in <SPAN
CLASS="QUOTE"
>".sh"</SPAN
>.  Mind that you might have to unalias <B
CLASS="command"
>ls</B
>.  Put the result in a temporary file.</P
></LI
><LI
><P
>Make a list of files in <TT
CLASS="filename"
>/usr/bin</TT
> that have the letter <SPAN
CLASS="QUOTE"
>"a"</SPAN
> as the second character.  Put the result in a temporary file.</P
></LI
><LI
><P
>Delete the first 3 lines of each temporary file.</P
></LI
><LI
><P
>Print to standard output only the lines containing the pattern <SPAN
CLASS="QUOTE"
>"an"</SPAN
>.</P
></LI
><LI
><P
>Create a file holding <B
CLASS="command"
>sed</B
> commands to perform the previous two tasks.  Add an extra command to this file that adds a string like <SPAN
CLASS="QUOTE"
>"*** This might have something to do with man and man pages ***"</SPAN
> in the line preceding every occurence of the string <SPAN
CLASS="QUOTE"
>"man"</SPAN
>.  Check the results.</P
></LI
><LI
><P
>A long listing of the root directory, <TT
CLASS="filename"
>/</TT
>, is used for input.  Create a file holding <B
CLASS="command"
>sed</B
> commands that check for symbolic links and plain files.  If a file is a symbolic link, precede it with a line like <SPAN
CLASS="QUOTE"
>"--This is a symlink--"</SPAN
>.  If the file is a plain file, add a string on the same line, adding a comment like <SPAN
CLASS="QUOTE"
>"&#60;--- this is a plain file"</SPAN
>.</P
></LI
><LI
><P
>Create a script that shows lines containing trailing white spaces from a file.  This script should use a <B
CLASS="command"
>sed</B
> script and show sensible information to the user.</P
></LI
></OL
></DIV
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="chap_06"
></A
>Chapter 6. The GNU awk programming language</H1
><BLOCKQUOTE
CLASS="ABSTRACT"
><DIV
CLASS="abstract"
><A
NAME="AEN3998"
></A
><P
></P
><P
>In this chapter we will discuss:</P
><P
><P
></P
><UL
><LI
><P
>What is <SPAN
CLASS="application"
>gawk</SPAN
>?</P
></LI
><LI
><P
>Using <SPAN
CLASS="application"
>gawk</SPAN
> commands on the command line</P
></LI
><LI
><P
>How to format text with <SPAN
CLASS="application"
>gawk</SPAN
></P
></LI
><LI
><P
>How <SPAN
CLASS="application"
>gawk</SPAN
> uses regular expressions</P
></LI
><LI
><P
><SPAN
CLASS="application"
>Gawk</SPAN
> in scripts</P
></LI
><LI
><P
><SPAN
CLASS="application"
>Gawk</SPAN
> and variables</P
></LI
></UL
></P
><P
><DIV
CLASS="note"
><P
></P
><TABLE
CLASS="note"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>To make it more fun</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>As with <B
CLASS="command"
>sed</B
>, entire books have been written about various versions of <B
CLASS="command"
>awk</B
>.  This introduction is far from complete and is only intended for understanding examples in the following chapters.  For more information, best start with the documentation that comes with <SPAN
CLASS="application"
>GNU awk</SPAN
>: <SPAN
CLASS="QUOTE"
>"GAWK: Effective AWK Programming: A User's Guide for GNU Awk"</SPAN
>.</P
></TD
></TR
></TABLE
></DIV
></P
><P
></P
></DIV
></BLOCKQUOTE
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="sect_06_01"
></A
>6.1. Getting started with gawk</H1
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="sect_06_01_01"
></A
>6.1.1. What is gawk?</H2
><P
><SPAN
CLASS="application"
>Gawk</SPAN
> is the GNU version of the commonly available UNIX <B
CLASS="command"
>awk</B
> program, another popular stream editor.  Since the <B
CLASS="command"
>awk</B
> program is often just a link to <B
CLASS="command"
>gawk</B
>, we will refer to it as <B
CLASS="command"
>awk</B
>.</P
><P
>The basic function of <B
CLASS="command"
>awk</B
> is to search files for lines or other text units containing one or more patterns.  When a line matches one of the patterns, special actions are performed on that line.</P
><P
>Programs in <B
CLASS="command"
>awk</B
> are different from programs in most other languages, because <B
CLASS="command"
>awk</B
> programs are <SPAN
CLASS="QUOTE"
>"data-driven"</SPAN
>: you describe the data you want to work with and then what to do when you
find it.  Most other languages are <SPAN
CLASS="QUOTE"
>"procedural."</SPAN
>  You have to describe, in great detail, every step the program is to take.  When working with procedural languages, it is usually much harder to clearly describe the data your program will process.  For this reason, <B
CLASS="command"
>awk</B
> programs are often refreshingly easy to read and write.</P
><DIV
CLASS="note"
><P
></P
><TABLE
CLASS="note"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>What does it really mean?</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Back in the 1970s, three programmers got together to create this language.  Their names were Aho, Kernighan and Weinberger.  They took the first character of each of their names and put them together.  So the name of the language might just as well have been <SPAN
CLASS="QUOTE"
>"wak"</SPAN
>.</P
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_06_01_02"
></A
>6.1.2. Gawk commands</H2
><P
>When you run <B
CLASS="command"
>awk</B
>, you specify an <B
CLASS="command"
>awk</B
> <EM
>program</EM
> that tells <B
CLASS="command"
>awk</B
> what to do.  The program consists of a series of <EM
>rules</EM
>.  (It may also
contain function definitions, loops, conditions and other programming constructs, advanced features that we will ignore for now.)  Each rule specifies one pattern to search for and one action to perform upon finding the pattern.</P
><P
>There are several ways to run <B
CLASS="command"
>awk</B
>.  If the program is short, it is easiest to run it on the command line:</P
><P
><B
CLASS="command"
>awk PROGRAM <TT
CLASS="filename"
>inputfile(s)</TT
></B
> </P
><P
>If multiple changes have to be made, possibly regularly and on multiple files, it is easier to put the <B
CLASS="command"
>awk</B
> commands in a script.  This is read like this:</P
><P
><B
CLASS="command"
>awk <TT
CLASS="option"
>-f</TT
> <TT
CLASS="filename"
>PROGRAM-FILE</TT
> <TT
CLASS="filename"
>inputfile(s)</TT
></B
> </P
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="sect_06_02"
></A
>6.2. The print program</H1
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="sect_06_02_01"
></A
>6.2.1. Printing selected fields</H2
><P
>The <B
CLASS="command"
>print</B
> command in <B
CLASS="command"
>awk</B
> outputs selected data from the input file.</P
><P
>When <B
CLASS="command"
>awk</B
> reads a line of a file, it divides the line in fields based on the specified <EM
>input field separator</EM
>, <TT
CLASS="varname"
>FS</TT
>, which is an <B
CLASS="command"
>awk</B
> variable (see <A
HREF="#sect_06_03_02"
>Section 6.3.2</A
>).  This variable is predefined to be one or more spaces or tabs.</P
><P
>The variables <TT
CLASS="varname"
>$1</TT
>, <TT
CLASS="varname"
>$2</TT
>, <TT
CLASS="varname"
>$3</TT
>, ..., <TT
CLASS="varname"
>$N</TT
> hold the values of the first, second, third until the last field of an input line.  The variable <TT
CLASS="varname"
>$0</TT
> (zero) holds the value of the entire line.  This is depicted in the image below, where we see six colums in the output of the <B
CLASS="command"
>df</B
> command:</P
><DIV
CLASS="figure"
><A
NAME="AEN4111"
></A
><P
><B
>Figure 6-1. Fields in awk</B
></P
><DIV
CLASS="mediaobject"
><P
><IMG
SRC="images/awk.png"></P
></DIV
></DIV
><P
>In the output of <B
CLASS="command"
>ls <TT
CLASS="option"
>-l</TT
></B
>, there are 9 columns.  The <B
CLASS="command"
>print</B
> statement uses these fields as follows:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>kelly@octarine ~/test&#62;</TT
> <B
CLASS="command"
>ls <TT
CLASS="option"
>-l</TT
> | awk <TT
CLASS="parameter"
><I
>'{ print $5 $9 }'</I
></TT
></B
>
160orig
121script.sed
120temp_file
126test
120twolines
441txt2html.sh

<TT
CLASS="prompt"
>kelly@octarine ~/test&#62;</TT
>
</PRE
></FONT
></TD
></TR
></TABLE
><P
>This command printed the fifth column of a long file listing, which contains the file size, and the last column, the name of the file.  This output is not very readable unless you use the official way of referring to columns, which is to separate the ones that you want to print with a comma.  In that case, the default output separater character, usually a space, will be put in between each output field.</P
><DIV
CLASS="note"
><P
></P
><TABLE
CLASS="note"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>Local configuration</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Note that the configuration of the output of the <B
CLASS="command"
>ls <TT
CLASS="option"
>-l</TT
></B
> command might be different on your system.  Display of time and date is dependent on your locale setting.</P
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_06_02_02"
></A
>6.2.2. Formatting fields</H2
><P
>Without formatting, using only the output separator, the output looks rather poor.  Inserting a couple of tabs and a string to indicate what output this is will make it look a lot better:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>kelly@octarine ~/test&#62;</TT
> <B
CLASS="command"
>ls <TT
CLASS="option"
>-ldh</TT
> <TT
CLASS="filename"
>*</TT
> | grep <TT
CLASS="option"
>-v</TT
> <TT
CLASS="parameter"
><I
>total</I
></TT
> | \ 
awk <TT
CLASS="parameter"
><I
>'{ print "Size is " $5 " bytes for " $9 }'</I
></TT
></B
>
Size is 160 bytes for orig
Size is 121 bytes for script.sed
Size is 120 bytes for temp_file
Size is 126 bytes for test
Size is 120 bytes for twolines
Size is 441 bytes for txt2html.sh

<TT
CLASS="prompt"
>kelly@octarine ~/test&#62;</TT
>
</PRE
></FONT
></TD
></TR
></TABLE
><P
>Note the use of the backslash, which makes long input continue on the next line without the shell interpreting this as a separate command.  While your command line input can be of virtually unlimited length, your monitor is not, and printed paper certainly isn't.  Using the backslash also allows for copying and pasting of the above lines into a terminal window.</P
><P
>The <TT
CLASS="option"
>-h</TT
> option to <B
CLASS="command"
>ls</B
> is used for supplying humanly readable size formats for bigger files.  The output of a long listing displaying the total amount of blocks in the directory is given when a directory is the argument.  This line is useless to us, so we add an asterisk.  We also add the <TT
CLASS="option"
>-d</TT
> option for the same reason, in case asterisk expands to a directory.</P
><P
>The backslash in this example marks the continuation of a line. See <A
HREF="#sect_03_03_02"
>Section 3.3.2</A
>.</P
><P
>You can take out any number of columns and even reverse the order.  In the example below this is demonstrated for showing the most critical partitions:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>kelly@octarine ~&#62;</TT
> <B
CLASS="command"
>df <TT
CLASS="option"
>-h</TT
> | sort <TT
CLASS="option"
>-rnk</TT
> <TT
CLASS="parameter"
><I
>5</I
></TT
> | head <TT
CLASS="parameter"
><I
>-3</I
></TT
> | \ 
awk <TT
CLASS="parameter"
><I
>'{ print "Partition " $6 "\t: " $5 " full!" }'</I
></TT
></B
>
Partition /var  : 86% full!
Partition /usr  : 85% full!
Partition /home : 70% full!

<TT
CLASS="prompt"
>kelly@octarine ~&#62;</TT
>
</PRE
></FONT
></TD
></TR
></TABLE
><P
>The table below gives an overview of special formatting characters:</P
><DIV
CLASS="table"
><A
NAME="tab_06_01"
></A
><P
><B
>Table 6-1. Formatting characters for gawk</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
>Sequence</TH
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
>Meaning</TH
></TR
></THEAD
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>\a</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Bell character</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>\n</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Newline character</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>\t</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Tab</TD
></TR
></TBODY
></TABLE
></DIV
><P
>Quotes, dollar signs and other meta-characters should be escaped with a backslash.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_06_02_03"
></A
>6.2.3. The print command and regular expressions</H2
><P
>A regular expression can be used as a pattern by enclosing it in slashes.  The regular expression is then tested against the entire text of each record.  The syntax is as follows:</P
><P
><B
CLASS="command"
>awk 'EXPRESSION  { PROGRAM }' <TT
CLASS="filename"
>file(s)</TT
></B
> </P
><P
>The following example displays only local disk device information, networked file systems are not shown:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>kelly is in ~&#62;</TT
> <B
CLASS="command"
>df <TT
CLASS="option"
>-h</TT
> | awk <TT
CLASS="parameter"
><I
>'/dev\/hd/ { print $6 "\t: " $5 }'</I
></TT
></B
>
/       : 46%
/boot   : 10%
/opt    : 84%
/usr    : 97%
/var    : 73%
/.vol1  : 8%

<TT
CLASS="prompt"
>kelly is in ~&#62;</TT
>
</PRE
></FONT
></TD
></TR
></TABLE
><P
>Slashes need to be escaped, because they have a special meaning to the <B
CLASS="command"
>awk</B
> program.</P
><P
>Below another example where we search the <TT
CLASS="filename"
>/etc</TT
> directory for files ending in <SPAN
CLASS="QUOTE"
>".conf"</SPAN
> and starting with either <SPAN
CLASS="QUOTE"
>"a"</SPAN
> <EM
>or</EM
> <SPAN
CLASS="QUOTE"
>"x"</SPAN
>, using extended regular expressions:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>kelly is in /etc&#62;</TT
> <B
CLASS="command"
>ls <TT
CLASS="option"
>-l</TT
> | awk <TT
CLASS="parameter"
><I
>'/\&#60;(a|x).*\.conf$/ { print $9 }'</I
></TT
></B
>
amd.conf
antivir.conf
xcdroast.conf
xinetd.conf

<TT
CLASS="prompt"
>kelly is in /etc&#62;</TT
>
</PRE
></FONT
></TD
></TR
></TABLE
><P
>This example illustrates the special meaning of the dot in regular expressions: the first one indicates that we want to search for any character after the first search string, the second is escaped because it is part of a string to find (the end of the file name).</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_06_02_04"
></A
>6.2.4. Special patterns</H2
><P
>In order to precede output with comments, use the <B
CLASS="command"
>BEGIN</B
> statement:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>kelly is in /etc&#62;</TT
> <B
CLASS="command"
>ls <TT
CLASS="option"
>-l</TT
> | \
awk <TT
CLASS="parameter"
><I
>'BEGIN { print "Files found:\n" } /\&#60;[a|x].*\.conf$/ { print $9 }'</I
></TT
></B
>
Files found:
amd.conf
antivir.conf
xcdroast.conf
xinetd.conf

<TT
CLASS="prompt"
>kelly is in /etc&#62;</TT
>
</PRE
></FONT
></TD
></TR
></TABLE
><P
>The <B
CLASS="command"
>END</B
> statement can be added for inserting text after the entire input is processed:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>kelly is in /etc&#62;</TT
> <B
CLASS="command"
>ls <TT
CLASS="option"
>-l</TT
> | \
awk <TT
CLASS="parameter"
><I
>'/\&#60;[a|x].*\.conf$/ { print $9 } END { print \
"Can I do anything else for you, mistress?" }'</I
></TT
></B
>
amd.conf
antivir.conf
xcdroast.conf
xinetd.conf
Can I do anything else for you, mistress?

<TT
CLASS="prompt"
>kelly is in /etc&#62;</TT
>
</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_06_02_05"
></A
>6.2.5. Gawk scripts</H2
><P
>As commands tend to get a little longer, you might want to put them in a script, so they are reusable.  An <B
CLASS="command"
>awk</B
> script contains <B
CLASS="command"
>awk</B
> statements defining patterns and actions.</P
><P
>As an illustration, we will build a report that displays our most loaded partitions.  See <A
HREF="#sect_06_02_02"
>Section 6.2.2</A
>.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>kelly is in ~&#62;</TT
> <B
CLASS="command"
>cat <TT
CLASS="filename"
>diskrep.awk</TT
></B
>
BEGIN { print "*** WARNING WARNING WARNING ***" }
/\&#60;[8|9][0-9]%/ { print "Partition " $6 "\t: " $5 " full!" }
END { print "*** Give money for new disks URGENTLY! ***" }

kelly is in ~&#62; df -h | awk -f diskrep.awk
*** WARNING WARNING WARNING ***
Partition /usr  : 97% full!
*** Give money for new disks URGENTLY! ***

<TT
CLASS="prompt"
>kelly is in ~&#62;</TT
>
</PRE
></FONT
></TD
></TR
></TABLE
><P
><B
CLASS="command"
>awk</B
> first prints a begin message, then formats all the lines that contain an eight or a nine at the beginning of a word, followed by one other number and a percentage sign.  An end message is added.</P
><DIV
CLASS="note"
><P
></P
><TABLE
CLASS="note"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>Syntax highlighting</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Awk is a programming language.  Its syntax is recognized by most editors that can do syntax highlighting for other languages, such as C, Bash, HTML, etc.</P
></TD
></TR
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="sect_06_03"
></A
>6.3. Gawk variables</H1
><P
>As <B
CLASS="command"
>awk</B
> is processing the input file, it uses several variables.  Some are editable, some are read-only.</P
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_06_03_01"
></A
>6.3.1. The input field separator</H2
><P
>The <EM
>field separator</EM
>, which is either a single character or a regular expression, controls the way <B
CLASS="command"
>awk</B
> splits up an input record into fields.  The input record is scanned for character sequences that match the separator definition; the fields themselves are the text between the matches.</P
><P
>The field separator is represented by the built-in variable <TT
CLASS="varname"
>FS</TT
>.  Note that this is something different from the <TT
CLASS="varname"
>IFS</TT
> variable used by POSIX-compliant shells.</P
><P
>The value of the field separator variable can be changed in the <B
CLASS="command"
>awk</B
> program with the assignment operator <B
CLASS="command"
>=</B
>.  Often the right time to do this is at the beginning of execution before any input has been processed, so that the very first record is read with the proper separator.  To do this, use the special <B
CLASS="command"
>BEGIN</B
> pattern.</P
><P
>In the example below, we build a command that displays all the users on your system with a description:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>kelly is in ~&#62;</TT
> <B
CLASS="command"
>awk <TT
CLASS="parameter"
><I
>'BEGIN { FS=":" } { print $1 "\t" $5 }'</I
></TT
> <TT
CLASS="filename"
>/etc/passwd</TT
></B
>
--output omitted--
kelly	Kelly Smith
franky	Franky B.
eddy	Eddy White
willy	William Black
cathy	Catherine the Great
sandy	Sandy Li Wong

<TT
CLASS="prompt"
>kelly is in ~&#62;</TT
>
</PRE
></FONT
></TD
></TR
></TABLE
><P
>In an <B
CLASS="command"
>awk</B
> script, it would look like this:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>kelly is in ~&#62;</TT
> <B
CLASS="command"
>cat <TT
CLASS="filename"
>printnames.awk</TT
></B
>
BEGIN { FS=":" }
{ print $1 "\t" $5 }

<TT
CLASS="prompt"
>kelly is in ~&#62;</TT
> <B
CLASS="command"
>awk <TT
CLASS="option"
>-f</TT
> <TT
CLASS="filename"
>printnames.awk /etc/passwd</TT
></B
>
--output omitted--
</PRE
></FONT
></TD
></TR
></TABLE
><P
>Choose input field separators carefully to prevent problems.  An example to illustrate this: say you get input in the form of lines that look like this:</P
><P
><SPAN
CLASS="QUOTE"
>"Sandy L. Wong, 64 Zoo St., Antwerp, 2000X"</SPAN
></P
><P
>You write a command line or a script, which prints out the name of the person in that record:</P
><P
><B
CLASS="command"
>awk 'BEGIN { FS="," } { print $1, $2, $3 }' <TT
CLASS="filename"
>inputfile</TT
></B
> </P
><P
>But a person might have a PhD, and it might be written like this:</P
><P
><SPAN
CLASS="QUOTE"
>"Sandy L. Wong, PhD, 64 Zoo St., Antwerp, 2000X"</SPAN
></P
><P
>Your <B
CLASS="command"
>awk</B
> will give the wrong output for this line.  If needed, use an extra <B
CLASS="command"
>awk</B
> or <B
CLASS="command"
>sed</B
> to uniform data input formats.</P
><P
>The default input field separator is one or more whitespaces or tabs.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_06_03_02"
></A
>6.3.2. The output separators</H2
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="sect_06_03_02_01"
></A
>6.3.2.1. The output field separator</H3
><P
>Fields are normally separated by spaces in the output.  This becomes apparent when you use the correct syntax for the <B
CLASS="command"
>print</B
> command, where arguments are separated by commas:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>kelly@octarine ~/test&#62;</TT
> <B
CLASS="command"
>cat <TT
CLASS="filename"
>test</TT
></B
>
record1         data1
record2         data2

<TT
CLASS="prompt"
>kelly@octarine ~/test&#62;</TT
> <B
CLASS="command"
>awk <TT
CLASS="parameter"
><I
>'{ print $1 $2}'</I
></TT
> <TT
CLASS="filename"
>test</TT
></B
>
record1data1
record2data2

<TT
CLASS="prompt"
>kelly@octarine ~/test&#62;</TT
> <B
CLASS="command"
>awk <TT
CLASS="parameter"
><I
>'{ print $1, $2}'</I
></TT
> <TT
CLASS="filename"
>test</TT
></B
>
record1 data1
record2 data2

<TT
CLASS="prompt"
>kelly@octarine ~/test&#62;</TT
>
</PRE
></FONT
></TD
></TR
></TABLE
><P
>If you don't put in the commas, <B
CLASS="command"
>print</B
> will treat the items to output as one argument, thus omitting the use of the default <EM
>output separator</EM
>, <TT
CLASS="varname"
>OFS</TT
>.</P
><P
>Any character string may be used as the output field separator by setting this built-in variable.</P
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="sect_06_03_02_02"
></A
>6.3.2.2. The output record separator</H3
><P
>The output from an entire <B
CLASS="command"
>print</B
> statement is called an <EM
>output record</EM
>.  Each <B
CLASS="command"
>print</B
> command results in one output record, and then outputs a string called the <EM
>output record separator</EM
>, <TT
CLASS="varname"
>ORS</TT
>.  The default value for this variable is <SPAN
CLASS="QUOTE"
>"\n"</SPAN
>, a newline character.  Thus, each <B
CLASS="command"
>print</B
> statement generates a separate line.</P
><P
>To change the way output fields and records are separated, assign new values to <TT
CLASS="varname"
>OFS</TT
> and <TT
CLASS="varname"
>ORS</TT
>:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>kelly@octarine ~/test&#62;</TT
> <B
CLASS="command"
>awk <TT
CLASS="parameter"
><I
>'BEGIN { OFS=";" ; ORS="\n--&#62;\n" } \
{ print $1,$2}'</I
></TT
> <TT
CLASS="filename"
>test</TT
></B
>
record1;data1
--&#62;
record2;data2
--&#62;

<TT
CLASS="prompt"
>kelly@octarine ~/test&#62;</TT
>
</PRE
></FONT
></TD
></TR
></TABLE
><P
>If the value of <TT
CLASS="varname"
>ORS</TT
> does not contain a newline, the program's output is run together on a single line.</P
></DIV
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_06_03_03"
></A
>6.3.3. The number of records</H2
><P
>The built-in <TT
CLASS="varname"
>NR</TT
> holds the number of records that are processed.  It is incremented after reading a new input line.  You can use it at the end to count the total number of records, or in each output record:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>kelly@octarine ~/test&#62;</TT
> <B
CLASS="command"
>cat <TT
CLASS="filename"
>processed.awk</TT
></B
>
BEGIN { OFS="-" ; ORS="\n--&#62; done\n" }
{ print "Record number " NR ":\t" $1,$2 }
END { print "Number of records processed: " NR }

<TT
CLASS="prompt"
>kelly@octarine ~/test&#62;</TT
> <B
CLASS="command"
>awk <TT
CLASS="option"
>-f</TT
> <TT
CLASS="filename"
>processed.awk test</TT
></B
>
Record number 1:        record1-data1
--&#62; done
Record number 2:        record2-data2
--&#62; done
Number of records processed: 2
--&#62; done

<TT
CLASS="prompt"
>kelly@octarine ~/test&#62;</TT
>
</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_06_03_04"
></A
>6.3.4. User defined variables</H2
><P
>Apart from the built-in variables, you can define your own.  When <B
CLASS="command"
>awk</B
> encounters a reference to a variable which does not exist (which is not predefined), the variable is created and initialized to a null string.  For all subsequent references, the value of the variable is whatever value was assigned last.  Variables can be a string or a numeric value.  Content of input fields can also be assigned to variables.</P
><P
>Values can be assigned directly using the <B
CLASS="command"
>=</B
> operator, or you can use the current value of the variable in combination with other operators:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>kelly@octarine ~&#62;</TT
> <B
CLASS="command"
>cat <TT
CLASS="filename"
>revenues</TT
></B
>
20021009        20021013        consultancy     BigComp         2500
20021015        20021020        training        EduComp         2000
20021112        20021123        appdev          SmartComp       10000
20021204        20021215        training        EduComp         5000

<TT
CLASS="prompt"
>kelly@octarine ~&#62;</TT
> <B
CLASS="command"
>cat <TT
CLASS="filename"
>total.awk</TT
></B
>
{ total=total + $5 }
{ print "Send bill for " $5 " dollar to " $4 }
END { print "---------------------------------\nTotal revenue: " total }

<TT
CLASS="prompt"
>kelly@octarine ~&#62;</TT
> <B
CLASS="command"
>awk <TT
CLASS="option"
>-f</TT
> <TT
CLASS="filename"
>total.awk test</TT
></B
>
Send bill for 2500 dollar to BigComp
Send bill for 2000 dollar to EduComp
Send bill for 10000 dollar to SmartComp
Send bill for 5000 dollar to EduComp
---------------------------------
Total revenue: 19500

<TT
CLASS="prompt"
>kelly@octarine ~&#62;</TT
>
</PRE
></FONT
></TD
></TR
></TABLE
><P
>C-like shorthands like <B
CLASS="command"
><TT
CLASS="varname"
>VAR</TT
>+= value</B
> are also accepted.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_06_03_05"
></A
>6.3.5. More examples</H2
><P
>The example from <A
HREF="#sect_05_03_02"
>Section 5.3.2</A
> becomes much easier when we use an <B
CLASS="command"
>awk</B
> script:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>kelly@octarine ~/html&#62;</TT
> <B
CLASS="command"
>cat <TT
CLASS="filename"
>make-html-from-text.awk</TT
></B
>
BEGIN { print "&#60;html&#62;\n&#60;head&#62;&#60;title&#62;Awk-generated HTML&#60;/title&#62;&#60;/head&#62;\n&#60;body bgcolor=\"#ffffff\"&#62;\n&#60;pre&#62;" }
{ print $0 }
END { print "&#60;/pre&#62;\n&#60;/body&#62;\n&#60;/html&#62;" }
</PRE
></FONT
></TD
></TR
></TABLE
><P
>And the command to execute is also much more straightforward when using <B
CLASS="command"
>awk</B
> instead of <B
CLASS="command"
>sed</B
>:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>kelly@octarine ~/html&#62;</TT
> <B
CLASS="command"
>awk <TT
CLASS="option"
>-f</TT
> <TT
CLASS="filename"
>make-html-from-text.awk testfile</TT
> &#62; <TT
CLASS="filename"
>file.html</TT
></B
>
</PRE
></FONT
></TD
></TR
></TABLE
><DIV
CLASS="tip"
><P
></P
><TABLE
CLASS="tip"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="images/tip.gif"
HSPACE="5"
ALT="Tip"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>Awk examples on your system</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>We refer again to the directory containing the initscripts on your system.  Enter a command similar to the following to see more practical examples of the widely spread usage of the <B
CLASS="command"
>awk</B
> command:</P
><P
><B
CLASS="command"
>grep <TT
CLASS="parameter"
><I
>awk</I
></TT
> <TT
CLASS="filename"
>/etc/init.d/*</TT
></B
> </P
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_06_03_06"
></A
>6.3.6. The printf program</H2
><P
>For more precise control over the output format than what is normally provided by <B
CLASS="command"
>print</B
>, use <B
CLASS="command"
>printf</B
>.  The <B
CLASS="command"
>printf</B
> command can be used to specify the field width to use for each item, as well as various formatting choices for numbers (such as what output base to use, whether to print an exponent, whether to print a sign, and how many digits to print after the decimal point).  This is done by supplying a string, called the <EM
>format string</EM
>, that controls how and where to print the other arguments.</P
><P
>The syntax is the same as for the C-language <B
CLASS="command"
>printf</B
> statement; see your C introduction guide.  The <B
CLASS="command"
>gawk</B
> info pages contain full explanations.</P
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="sect_06_04"
></A
>6.4. Summary</H1
><P
>The <B
CLASS="command"
>gawk</B
> utility interprets a special-purpose programming language, handling simple data-reformatting jobs with just a few lines of code.  It is the free version of the general UNIX <B
CLASS="command"
>awk</B
> command.</P
><P
>This tools reads lines of input data and can easily recognize columned output.  The <B
CLASS="command"
>print</B
> program is the most common for filtering and formatting defined fields.</P
><P
>On-the-fly variable declaration is straightforward and allows for simple calculation of sums, statistics and other operations on the processed input stream.  Variables and commands can be put in <B
CLASS="command"
>awk</B
> scripts for background processing.</P
><P
>Other things you should know about <B
CLASS="command"
>awk</B
>:</P
><P
></P
><UL
><LI
><P
>The language remains well-known on UNIX and alikes, but for executing similar tasks, <SPAN
CLASS="application"
>Perl</SPAN
> is now more commonly used.  However, <B
CLASS="command"
>awk</B
> has a much steeper learning curve (meaning that you learn a lot in a very short time).  In other words, <SPAN
CLASS="application"
>Perl</SPAN
> is more difficult to learn.</P
></LI
><LI
><P
>Both <SPAN
CLASS="application"
>Perl</SPAN
> and <B
CLASS="command"
>awk</B
> share the reputation of being incomprehensible, even to the actual authors of the programs that use these languages.  So document your code!</P
></LI
></UL
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="sect_06_05"
></A
>6.5. Exercises</H1
><P
>These are some practical examples where <B
CLASS="command"
>awk</B
> can be useful.</P
><P
></P
><OL
TYPE="1"
><LI
><P
>For the first exercise, your input is lines in the following form:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>Username:Firstname:Lastname:Telephone number</PRE
></FONT
></TD
></TR
></TABLE
><P
>Make an <B
CLASS="command"
>awk</B
> script that will convert such a line to an LDAP record in this format:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;dn: uid=Username, dc=example, dc=com
cn: Firstname Lastname
sn: Lastname
telephoneNumber: Telephone number
</PRE
></FONT
></TD
></TR
></TABLE
><P
>Create a file containing a couple of test records and check.</P
></LI
><LI
><P
>Create a Bash script using <B
CLASS="command"
>awk</B
> and standard UNIX commands that will show the top three users of disk space in the <TT
CLASS="filename"
>/home</TT
> file system (if you don't have the directory holding the homes on a separate partition, make the script for the <TT
CLASS="filename"
>/</TT
> partition; this is present on every UNIX system).  First, execute the commands from the command line.  Then put them in a script.  The script should create sensible output (sensible as in readable by the boss).  If everything proves to work, have the script email its results to you (use for instance <B
CLASS="command"
>mail <TT
CLASS="option"
>-s</TT
> <TT
CLASS="parameter"
><I
>Disk space usage</I
></TT
> <TT
CLASS="email"
>&#60;<A
HREF="mailto:you@your_comp"
>you@your_comp</A
>&#62;</TT
> &#60; <TT
CLASS="filename"
>result</TT
></B
>).</P
><P
>If the quota daemon is running, use that information; if not, use <B
CLASS="command"
>find</B
>.</P
></LI
><LI
><P
>Create XML-style output from a <B
CLASS="keycap"
>Tab</B
>-separated list in the following form:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;Meaning very long line with a lot of description
 
meaning another long line
 
othermeaning    more longline
 
testmeaning     looooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooong line, but i mean really looooooooooooooooooooooooooooooooooooooooooooooooooong.
 
</PRE
></FONT
></TD
></TR
></TABLE
><P
>The output should read:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;&#60;row&#62;
&#60;entry&#62;Meaning&#60;/entry&#62;
&#60;entry&#62;
very long line
&#60;/entry&#62;
&#60;/row&#62;
&#60;row&#62;
&#60;entry&#62;meaning&#60;/entry&#62;
&#60;entry&#62;
long line
&#60;/entry&#62;
&#60;/row&#62;
&#60;row&#62;
&#60;entryothermeaning&#60;/entry&#62;
&#60;entry&#62;
more longline
&#60;/entry&#62;
&#60;/row&#62;
&#60;row&#62;
&#60;entrytestmeaning&#60;/entry&#62;
&#60;entry&#62;
looooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooong line, but i mean really looooooooooooooooooooooooooooooooooooooooooooooooooong.
&#60;/entry&#62;
&#60;/row&#62;
</PRE
></FONT
></TD
></TR
></TABLE
><P
>Additionally, if you know anything about XML, write a BEGIN and END script to complete the table.  Or do it in HTML.</P
></LI
></OL
></DIV
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="chap_07"
></A
>Chapter 7. Conditional statements</H1
><BLOCKQUOTE
CLASS="ABSTRACT"
><DIV
CLASS="abstract"
><A
NAME="AEN4515"
></A
><P
></P
><P
>In this chapter we will discuss the use of conditionals in Bash scripts.  This includes the following topics:</P
><P
>&#13;<P
></P
><UL
><LI
><P
>The <B
CLASS="command"
>if</B
> statement</P
></LI
><LI
><P
>Using the exit status of a command</P
></LI
><LI
><P
>Comparing and testing input and files</P
></LI
><LI
><P
><B
CLASS="command"
>if/then/else</B
> constructs</P
></LI
><LI
><P
><B
CLASS="command"
>if/then/elif/else</B
> constructs</P
></LI
><LI
><P
>Using and testing the positional parameters</P
></LI
><LI
><P
>Nested <B
CLASS="command"
>if</B
> statements</P
></LI
><LI
><P
>Boolean expressions</P
></LI
><LI
><P
>Using <B
CLASS="command"
>case</B
> statements</P
></LI
></UL
>
</P
><P
></P
></DIV
></BLOCKQUOTE
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="sect_07_01"
></A
>7.1. Introduction to if</H1
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="sect_07_01_01"
></A
>7.1.1. General</H2
><P
>At times you need to specify different courses of action to be taken in a shell script, depending on the success or failure of a command.  The <B
CLASS="command"
>if</B
> construction allows you to specify such conditions.</P
><P
>The most compact syntax of the <B
CLASS="command"
>if</B
> command is:</P
><P
><B
CLASS="command"
>if TEST-COMMANDS; then CONSEQUENT-COMMANDS; fi</B
> </P
><P
>The <B
CLASS="command"
>TEST-COMMAND</B
> list is executed, and if its return status is zero, the <B
CLASS="command"
>CONSEQUENT-COMMANDS</B
> list is executed.  The return status is the exit status of the last command executed, or zero if no condition tested true.</P
><P
>The <B
CLASS="command"
>TEST-COMMAND</B
> often involves numerical or string comparison tests, but it can also be any command that returns a status of zero when it succeeds and some other status when it fails.  Unary expressions are often used to examine the status of a file.  If the <TT
CLASS="filename"
>FILE</TT
> argument to one of the primaries is of the form <TT
CLASS="filename"
>/dev/fd/N</TT
>, then file descriptor <SPAN
CLASS="QUOTE"
>"N"</SPAN
> is checked.  <TT
CLASS="filename"
>stdin</TT
>, <TT
CLASS="filename"
>stdout</TT
> and <TT
CLASS="filename"
>stderr</TT
> and their respective file descriptors may also be used for tests.</P
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="sect_07_01_01_01"
></A
>7.1.1.1. Expressions used with if</H3
><P
>The table below contains an overview of the so-called <SPAN
CLASS="QUOTE"
>"primaries"</SPAN
> that make up the <B
CLASS="command"
>TEST-COMMAND</B
> command or list of commands.  These primaries are put between square brackets to indicate the test of a conditional expression.</P
><DIV
CLASS="table"
><A
NAME="tab_07_01"
></A
><P
><B
>Table 7-1. Primary expressions</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
>Primary</TH
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
>Meaning</TH
></TR
></THEAD
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>[ <TT
CLASS="option"
>-a</TT
> <TT
CLASS="filename"
>FILE</TT
> ]</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>True if <TT
CLASS="filename"
>FILE</TT
> exists.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>[ <TT
CLASS="option"
>-b</TT
> <TT
CLASS="filename"
>FILE</TT
> ]</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>True if <TT
CLASS="filename"
>FILE</TT
> exists and is a block-special file.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>[ <TT
CLASS="option"
>-c</TT
> <TT
CLASS="filename"
>FILE</TT
> ]</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>True if <TT
CLASS="filename"
>FILE</TT
> exists and is a character-special file.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>[ <TT
CLASS="option"
>-d</TT
> <TT
CLASS="filename"
>FILE</TT
> ]</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>True if <TT
CLASS="filename"
>FILE</TT
> exists and is a directory.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>[ <TT
CLASS="option"
>-e</TT
> <TT
CLASS="filename"
>FILE</TT
> ]</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>True if <TT
CLASS="filename"
>FILE</TT
> exists.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>[ <TT
CLASS="option"
>-f</TT
> <TT
CLASS="filename"
>FILE</TT
> ]</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>True if <TT
CLASS="filename"
>FILE</TT
> exists and is a regular file.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>[ <TT
CLASS="option"
>-g</TT
> <TT
CLASS="filename"
>FILE</TT
> ]</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>True if <TT
CLASS="filename"
>FILE</TT
> exists and its SGID bit is set.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>[ <TT
CLASS="option"
>-h</TT
> <TT
CLASS="filename"
>FILE</TT
> ]</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>True if <TT
CLASS="filename"
>FILE</TT
> exists and is a symbolic link.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>[ <TT
CLASS="option"
>-k</TT
> <TT
CLASS="filename"
>FILE</TT
> ]</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>True if <TT
CLASS="filename"
>FILE</TT
> exists and its sticky bit is set.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>[ <TT
CLASS="option"
>-p</TT
> <TT
CLASS="filename"
>FILE</TT
> ]</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>True if <TT
CLASS="filename"
>FILE</TT
> exists and is a named pipe (FIFO).</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>[ <TT
CLASS="option"
>-r</TT
> <TT
CLASS="filename"
>FILE</TT
> ]</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>True if <TT
CLASS="filename"
>FILE</TT
> exists and is readable.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>[ <TT
CLASS="option"
>-s</TT
> <TT
CLASS="filename"
>FILE</TT
> ]</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>True if <TT
CLASS="filename"
>FILE</TT
> exists and has a size greater than zero.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>[ <TT
CLASS="option"
>-t</TT
> <TT
CLASS="filename"
>FD</TT
> ]</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>True if file descriptor <TT
CLASS="filename"
>FD</TT
> is open and refers to a terminal.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>[ <TT
CLASS="option"
>-u</TT
> <TT
CLASS="filename"
>FILE</TT
> ]</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>True if <TT
CLASS="filename"
>FILE</TT
> exists and its SUID (set user ID) bit is set.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>[ <TT
CLASS="option"
>-w</TT
> <TT
CLASS="filename"
>FILE</TT
> ]</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>True if <TT
CLASS="filename"
>FILE</TT
> exists and is writable.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>[ <TT
CLASS="option"
>-x</TT
> <TT
CLASS="filename"
>FILE</TT
> ]</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>True if <TT
CLASS="filename"
>FILE</TT
> exists and is executable.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>[ <TT
CLASS="option"
>-O</TT
> <TT
CLASS="filename"
>FILE</TT
> ]</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>True if <TT
CLASS="filename"
>FILE</TT
> exists and is owned by the effective user ID.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>[ <TT
CLASS="option"
>-G</TT
> <TT
CLASS="filename"
>FILE</TT
> ]</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>True if <TT
CLASS="filename"
>FILE</TT
> exists and is owned by the effective group ID.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>[ <TT
CLASS="option"
>-L</TT
> <TT
CLASS="filename"
>FILE</TT
> ]</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>True if <TT
CLASS="filename"
>FILE</TT
> exists and is a symbolic link.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>[ <TT
CLASS="option"
>-N</TT
> <TT
CLASS="filename"
>FILE</TT
> ]</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>True if <TT
CLASS="filename"
>FILE</TT
> exists and has been modified since it was last read.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>[ <TT
CLASS="option"
>-S</TT
> <TT
CLASS="filename"
>FILE</TT
> ]</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>True if <TT
CLASS="filename"
>FILE</TT
> exists and is a socket.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>[ <TT
CLASS="filename"
>FILE1</TT
> <TT
CLASS="option"
>-nt</TT
> <TT
CLASS="filename"
>FILE2</TT
> ]</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>True if <TT
CLASS="filename"
>FILE1</TT
> has been changed more recently than <TT
CLASS="filename"
>FILE2</TT
>, or if <TT
CLASS="filename"
>FILE1</TT
> exists and <TT
CLASS="filename"
>FILE2</TT
> does not.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>[ <TT
CLASS="filename"
>FILE1</TT
> <TT
CLASS="option"
>-ot</TT
> <TT
CLASS="filename"
>FILE2</TT
> ]</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>True if <TT
CLASS="filename"
>FILE1</TT
> is older than <TT
CLASS="filename"
>FILE2</TT
>, or is <TT
CLASS="filename"
>FILE2</TT
> exists and <TT
CLASS="filename"
>FILE1</TT
> does not.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>[ <TT
CLASS="filename"
>FILE1</TT
> <TT
CLASS="option"
>-ef</TT
> <TT
CLASS="filename"
>FILE2</TT
> ]</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>True if <TT
CLASS="filename"
>FILE1</TT
> and <TT
CLASS="filename"
>FILE2</TT
> refer to the same device and inode numbers.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>[ <TT
CLASS="option"
>-o</TT
> OPTIONNAME ]</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>True if shell option <SPAN
CLASS="QUOTE"
>"OPTIONNAME"</SPAN
> is enabled.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><TT
CLASS="option"
>[ -z</TT
> STRING ]</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>True of the length if <SPAN
CLASS="QUOTE"
>"STRING"</SPAN
> is zero.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><TT
CLASS="option"
>[ -n</TT
> STRING ] or [ STRING ]</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>True if the length of <SPAN
CLASS="QUOTE"
>"STRING"</SPAN
> is non-zero.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>[ STRING1 == STRING2 ] </TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>True if the strings are equal.  <SPAN
CLASS="QUOTE"
>"="</SPAN
> may be used instead of <SPAN
CLASS="QUOTE"
>"=="</SPAN
> for strict POSIX compliance.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>[ STRING1 != STRING2 ] </TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>True if the strings are not equal.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>[ STRING1 &#60; STRING2 ] </TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>True if <SPAN
CLASS="QUOTE"
>"STRING1"</SPAN
> sorts before <SPAN
CLASS="QUOTE"
>"STRING2"</SPAN
> lexicographically in the current locale.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>[ STRING1 &#62; STRING2 ] </TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>True if <SPAN
CLASS="QUOTE"
>"STRING1"</SPAN
> sorts after <SPAN
CLASS="QUOTE"
>"STRING2"</SPAN
> lexicographically in the current locale.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>[ ARG1 OP ARG2 ]</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><SPAN
CLASS="QUOTE"
>"OP"</SPAN
> is one of <TT
CLASS="option"
>-eq</TT
>, <TT
CLASS="option"
>-ne</TT
>, <TT
CLASS="option"
>-lt</TT
>, <TT
CLASS="option"
>-le</TT
>, <TT
CLASS="option"
>-gt</TT
> or <TT
CLASS="option"
>-ge</TT
>.  These arithmetic binary operators return true if <SPAN
CLASS="QUOTE"
>"ARG1"</SPAN
> is equal to, not equal to, less than, less than or equal to, greater than, or greater than or equal to <SPAN
CLASS="QUOTE"
>"ARG2"</SPAN
>, respectively.  <SPAN
CLASS="QUOTE"
>"ARG1"</SPAN
> and <SPAN
CLASS="QUOTE"
>"ARG2"</SPAN
> are integers.</TD
></TR
></TBODY
></TABLE
></DIV
><P
>Expressions may be combined using the following operators, listed in decreasing order of precedence:</P
><DIV
CLASS="table"
><A
NAME="tab_07_02"
></A
><P
><B
>Table 7-2. Combining expressions</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
>Operation</TH
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
>Effect</TH
></TR
></THEAD
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>[ ! EXPR ]</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>True if <B
CLASS="command"
>EXPR</B
> is false.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>[ ( EXPR ) ]</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Returns the value of <B
CLASS="command"
>EXPR</B
>.  This may be used to override the normal precedence of operators.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>[ EXPR1 -a EXPR2 ]</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>True if both <B
CLASS="command"
>EXPR1</B
> and <B
CLASS="command"
>EXPR2</B
> are true.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>[ EXPR1 -o EXPR2 ]</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>True if either <B
CLASS="command"
>EXPR1</B
> or <B
CLASS="command"
>EXPR2</B
> is true.</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The <B
CLASS="command"
>[</B
> (or <B
CLASS="command"
>test</B
>) built-in evaluates conditional expressions using a set of rules based on the number of arguments.  More information about this subject can be found in the Bash documentation.  Just like the <B
CLASS="command"
>if</B
> is closed with <B
CLASS="command"
>fi</B
>, the opening square bracket should be closed after the conditions have been listed.</P
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="sect_07_01_01_02"
></A
>7.1.1.2. Commands following the then statement</H3
><P
>The <B
CLASS="command"
>CONSEQUENT-COMMANDS</B
> list that follows the <B
CLASS="command"
>then</B
> statement can be any valid UNIX command, any executable program, any executable shell script or any shell statement, with the exception of the closing <B
CLASS="command"
>fi</B
>.  It is important to remember that the <B
CLASS="command"
>then</B
> and <B
CLASS="command"
>fi</B
> are considered to be separated statements in the shell.  Therefore, when issued on the command line, they are separated by a semi-colon.</P
><P
>In a script, the different parts of the <B
CLASS="command"
>if</B
> statement are usually well-separated.  Below, a couple of simple examples.</P
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="sect_07_01_01_03"
></A
>7.1.1.3. Checking files</H3
><P
>The first example checks for the existence of a file:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>anny ~&#62;</TT
> <B
CLASS="command"
>cat <TT
CLASS="filename"
>msgcheck.sh</TT
></B
>
#!/bin/bash

echo "This scripts checks the existence of the messages file."
echo "Checking..."
if [ -f /var/log/messages ]
  then
    echo "/var/log/messages exists."
fi
echo
echo "...done."

<TT
CLASS="prompt"
>anny ~&#62;</TT
> <B
CLASS="command"
>./msgcheck.sh</B
>
This scripts checks the existence of the messages file.
Checking...
/var/log/messages exists.

...done.
</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="sect_07_01_01_04"
></A
>7.1.1.4. Checking shell options</H3
><P
>To add in your Bash configuration files:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;# These lines will print a message if the noclobber option is set:

if [ -o noclobber ]
  then
	echo "Your files are protected against accidental overwriting using redirection."
fi

</PRE
></FONT
></TD
></TR
></TABLE
><DIV
CLASS="note"
><P
></P
><TABLE
CLASS="note"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>The environment</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The above example will work when entered on the command line:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>anny ~&#62;</TT
> <B
CLASS="command"
>if <TT
CLASS="parameter"
><I
>[ -o noclobber ]</I
></TT
> ; then echo ; echo <TT
CLASS="parameter"
><I
>"your files are protected
against overwriting."</I
></TT
> ; echo ; fi</B
>

your files are protected against overwriting.

<TT
CLASS="prompt"
>anny ~&#62;</TT
>
</PRE
></FONT
></TD
></TR
></TABLE
><P
>However, if you use testing of conditions that depend on the environment, you might get different results when you enter the same command in a script, because the script will open a new shell, in which expected variables and options might not be set automatically.</P
></TD
></TR
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_07_01_02"
></A
>7.1.2. Simple applications of if</H2
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="sect_07_01_02_01"
></A
>7.1.2.1. Testing exit status</H3
><P
>The <TT
CLASS="varname"
>?</TT
> variable holds the exit status of the previously executed command (the most recently completed foreground process).</P
><P
>The following example shows a simple test:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>anny ~&#62;</TT
> <B
CLASS="command"
>if <TT
CLASS="parameter"
><I
>[ $? -eq 0 ]</I
></TT
></B
>
<TT
CLASS="prompt"
>More input&#62;</TT
> <B
CLASS="command"
>then echo <TT
CLASS="parameter"
><I
>'That was a good job!'</I
></TT
></B
>
<TT
CLASS="prompt"
>More input&#62;</TT
> <B
CLASS="command"
>fi</B
>
That was a good job!

<TT
CLASS="prompt"
>anny ~&#62;</TT
>
</PRE
></FONT
></TD
></TR
></TABLE
><P
>The following example demonstrates that <B
CLASS="command"
>TEST-COMMANDS</B
> might be any UNIX command that returns an exit status, and that <B
CLASS="command"
>if</B
> again returns an exit status of zero:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>anny ~&#62;</TT
> <B
CLASS="command"
>if <TT
CLASS="parameter"
><I
>! grep $USER</I
></TT
> <TT
CLASS="filename"
>/etc/passwd</TT
></B
>
<TT
CLASS="prompt"
>More input&#62;</TT
> <B
CLASS="command"
>then echo <TT
CLASS="parameter"
><I
>"your user account is not managed locally"</I
></TT
>; fi</B
>
your user account is not managed locally

<TT
CLASS="prompt"
>anny &#62;</TT
> <B
CLASS="command"
>echo <TT
CLASS="varname"
>$?</TT
></B
>
0

<TT
CLASS="prompt"
>anny &#62;</TT
>
</PRE
></FONT
></TD
></TR
></TABLE
><P
>The same result can be obtained as follows:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>anny &#62;</TT
> <B
CLASS="command"
>grep <TT
CLASS="varname"
>$USER</TT
> <TT
CLASS="filename"
>/etc/passwd</TT
></B
>

<TT
CLASS="prompt"
>anny &#62;</TT
> <B
CLASS="command"
>if <TT
CLASS="parameter"
><I
>[ $? -ne 0 ]</I
></TT
> ; then echo <TT
CLASS="parameter"
><I
>"not a local account"</I
></TT
> ; fi</B
>
not a local account

<TT
CLASS="prompt"
>anny &#62;</TT
>
</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="sect_07_01_02_02"
></A
>7.1.2.2. Numeric comparisons</H3
><P
>The examples below use numerical comparisons:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>anny &#62;</TT
> <B
CLASS="command"
><TT
CLASS="varname"
>num</TT
>=<TT
CLASS="parameter"
><I
>`wc -l work.txt`</I
></TT
></B
>

<TT
CLASS="prompt"
>anny &#62;</TT
> <B
CLASS="command"
>echo <TT
CLASS="varname"
>$num</TT
></B
>
201

<TT
CLASS="prompt"
>anny &#62;</TT
> <B
CLASS="command"
>if <TT
CLASS="parameter"
><I
>[ "$num" -gt "150" ]</I
></TT
></B
>
<TT
CLASS="prompt"
>More input&#62;</TT
> <B
CLASS="command"
>then echo ; echo <TT
CLASS="parameter"
><I
>"you've worked hard enough for today."</I
></TT
></B
>
<TT
CLASS="prompt"
>More input&#62;</TT
> <B
CLASS="command"
>echo ; fi</B
>

you've worked hard enough for today.


<TT
CLASS="prompt"
>anny &#62;</TT
>
</PRE
></FONT
></TD
></TR
></TABLE
><P
>This script is executed by cron every Sunday.  If the week number is even, it reminds you to put out the garbage cans:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;#!/bin/bash

# Calculate the week number using the date command:

WEEKOFFSET=$[ $(date +"%V") % 2 ]

# Test if we have a remainder.  If not, this is an even week so send a message.
# Else, do nothing.

if [ $WEEKOFFSET -eq "0" ]; then
  echo "Sunday evening, put out the garbage cans." | mail -s "Garbage cans out" your@your_domain.org
fi
</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="sect_07_01_02_03"
></A
>7.1.2.3. String comparisons</H3
><P
>An example of comparing strings for testing the user ID:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;if [ "$(whoami)" != 'root' ]; then
        echo "You have no permission to run $0 as non-root user."
        exit 1;
fi
</PRE
></FONT
></TD
></TR
></TABLE
><P
>With Bash, you can shorten this type of construct.  The compact equivalent of the above test is as follows:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;[ "$(whoami)" != 'root' ] &#38;&#38; ( echo you are using a non-privileged account; exit 1 )
</PRE
></FONT
></TD
></TR
></TABLE
><P
>Similar to the <SPAN
CLASS="QUOTE"
>"&#38;&#38;"</SPAN
> expression which indicates what to do if the test proves true, <SPAN
CLASS="QUOTE"
>"||"</SPAN
> specifies what to do if the test is false.</P
><P
>Regular expressions may also be used in comparisons:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>anny &#62;</TT
> <B
CLASS="command"
><TT
CLASS="varname"
>gender</TT
>=<TT
CLASS="parameter"
><I
>"female"</I
></TT
></B
>

<TT
CLASS="prompt"
>anny &#62;</TT
> <B
CLASS="command"
>if <TT
CLASS="parameter"
><I
>[[ "$gender" == f* ]]</I
></TT
></B
>
<TT
CLASS="prompt"
>More input&#62;</TT
> <B
CLASS="command"
>then echo <TT
CLASS="parameter"
><I
>"Pleasure to meet you, Madame."</I
></TT
>; fi</B
>
Pleasure to meet you, Madame.

<TT
CLASS="prompt"
>anny &#62;</TT
>
</PRE
></FONT
></TD
></TR
></TABLE
><DIV
CLASS="note"
><P
></P
><TABLE
CLASS="note"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>Real Programmers</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Most programmers will prefer to use the <B
CLASS="command"
>test</B
> built-in command, which is equivalent to using square brackets for comparison, like this:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;test "$(whoami)" != 'root' &#38;&#38; (echo you are using a non-privileged account; exit 1)
</PRE
></FONT
></TD
></TR
></TABLE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="note"
><P
></P
><TABLE
CLASS="note"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>No exit?</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>If you invoke the <B
CLASS="command"
>exit</B
> in a subshell, it will not pass variables to the parent.  Use { and } instead of ( and ) if you do not want Bash to fork a subshell.</P
></TD
></TR
></TABLE
></DIV
><P
>See the info pages for Bash for more information on pattern matching with the <SPAN
CLASS="QUOTE"
>"(( EXPRESSION ))"</SPAN
> and <SPAN
CLASS="QUOTE"
>"[[ EXPRESSION ]]"</SPAN
> constructs.</P
></DIV
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="sect_07_02"
></A
>7.2. More advanced if usage</H1
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="sect_07_02_01"
></A
>7.2.1. if/then/else constructs</H2
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="sect_07_02_01_01"
></A
>7.2.1.1. Dummy example</H3
><P
>This is the construct to use to take one course of action if the <B
CLASS="command"
>if</B
> commands test true, and another if it tests false.  An example:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>freddy scripts&#62;</TT
> <B
CLASS="command"
><TT
CLASS="varname"
>gender</TT
>=<TT
CLASS="parameter"
><I
>"male"</I
></TT
></B
>

<TT
CLASS="prompt"
>freddy scripts&#62;</TT
> <B
CLASS="command"
>if <TT
CLASS="parameter"
><I
>[[ "$gender" == "f*" ]]</I
></TT
></B
>
<TT
CLASS="prompt"
>More input&#62;</TT
> <B
CLASS="command"
>then echo <TT
CLASS="parameter"
><I
>"Pleasure to meet you, Madame."</I
></TT
></B
>
<TT
CLASS="prompt"
>More input&#62;</TT
> <B
CLASS="command"
>else echo <TT
CLASS="parameter"
><I
>"How come the lady hasn't got a drink yet?"</I
></TT
></B
>
<TT
CLASS="prompt"
>More input&#62;</TT
> <B
CLASS="command"
>fi</B
>
How come the lady hasn't got a drink yet?

<TT
CLASS="prompt"
>freddy scripts&#62;</TT
>
</PRE
></FONT
></TD
></TR
></TABLE
><DIV
CLASS="important"
><P
></P
><TABLE
CLASS="important"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="images/important.gif"
HSPACE="5"
ALT="Important"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>[] vs. [[]]</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Contrary to <TT
CLASS="parameter"
><I
>[</I
></TT
>, <TT
CLASS="parameter"
><I
>[[</I
></TT
> prevents word splitting of variable values.  So, if <TT
CLASS="varname"
>VAR="var with spaces"</TT
>, you do not need to double quote <TT
CLASS="varname"
>$VAR</TT
> in a test - eventhough using quotes remains a good habit.  Also, <TT
CLASS="parameter"
><I
>[[</I
></TT
> prevents pathname expansion, so literal strings with wildcards do not try to expand to filenames.  Using <TT
CLASS="parameter"
><I
>[[</I
></TT
>, <TT
CLASS="parameter"
><I
>==</I
></TT
> and <TT
CLASS="parameter"
><I
>!=</I
></TT
> interpret strings to the right as shell glob patterns to be matched against the value to the left, for instance: <TT
CLASS="parameter"
><I
>[[ "value" == val* ]]</I
></TT
>.</P
></TD
></TR
></TABLE
></DIV
><P
>Like the <B
CLASS="command"
>CONSEQUENT-COMMANDS</B
> list following the <B
CLASS="command"
>then</B
> statement, the <B
CLASS="command"
>ALTERNATE-CONSEQUENT-COMMANDS</B
> list following the <B
CLASS="command"
>else</B
> statement can hold any UNIX-style command that returns an exit status.</P
><P
>Another example, extending the one from <A
HREF="#sect_07_01_02_01"
>Section 7.1.2.1</A
>:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>anny ~&#62;</TT
> <B
CLASS="command"
>su <TT
CLASS="parameter"
><I
>-</I
></TT
></B
>
Password:
<TT
CLASS="prompt"
>[root@elegance root]#</TT
> <B
CLASS="command"
>if <TT
CLASS="parameter"
><I
>! grep ^$USER</I
></TT
> <TT
CLASS="filename"
>/etc/passwd</TT
> 1&#62; <TT
CLASS="filename"
>/dev/null</TT
></B
>
<TT
CLASS="prompt"
>&#62;</TT
> <B
CLASS="command"
>then echo <TT
CLASS="parameter"
><I
>"your user account is not managed locally"</I
></TT
></B
>
<TT
CLASS="prompt"
>&#62;</TT
> <B
CLASS="command"
>else echo <TT
CLASS="parameter"
><I
>"your account is managed from the local /etc/passwd file"</I
></TT
></B
>
<TT
CLASS="prompt"
>&#62;</TT
> <B
CLASS="command"
>fi</B
>
your account is managed from the local /etc/passwd file
<TT
CLASS="prompt"
>[root@elegance root]#</TT
>
</PRE
></FONT
></TD
></TR
></TABLE
><P
>We switch to the <EM
>root</EM
> account to demonstrate the effect of the <B
CLASS="command"
>else</B
> statement - your <EM
>root</EM
> is usually a local account while your own user account might be managed by a central system, such as an LDAP server.</P
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="sect_07_02_01_02"
></A
>7.2.1.2. Checking command line arguments</H3
><P
>Instead of setting a variable and then executing a script, it is frequently more elegant to put the values for the variables on the command line.</P
><P
>We use the positional parameters <TT
CLASS="varname"
>$1</TT
>, <TT
CLASS="varname"
>$2</TT
>, ..., <TT
CLASS="varname"
>$N</TT
> for this purpose.  <TT
CLASS="varname"
>$#</TT
> refers to the number of command line arguments.  <TT
CLASS="varname"
>$0</TT
> refers to the name of the script.</P
><P
>The following is a simple example:</P
><DIV
CLASS="figure"
><A
NAME="AEN5029"
></A
><P
><B
>Figure 7-1. Testing of a command line argument with if</B
></P
><DIV
CLASS="mediaobject"
><P
><IMG
SRC="images/penguin.sh.png"></P
></DIV
></DIV
><P
>Here's another example, using two arguments:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>anny ~&#62;</TT
> <B
CLASS="command"
>cat <TT
CLASS="filename"
>weight.sh</TT
></B
>
#!/bin/bash

# This script prints a message about your weight if you give it your
# weight in kilos and height in centimeters.

weight="$1"
height="$2"
idealweight=$[$height - 110]

if [ $weight -le $idealweight ] ; then
  echo "You should eat a bit more fat."
else
  echo "You should eat a bit more fruit."
fi

<TT
CLASS="prompt"
>anny ~&#62;</TT
> <B
CLASS="command"
>bash <TT
CLASS="option"
>-x</TT
> <TT
CLASS="filename"
>weight.sh</TT
> <TT
CLASS="parameter"
><I
>55 169</I
></TT
></B
>
+ weight=55
+ height=169
+ idealweight=59
+ '[' 55 -le 59 ']'
+ echo 'You should eat a bit more fat.'
You should eat a bit more fat.
</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="sect_07_02_01_03"
></A
>7.2.1.3. Testing the number of arguments</H3
><P
>The following example shows how to change the previous script so that it prints a message if more or less than 2 arguments are given:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>anny ~&#62;</TT
> <B
CLASS="command"
>cat <TT
CLASS="filename"
>weight.sh</TT
></B
>
#!/bin/bash

# This script prints a message about your weight if you give it your
# weight in kilos and height in centimeters.

if [ ! $# == 2 ]; then
  echo "Usage: $0 weight_in_kilos length_in_centimeters"
  exit
fi

weight="$1"
height="$2"
idealweight=$[$height - 110]

if [ $weight -le $idealweight ] ; then
  echo "You should eat a bit more fat."
else
  echo "You should eat a bit more fruit."
fi

<TT
CLASS="prompt"
>anny ~&#62;</TT
> <B
CLASS="command"
>weight.sh <TT
CLASS="parameter"
><I
>70 150</I
></TT
></B
>
You should eat a bit more fruit.

<TT
CLASS="prompt"
>anny ~&#62;</TT
> <B
CLASS="command"
>weight.sh <TT
CLASS="parameter"
><I
>70 150 33</I
></TT
></B
>
Usage: ./weight.sh weight_in_kilos length_in_centimeters
</PRE
></FONT
></TD
></TR
></TABLE
><P
>The first argument is referred to as <TT
CLASS="varname"
>$1</TT
>, the second as <TT
CLASS="varname"
>$2</TT
> and so on.  The total number of arguments is stored in <TT
CLASS="varname"
>$#</TT
>.</P
><P
>Check out <A
HREF="#sect_07_02_05"
>Section 7.2.5</A
> for a more elegant way to print usage messages.</P
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="sect_07_02_01_04"
></A
>7.2.1.4. Testing that a file exists</H3
><P
>This test is done in a lot of scripts, because there's no use in starting a lot of programs if you know they're not going to work:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;#!/bin/bash

# This script gives information about a file.

FILENAME="$1"

echo "Properties for $FILENAME:"

if [ -f $FILENAME ]; then
  echo "Size is $(ls -lh $FILENAME | awk '{ print $5 }')"
  echo "Type is $(file $FILENAME | cut -d":" -f2 -)"
  echo "Inode number is $(ls -i $FILENAME | cut -d" " -f1 -)"
  echo "$(df -h $FILENAME | grep -v Mounted | awk '{ print "On",$1", \
which is mounted as the",$6,"partition."}')"
else
  echo "File does not exist."
fi
</PRE
></FONT
></TD
></TR
></TABLE
><P
>Note that the file is referred to using a variable; in this case it is the first argument to the script.  Alternatively, when no arguments are given, file locations are usually stored in variables at the beginning of a script, and their content is referred to using these variables.  Thus, when you want to change a file name in a script, you only need to do it once.</P
><DIV
CLASS="tip"
><P
></P
><TABLE
CLASS="tip"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="images/tip.gif"
HSPACE="5"
ALT="Tip"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>Filenames with spaces</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The above example will fail if the value of <TT
CLASS="varname"
>$1</TT
> can be parsed as multiple words.  In that case, the <B
CLASS="command"
>if</B
> command can be fixed either using double quotes around the filename, or by using <TT
CLASS="parameter"
><I
>[[</I
></TT
> instead of <TT
CLASS="parameter"
><I
>[</I
></TT
>.</P
></TD
></TR
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_07_02_02"
></A
>7.2.2. if/then/elif/else constructs</H2
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="sect_07_02_02_01"
></A
>7.2.2.1. General</H3
><P
>This is the full form of the <B
CLASS="command"
>if</B
> statement:</P
><P
><B
CLASS="command"
>if TEST-COMMANDS; then</B
> </P
><P
><B
CLASS="command"
>CONSEQUENT-COMMANDS;</B
> </P
><P
><B
CLASS="command"
>elif MORE-TEST-COMMANDS; then</B
> </P
><P
><B
CLASS="command"
>MORE-CONSEQUENT-COMMANDS;</B
> </P
><P
><B
CLASS="command"
>else ALTERNATE-CONSEQUENT-COMMANDS;</B
> </P
><P
><B
CLASS="command"
>fi</B
> </P
><P
>The <B
CLASS="command"
>TEST-COMMANDS</B
> list is executed, and if its return status is zero, the <B
CLASS="command"
>CONSEQUENT-COMMANDS</B
> list is executed.  If
<B
CLASS="command"
>TEST-COMMANDS</B
> returns a non-zero status, each <B
CLASS="command"
>elif</B
> list is executed in turn, and if its exit status is zero, the corresponding <B
CLASS="command"
>MORE-CONSEQUENT-COMMANDS</B
> is executed and the command completes.  If <B
CLASS="command"
>else</B
> is followed by an <B
CLASS="command"
>ALTERNATE-CONSEQUENT-COMMANDS</B
> list, and the final command in the final <B
CLASS="command"
>if</B
> or <B
CLASS="command"
>elif</B
> clause has a non-zero exit status, then <B
CLASS="command"
>ALTERNATE-CONSEQUENT-COMMANDS</B
> is executed.  The return status is the exit status of the last command executed, or zero if no condition tested true.</P
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="sect_07_02_02_02"
></A
>7.2.2.2. Example</H3
><P
>This is an example that you can put in your crontab for daily execution:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>anny /etc/cron.daily&#62;</TT
> <B
CLASS="command"
>cat <TT
CLASS="filename"
>disktest.sh</TT
></B
>
#!/bin/bash

# This script does a very simple test for checking disk space.

space=`df -h | awk '{print $5}' | grep % | grep -v Use | sort -n | tail -1 | cut -d "%" -f1 -`
alertvalue="80"

if [ "$space" -ge "$alertvalue" ]; then
  echo "At least one of my disks is nearly full!" | mail -s "daily diskcheck" root
else
  echo "Disk space normal" | mail -s "daily diskcheck" root
fi
</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_07_02_03"
></A
>7.2.3. Nested if statements</H2
><P
>Inside the <B
CLASS="command"
>if</B
> statement, you can use another <B
CLASS="command"
>if</B
> statement.  You may use as many levels of nested <B
CLASS="command"
>if</B
>s as you can logically manage.</P
><P
>This is an example testing leap years:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>anny ~/testdir&#62;</TT
> <B
CLASS="command"
>cat <TT
CLASS="filename"
>testleap.sh</TT
></B
>
#!/bin/bash
# This script will test if we're in a leap year or not.

year=`date +%Y`

if [ $[$year % 400] -eq "0" ]; then
  echo "This is a leap year.  February has 29 days."
elif [ $[$year % 4] -eq 0 ]; then
        if [ $[$year % 100] -ne 0 ]; then
          echo "This is a leap year, February has 29 days."
        else
          echo "This is not a leap year.  February has 28 days."
        fi
else
  echo "This is not a leap year.  February has 28 days."
fi

<TT
CLASS="prompt"
>anny ~/testdir&#62;</TT
> <B
CLASS="command"
>date</B
>
Tue Jan 14 20:37:55 CET 2003

<TT
CLASS="prompt"
>anny ~/testdir&#62;</TT
> <B
CLASS="command"
>testleap.sh</B
>
This is not a leap year.
</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_07_02_04"
></A
>7.2.4. Boolean operations</H2
><P
>The above script can be shortened using the Boolean operators <SPAN
CLASS="QUOTE"
>"AND"</SPAN
> (&#38;&#38;) and <SPAN
CLASS="QUOTE"
>"OR"</SPAN
> (||).</P
><DIV
CLASS="figure"
><A
NAME="AEN5144"
></A
><P
><B
>Figure 7-2. Example using Boolean operators</B
></P
><DIV
CLASS="mediaobject"
><P
><IMG
SRC="images/leaptest.sh.png"></P
></DIV
></DIV
><P
>We use the double brackets for testing an arithmetic expression, see <A
HREF="#sect_03_04_05"
>Section 3.4.6</A
>.  This is equivalent to the <B
CLASS="command"
>let</B
> statement.  You will get stuck using square brackets here, if you try something like <B
CLASS="command"
>$[$year % 400]</B
>, because here, the square brackets don't represent an actual command by themselves.</P
><P
>Among other editors, <B
CLASS="command"
>gvim</B
> is one of those supporting colour schemes according to the file format; such editors are useful for detecting errors in your code.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_07_02_05"
></A
>7.2.5. Using the exit statement and if</H2
><P
>We already briefly met the <B
CLASS="command"
>exit</B
> statement in <A
HREF="#sect_07_02_01_03"
>Section 7.2.1.3</A
>.  It terminates execution of the entire script.  It is most often used if the input requested from the user is incorrect, if a statement did not run successfully or if some other error occurred.</P
><P
>The <B
CLASS="command"
>exit</B
> statement takes an optional argument.  This argument is the integer exit status code, which is passed back to the parent and stored in the <TT
CLASS="varname"
>$?</TT
> variable.</P
><P
>A zero argument means that the script ran successfully.  Any other value may be used by programmers to pass back different messages to the parent, so that different actions can be taken according to failure or success of the child process.  If no argument is given to the <B
CLASS="command"
>exit</B
> command, the parent shell uses the current value of the <TT
CLASS="varname"
>$?</TT
> variable.</P
><P
>Below is an example with a slightly adapted <TT
CLASS="filename"
>penguin.sh</TT
> script, which sends its exit status back to the parent, <TT
CLASS="filename"
>feed.sh</TT
>:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>anny ~/testdir&#62;</TT
> <B
CLASS="command"
>cat <TT
CLASS="filename"
>penguin.sh</TT
></B
>
#!/bin/bash
                                                                                                 
# This script lets you present different menus to Tux.  He will only be happy
# when given a fish.  We've also added a dolphin and (presumably) a camel.
                                                                                                 
if [ "$menu" == "fish" ]; then
  if [ "$animal" == "penguin" ]; then
    echo "Hmmmmmm fish... Tux happy!"
  elif [ "$animal" == "dolphin" ]; then
    echo "Pweetpeettreetppeterdepweet!"
  else
    echo "*prrrrrrrt*"
  fi
else
  if [ "$animal" == "penguin" ]; then
    echo "Tux don't like that.  Tux wants fish!"
    exit 1
  elif [ "$animal" == "dolphin" ]; then
    echo "Pweepwishpeeterdepweet!"
    exit 2
  else
    echo "Will you read this sign?!"
    exit 3
  fi
fi
</PRE
></FONT
></TD
></TR
></TABLE
><P
>This script is called upon in the next one, which therefore exports its variables <TT
CLASS="varname"
>menu</TT
> and <TT
CLASS="varname"
>animal</TT
>:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>anny ~/testdir&#62;</TT
> <B
CLASS="command"
>cat <TT
CLASS="filename"
>feed.sh</TT
></B
>
#!/bin/bash
# This script acts upon the exit status given by penguin.sh
                                                                                                 
export menu="$1"
export animal="$2"
                                                                                                 
feed="/nethome/anny/testdir/penguin.sh"
                                                                                                 
$feed $menu $animal
                                                                                                 
case $? in
                                                                                                 
1)
  echo "Guard: You'd better give'm a fish, less they get violent..."
  ;;
2)
  echo "Guard: It's because of people like you that they are leaving earth all the time..."
  ;;
3)
  echo "Guard: Buy the food that the Zoo provides for the animals, you ***, how
do you think we survive?"
  ;;
*)
  echo "Guard: Don't forget the guide!"
  ;;
esac
                                                                                                 
<TT
CLASS="prompt"
>anny ~/testdir&#62;</TT
> <B
CLASS="command"
>./feed.sh <TT
CLASS="parameter"
><I
>apple penguin</I
></TT
></B
>
Tux don't like that.  Tux wants fish!
Guard: You'd better give'm a fish, less they get violent...
</PRE
></FONT
></TD
></TR
></TABLE
><P
>As you can see, exit status codes can be chosen freely.  Existing commands usually have a series of defined codes; see the programmer's manual for each command for more information.</P
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="sect_07_03"
></A
>7.3. Using case statements</H1
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="sect_07_03_01"
></A
>7.3.1. Simplified conditions</H2
><P
>Nested <B
CLASS="command"
>if</B
> statements might be nice, but as soon as you are confronted with a couple of different possible actions to take, they tend to confuse.  For the more complex conditionals, use the <B
CLASS="command"
>case</B
> syntax:</P
><P
><B
CLASS="command"
>case <TT
CLASS="function"
>EXPRESSION</TT
> in <TT
CLASS="function"
>CASE1</TT
>) COMMAND-LIST;; <TT
CLASS="function"
>CASE2</TT
>) COMMAND-LIST;; ... <TT
CLASS="function"
>CASEN</TT
>) COMMAND-LIST;; esac</B
> </P
><P
>Each case is an expression matching a pattern.  The commands in the <B
CLASS="command"
>COMMAND-LIST</B
> for the first match are executed.  The <SPAN
CLASS="QUOTE"
>"|"</SPAN
> symbol is used for separating multiple patterns, and the <SPAN
CLASS="QUOTE"
>")"</SPAN
> operator terminates a pattern list.  Each case plus its according commands are called a <EM
>clause</EM
>.  Each clause must be terminated with <SPAN
CLASS="QUOTE"
>";;"</SPAN
>.  Each <B
CLASS="command"
>case</B
> statement is ended with the <B
CLASS="command"
>esac</B
> statement.</P
><P
>In the example, we demonstrate use of cases for sending a more selective warning message with the <TT
CLASS="filename"
>disktest.sh</TT
> script:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>anny ~/testdir&#62;</TT
> <B
CLASS="command"
>cat <TT
CLASS="filename"
>disktest.sh</TT
></B
>
#!/bin/bash

# This script does a very simple test for checking disk space.

space=`df -h | awk '{print $5}' | grep % | grep -v Use | sort -n | tail -1 | cut -d "%" -f1 -`

case $space in
[1-6]*)
  Message="All is quiet."
  ;;
[7-8]*)
  Message="Start thinking about cleaning out some stuff.  There's a partition that is $space % full."
  ;;
9[1-8])
  Message="Better hurry with that new disk...  One partition is $space % full."
  ;;
99)
  Message="I'm drowning here!  There's a partition at $space %!"
  ;;
*)
  Message="I seem to be running with an nonexistent amount of disk space..."
  ;;
esac

echo $Message | mail -s "disk report `date`" anny

<TT
CLASS="prompt"
>anny ~/testdir&#62;</TT
>
You have new mail.

<TT
CLASS="prompt"
>anny ~/testdir&#62;</TT
> <B
CLASS="command"
>tail <TT
CLASS="parameter"
><I
>-16</I
></TT
> <TT
CLASS="filename"
>/var/spool/mail/anny</TT
></B
>
From anny@octarine Tue Jan 14 22:10:47 2003
Return-Path: &#60;anny@octarine&#62;
Received: from octarine (localhost [127.0.0.1])
        by octarine (8.12.5/8.12.5) with ESMTP id h0ELAlBG020414
        for &#60;anny@octarine&#62;; Tue, 14 Jan 2003 22:10:47 +0100
Received: (from anny@localhost)
        by octarine (8.12.5/8.12.5/Submit) id h0ELAltn020413
        for anny; Tue, 14 Jan 2003 22:10:47 +0100
Date: Tue, 14 Jan 2003 22:10:47 +0100
From: Anny &#60;anny@octarine&#62;
Message-Id: &#60;200301142110.h0ELAltn020413@octarine&#62;
To: anny@octarine
Subject: disk report Tue Jan 14 22:10:47 CET 2003

Start thinking about cleaning out some stuff.  There's a partition that is 87 % full.

<TT
CLASS="prompt"
>anny ~/testdir&#62;</TT
>
</PRE
></FONT
></TD
></TR
></TABLE
><P
>Of course you could have opened your mail program to check the results; this is just to demonstrate that the script sends a decent mail with <SPAN
CLASS="QUOTE"
>"To:"</SPAN
>, <SPAN
CLASS="QUOTE"
>"Subject:"</SPAN
> and <SPAN
CLASS="QUOTE"
>"From:"</SPAN
> header lines.</P
><P
>Many more examples using <B
CLASS="command"
>case</B
> statements can be found in your system's init script directory.  The startup scripts use <B
CLASS="command"
>start</B
> and <B
CLASS="command"
>stop</B
> cases to run or stop system processes.  A theoretical example can be found in the next section.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_07_03_02"
></A
>7.3.2. Initscript example</H2
><P
>Initscripts often make use of <B
CLASS="command"
>case</B
> statements for starting, stopping and querying system services.  This is an excerpt of the script that starts <SPAN
CLASS="application"
>Anacron</SPAN
>, a daemon that runs commands periodically with a frequency specified in days.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;case "$1" in
        start)
            start
            ;;
         
        stop)
            stop
            ;;
         
        status)
            status anacron
            ;;
        restart)
            stop
            start
            ;;
        condrestart)
            if test "x`pidof anacron`" != x; then
                stop
                start
            fi
            ;;
         
        *)
            echo $"Usage: $0 {start|stop|restart|condrestart|status}"
            exit 1
 
esac
</PRE
></FONT
></TD
></TR
></TABLE
><P
>The tasks to execute in each case, such as stopping and starting the daemon, are defined in functions, which are partially sourced from the <TT
CLASS="filename"
>/etc/rc.d/init.d/functions</TT
> file.  See <A
HREF="#chap_11"
>Chapter 11</A
> for more explanation.</P
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="sect_07_04"
></A
>7.4. Summary</H1
><P
>In this chapter we learned how to build conditions into our scripts so that different actions can be undertaken upon success or failure of a command.  The actions can be determined using the <B
CLASS="command"
>if</B
> statement.  This allows you to perform arithmetic and string comparisons, and testing of exit code, input and files needed by the script.</P
><P
>A simple <B
CLASS="command"
>if/then/fi</B
> test often preceeds commands in a shell script in order to prevent output generation, so that the script can easily be run in the background or through the <SPAN
CLASS="application"
>cron</SPAN
> facility.  More complex definitions of conditions are usually put in a <B
CLASS="command"
>case</B
> statement.</P
><P
>Upon successful condition testing, the script can explicitly inform the parent using the <B
CLASS="command"
>exit 0</B
> status.  Upon failure, any other number may be returned.  Based on the return code, the parent program can take appropriate action.</P
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="sect_07_05"
></A
>7.5. Exercises</H1
><P
>Here are some ideas to get you started using <B
CLASS="command"
>if</B
> in scripts:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Use an <B
CLASS="command"
>if/then/elif/else</B
> construct that prints information about the current month.  The script should print the number of days in this month, and give information about leap years if the current month is February.</P
></LI
><LI
><P
>Do the same, using a <B
CLASS="command"
>case</B
> statement and an alternative use of the <B
CLASS="command"
>date</B
> command.</P
></LI
><LI
><P
>Modify <TT
CLASS="filename"
>/etc/profile</TT
> so that you get a special greeting message when you connect to your system as <EM
>root</EM
>.</P
></LI
><LI
><P
>Edit the <TT
CLASS="filename"
>leaptest.sh</TT
> script from <A
HREF="#sect_07_02_04"
>Section 7.2.4</A
> so that it requires one argument, the year.  Test that exactly one argument is supplied.</P
></LI
><LI
><P
>Write a script called <TT
CLASS="filename"
>whichdaemon.sh</TT
> that checks if the <B
CLASS="command"
>httpd</B
> and <B
CLASS="command"
>init</B
> daemons are running on your system.  If an <B
CLASS="command"
>httpd</B
> is running, the script should print a message like, <SPAN
CLASS="QUOTE"
>"This machine is running a web server."</SPAN
>  Use <B
CLASS="command"
>ps</B
> to check on processes.</P
></LI
><LI
><P
>Write a script that makes a backup of your home directory on a remote machine using <B
CLASS="command"
>scp</B
>.  The script should report in a log file, for instance <TT
CLASS="filename"
>~/log/homebackup.log</TT
>.  If you don't have a second machine to copy the backup to, use <B
CLASS="command"
>scp</B
> to test copying it to the localhost.  This requires SSH keys between the two hosts, or else you have to supply a password.  The creation of SSH keys is explained in <B
CLASS="command"
>man <TT
CLASS="parameter"
><I
>ssh-keygen</I
></TT
></B
>.</P
><LI
><P
>Adapt the script from the first example in <A
HREF="#sect_07_03_01"
>Section 7.3.1</A
> to include the case of exactly 90% disk space usage, and lower than 10% disk space usage.</P
></LI
><P
>The script should use <B
CLASS="command"
>tar <TT
CLASS="option"
>cf</TT
></B
> for the creation of the backup and <B
CLASS="command"
>gzip</B
> or <B
CLASS="command"
>bzip2</B
> for compressing the <TT
CLASS="filename"
>.tar</TT
> file.  Put all filenames in variables.  Put the name of the remote server and the remote directory in a variable.  This will make it easier to re-use the script or to make changes to it in the future.</P
><P
>The script should check for the existence of a compressed archive.  If this exists, remove it first in order to prevent output generation.</P
><P
>The script should also check for available diskspace.  Keep in mind that at any given moment you could have the data in your home directory, the data in the <TT
CLASS="filename"
>.tar</TT
> file and the data in the compressed archive all together on your disk.  If there is not enough diskspace, exit with an error message in the log file.</P
><P
>The script should clean up the compressed archive before it exits.</P
></LI
></OL
></DIV
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="chap_08"
></A
>Chapter 8. Writing interactive scripts</H1
><BLOCKQUOTE
CLASS="ABSTRACT"
><DIV
CLASS="abstract"
><A
NAME="AEN5307"
></A
><P
></P
><P
>In this chapter we will discuss how to interact with the users of our scripts:</P
><P
>&#13;<P
></P
><UL
><LI
><P
>Printing user friendly messages and explanations</P
></LI
><LI
><P
>Catching user input</P
></LI
><LI
><P
>Prompting for user input</P
></LI
><LI
><P
>Using the file descriptors to read from and write to multiple files</P
></LI
></UL
>
</P
><P
></P
></DIV
></BLOCKQUOTE
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="sect_08_01"
></A
>8.1. Displaying user messages</H1
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="sect_08_01_01"
></A
>8.1.1. Interactive or not?</H2
><P
>Some scripts run without any interaction from the user at all.  Advantages of non-interactive scripts include:</P
><P
></P
><UL
><LI
><P
>The script runs in a predictable way every time.</P
></LI
><LI
><P
>The script can run in the background.</P
></LI
></UL
><P
>Many scripts, however, require input from the user, or give output to the user as the script is running.  The advantages of interactive scripts are, among others:</P
><P
></P
><UL
><LI
><P
>More flexible scripts can be built.</P
></LI
><LI
><P
>Users can customize the script as it runs or make it behave in different ways.</P
></LI
><LI
><P
>The script can report its progress as it runs.</P
></LI
></UL
><P
>When writing interactive scripts, never hold back on comments.  A script that prints appropriate messages is much more user-friendly and can be more easily debugged.  A script might do a perfect job, but you will get a whole lot of support calls if it does not inform the user about what it is doing.  So include messages that tell the user to wait for output because a calculation is being done.  If possible, try to give an indication of how long the user will have to wait.  If the waiting should regularly take a long time when executing a certain task, you might want to consider integrating some processing indication in the output of your script.</P
><P
>When prompting the user for input, it is also better to give too much than too little information about the kind of data to be entered.  This applies to the checking of arguments and the accompanying usage message as well.</P
><P
>Bash has the <B
CLASS="command"
>echo</B
> and <B
CLASS="command"
>printf</B
> commands to provide comments for users, and although you should be familiar with at least the use of <B
CLASS="command"
>echo</B
> by now, we will discuss some more examples in the next sections.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_08_01_02"
></A
>8.1.2. Using the echo built-in command</H2
><P
>The <B
CLASS="command"
>echo</B
> built-in command outputs its arguments, separated by spaces and terminated with a newline character.  The return status is always zero.  <B
CLASS="command"
>echo</B
> takes a couple of options:</P
><P
></P
><UL
><LI
><P
><TT
CLASS="option"
>-e</TT
>: interprets backslash-escaped characters.</P
></LI
><LI
><P
><TT
CLASS="option"
>-n</TT
>: suppresses the trailing newline.</P
></LI
></UL
><P
>As an example of adding comments, we will make the <TT
CLASS="filename"
>feed.sh</TT
> and <TT
CLASS="filename"
>penguin.sh</TT
> from <A
HREF="#sect_07_02_01_02"
>Section 7.2.1.2</A
> a bit better:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>michel ~/test&#62;</TT
> <B
CLASS="command"
>cat <TT
CLASS="filename"
>penguin.sh</TT
></B
>
#!/bin/bash

# This script lets you present different menus to Tux.  He will only be happy
# when given a fish.  To make it more fun, we added a couple more animals.

if [ "$menu" == "fish" ]; then
  if [ "$animal" == "penguin" ]; then
    echo -e "Hmmmmmm fish... Tux happy!\n"
  elif [ "$animal" == "dolphin" ]; then
    echo -e "\a\a\aPweetpeettreetppeterdepweet!\a\a\a\n"
  else
    echo -e "*prrrrrrrt*\n"
  fi
else
  if [ "$animal" == "penguin" ]; then
    echo -e "Tux don't like that.  Tux wants fish!\n"
    exit 1
  elif [ "$animal" == "dolphin" ]; then
    echo -e "\a\a\a\a\a\aPweepwishpeeterdepweet!\a\a\a"
    exit 2
  else
    echo -e "Will you read this sign?!  Don't feed the "$animal"s!\n"
    exit 3
  fi
fi

<TT
CLASS="prompt"
>michel ~/test&#62;</TT
> <B
CLASS="command"
>cat <TT
CLASS="filename"
>feed.sh</TT
></B
>
#!/bin/bash
# This script acts upon the exit status given by penguin.sh

if [ "$#" != "2" ]; then
  echo -e "Usage of the feed script:\t$0 food-on-menu animal-name\n"
  exit 1
else

  export menu="$1"
  export animal="$2"

  echo -e "Feeding $menu to $animal...\n"

  feed="/nethome/anny/testdir/penguin.sh"

  $feed $menu $animal

result="$?"

  echo -e "Done feeding.\n"

case "$result" in

  1)
    echo -e "Guard: \"You'd better give'm a fish, less they get violent...\"\n"
    ;;
  2)
    echo -e "Guard: \"No wonder they flee our planet...\"\n"
    ;;
  3)
    echo -e "Guard: \"Buy the food that the Zoo provides at the entry, you ***\"\n"
    echo -e "Guard: \"You want to poison them, do you?\"\n"
    ;;
  *)
    echo -e "Guard: \"Don't forget the guide!\"\n"
    ;;
  esac

fi

echo "Leaving..."
echo -e "\a\a\aThanks for visiting the Zoo, hope to see you again soon!\n"

<TT
CLASS="prompt"
>michel ~/test&#62;</TT
> <B
CLASS="command"
>feed.sh <TT
CLASS="parameter"
><I
>apple camel</I
></TT
></B
>
Feeding apple to camel...

Will you read this sign?!  Don't feed the camels!

Done feeding.

Guard: "Buy the food that the Zoo provides at the entry, you ***"

Guard: "You want to poison them, do you?"

Leaving...
Thanks for visiting the Zoo, hope to see you again soon!

<TT
CLASS="prompt"
>michel ~/test&#62;</TT
> <B
CLASS="command"
>feed.sh <TT
CLASS="parameter"
><I
>apple</I
></TT
></B
>
Usage of the feed script:       ./feed.sh food-on-menu animal-name

</PRE
></FONT
></TD
></TR
></TABLE
><P
>More about escape characters can be found in <A
HREF="#sect_03_03_02"
>Section 3.3.2</A
>.  The following table gives an overview of sequences recognized by the <B
CLASS="command"
>echo</B
> command:</P
><DIV
CLASS="table"
><A
NAME="tab_08_01"
></A
><P
><B
>Table 8-1. Escape sequences used by the echo command</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
>Sequence</TH
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
>Meaning</TH
></TR
></THEAD
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>\a</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Alert (bell).</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>\b</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Backspace.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>\c</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Suppress trailing newline.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>\e</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Escape.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>\f</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Form feed.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>\n</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Newline.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>\r</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Carriage return.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>\t</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Horizontal tab.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>\v</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Vertical tab.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>\\</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Backslash.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>\0NNN</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>The eight-bit character whose value is the octal value NNN (zero to three octal digits).</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>\NNN</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>The eight-bit character whose value is the octal value NNN (one to three octal digits).</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>\xHH</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>The eight-bit character whose value is the hexadecimal value (one or two hexadecimal digits).</TD
></TR
></TBODY
></TABLE
></DIV
><P
>For more information about the <B
CLASS="command"
>printf</B
> command and the way it allows you to format output, see the Bash info pages.  Keep in mind that there might be differences between different versions of Bash.</P
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="sect_08_02"
></A
>8.2. Catching user input</H1
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="sect_08_02_01"
></A
>8.2.1. Using the read built-in command</H2
><P
>The <B
CLASS="command"
>read</B
> built-in command is the counterpart of the <B
CLASS="command"
>echo</B
> and <B
CLASS="command"
>printf</B
> commands.  The syntax of the <B
CLASS="command"
>read</B
> command is as follows:</P
><P
><B
CLASS="command"
>read <TT
CLASS="option"
>[options]</TT
> <TT
CLASS="varname"
>NAME1 NAME2 ... NAMEN</TT
></B
> </P
><P
>One line is read from the standard input, or from the file descriptor supplied as an argument to the <TT
CLASS="option"
>-u</TT
> option.  The first word of the line is assigned to the first name, <TT
CLASS="varname"
>NAME1</TT
>, the second word to the second name, and so on, with leftover words and their intervening separators assigned to the last name, <TT
CLASS="varname"
>NAMEN</TT
>.  If there are fewer words read from the input stream than there are names, the remaining names are assigned empty values.</P
><P
>The characters in the value of the <TT
CLASS="varname"
>IFS</TT
> variable are used to split the input line into words or tokens; see <A
HREF="#sect_03_04_07"
>Section 3.4.8</A
>.  The backslash character may be used to remove any special meaning for the next character read and for line continuation.</P
><P
>If no names are supplied, the line read is assigned to the variable <TT
CLASS="varname"
>REPLY</TT
>.</P
><P
>The return code of the <B
CLASS="command"
>read</B
> command is zero, unless an end-of-file character is encountered, if <B
CLASS="command"
>read</B
> times out or if an invalid file descriptor is supplied as the argument to the <TT
CLASS="option"
>-u</TT
> option.</P
><P
>The following options are supported by the Bash <B
CLASS="command"
>read</B
> built-in:</P
><DIV
CLASS="table"
><A
NAME="tab_08_02"
></A
><P
><B
>Table 8-2. Options to the read built-in</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
>Option</TH
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
>Meaning</TH
></TR
></THEAD
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>-a <TT
CLASS="varname"
>ANAME</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>The words are assigned to sequential indexes of the array variable <TT
CLASS="varname"
>ANAME</TT
>, starting at 0.  All elements are removed from <TT
CLASS="varname"
>ANAME</TT
> before the assignment.  Other <TT
CLASS="varname"
>NAME</TT
> arguments are ignored.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>-d <TT
CLASS="varname"
>DELIM</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>The first character of <TT
CLASS="varname"
>DELIM</TT
> is used to terminate the input line, rather than newline.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>-e</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>readline</B
> is used to obtain the line.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>-n <TT
CLASS="varname"
>NCHARS</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>read</B
> returns after reading <TT
CLASS="varname"
>NCHARS</TT
> characters rather than waiting for a complete line of input.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>-p <TT
CLASS="varname"
>PROMPT</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Display <TT
CLASS="varname"
>PROMPT</TT
>, without a trailing newline, before attempting to read any input.  The prompt is displayed only if input is coming from a terminal.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>-r</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>If this option is given, backslash does not act as an escape character.  The backslash is considered to be part of the line.  In particular, a backslash-newline pair may not be used as a line continuation.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>-s</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Silent mode.  If input is coming from a terminal, characters are not echoed.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>-t <TT
CLASS="varname"
>TIMEOUT</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Cause <B
CLASS="command"
>read</B
> to time out and return failure if a complete line of input is not read within <TT
CLASS="varname"
>TIMEOUT</TT
> seconds.  This option has no effect if <B
CLASS="command"
>read</B
> is not reading input from the terminal or from a pipe.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>-u <TT
CLASS="varname"
>FD</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Read input from file descriptor <TT
CLASS="varname"
>FD</TT
>.</TD
></TR
></TBODY
></TABLE
></DIV
><P
>This is a straightforward example, improving on the <TT
CLASS="filename"
>leaptest.sh</TT
> script from the previous chapter:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>michel ~/test&#62;</TT
> <B
CLASS="command"
>cat <TT
CLASS="filename"
>leaptest.sh</TT
></B
>
#!/bin/bash
# This script will test if you have given a leap year or not.

echo "Type the year that you want to check (4 digits), followed by [ENTER]:"

read year

if (( ("$year" % 400) == "0" )) || (( ("$year" % 4 == "0") &#38;&#38; ("$year" % 100 !=
"0") )); then
  echo "$year is a leap year."
else
  echo "This is not a leap year."
fi

<TT
CLASS="prompt"
>michel ~/test&#62;</TT
> <B
CLASS="command"
>leaptest.sh</B
>
Type the year that you want to check (4 digits), followed by [ENTER]:
2000
2000 is a leap year.
</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_08_02_02"
></A
>8.2.2. Prompting for user input</H2
><P
>The following example shows how you can use prompts to explain what the user should enter.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>michel ~/test&#62;</TT
> <B
CLASS="command"
>cat <TT
CLASS="filename"
>friends.sh</TT
></B
>
#!/bin/bash

# This is a program that keeps your address book up to date.

friends="/var/tmp/michel/friends"

echo "Hello, "$USER".  This script will register you in Michel's friends database."

echo -n "Enter your name and press [ENTER]: "
read name
echo -n "Enter your gender and press [ENTER]: "
read -n 1 gender
echo

grep -i "$name" "$friends"

if  [ $? == 0 ]; then
  echo "You are already registered, quitting."
  exit 1
elif [ "$gender" == "m" ]; then
  echo "You are added to Michel's friends list."
  exit 1
else
  echo -n "How old are you? "
  read age
  if [ $age -lt 25 ]; then
    echo -n "Which colour of hair do you have? "
    read colour
    echo "$name $age $colour" &#62;&#62; "$friends" 
    echo "You are added to Michel's friends list.  Thank you so much!"
  else
    echo "You are added to Michel's friends list."
    exit 1
  fi
fi

<TT
CLASS="prompt"
>michel ~/test&#62;</TT
> <B
CLASS="command"
>cp <TT
CLASS="filename"
>friends.sh /var/tmp</TT
>; cd <TT
CLASS="filename"
>/var/tmp</TT
></B
>

<TT
CLASS="prompt"
>michel ~/test&#62;</TT
> <B
CLASS="command"
>touch <TT
CLASS="filename"
>friends</TT
>; chmod <TT
CLASS="option"
>a+w</TT
> <TT
CLASS="filename"
>friends</TT
></B
>

<TT
CLASS="prompt"
>michel ~/test&#62;</TT
> <B
CLASS="command"
>friends.sh</B
>
Hello, michel.  This script will register you in Michel's friends database.
Enter your name and press [ENTER]: michel
Enter your gender and press [ENTER] :m
You are added to Michel's friends list.

<TT
CLASS="prompt"
>michel ~/test&#62;</TT
> <B
CLASS="command"
>cat <TT
CLASS="filename"
>friends</TT
></B
>

</PRE
></FONT
></TD
></TR
></TABLE
><P
>Note that no output is omitted here.  The script only stores information about the people Michel is interested in, but it will always say you are added to the list, unless you are already in it.</P
><P
>Other people can now start executing the script:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>[anny@octarine tmp]$</TT
> <B
CLASS="command"
>friends.sh</B
>
Hello, anny.  This script will register you in Michel's friends database.
Enter your name and press [ENTER]: anny
Enter your gender and press [ENTER] :f
How old are you? 22
Which colour of hair do you have? black
You are added to Michel's friends list.
</PRE
></FONT
></TD
></TR
></TABLE
><P
>After a while, the <TT
CLASS="filename"
>friends</TT
> list begins to look like this:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;tille 24 black
anny 22 black
katya 22 blonde
maria 21 black
--output omitted--
</PRE
></FONT
></TD
></TR
></TABLE
><P
>Of course, this situation is not ideal, since everybody can edit (but not delete) Michel's files.  You can solve this problem using special access modes on the script file, see <A
HREF="http://www.tldp.org/LDP/intro-linux/html/sect_04_01.html#sect_04_01_06"
TARGET="_top"
>SUID and SGID</A
> in the Introduction to Linux guide.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_08_02_03"
></A
>8.2.3. Redirection and file descriptors</H2
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="sect_08_02_03_01"
></A
>8.2.3.1. General</H3
><P
>As you know from basic shell usage, input and output of a command may be redirected before it is executed, using a special notation - the redirection operators - interpreted by the shell.  Redirection may also be used to open and close files for the current shell execution environment.</P
><P
>Redirection can also occur in a script, so that it can receive input from a file, for instance, or send output to a file.  Later, the user can review the output file, or it may be used by another script as input.</P
><P
>File input and output are accomplished by integer handles that track all open files for a given process.  These numeric values are known as file descriptors.  The best known file descriptors are <EM
>stdin</EM
>, <EM
>stdout</EM
> and <EM
>stderr</EM
>, with file descriptor numbers 0, 1 and 2, respectively.  These numbers and respective devices are reserved.  Bash can take TCP or UDP ports on networked hosts as file descriptors as well.</P
><P
>The output below shows how the reserved file descriptors point to actual devices:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>michel ~&#62;</TT
> <B
CLASS="command"
>ls <TT
CLASS="option"
>-l</TT
> <TT
CLASS="filename"
>/dev/std*</TT
></B
>
lrwxrwxrwx  1 root    root     17 Oct  2 07:46 /dev/stderr -&#62; ../proc/self/fd/2
lrwxrwxrwx  1 root    root     17 Oct  2 07:46 /dev/stdin -&#62; ../proc/self/fd/0
lrwxrwxrwx  1 root    root     17 Oct  2 07:46 /dev/stdout -&#62; ../proc/self/fd/1

<TT
CLASS="prompt"
>michel ~&#62;</TT
> <B
CLASS="command"
>ls <TT
CLASS="option"
>-l</TT
> <TT
CLASS="filename"
>/proc/self/fd/[0-2]</TT
></B
>
lrwx------  1 michel  michel   64 Jan 23 12:11 /proc/self/fd/0 -&#62; /dev/pts/6
lrwx------  1 michel  michel   64 Jan 23 12:11 /proc/self/fd/1 -&#62; /dev/pts/6
lrwx------  1 michel  michel   64 Jan 23 12:11 /proc/self/fd/2 -&#62; /dev/pts/6
</PRE
></FONT
></TD
></TR
></TABLE
><P
>Note that each process has its own view of the files under <TT
CLASS="filename"
>/proc/self</TT
>, as it is actually a symbolic link to <TT
CLASS="filename"
>/proc/&#60;process_ID&#62;</TT
>.</P
><P
>You might want to check <B
CLASS="command"
>info MAKEDEV</B
> and <B
CLASS="command"
>info proc</B
> for more information about <TT
CLASS="filename"
>/proc</TT
> subdirectories and the way your system handles standard file descriptors for each running process.</P
><P
>When excuting a given command, the following steps are excuted, in order:</P
><P
></P
><UL
><LI
><P
>If the standard output of a previous command is being piped to the standard input of the current command, then <TT
CLASS="filename"
>/proc/&#60;current_process_ID&#62;/fd/0</TT
> is updated to target the same anonymous pipe as <TT
CLASS="filename"
>/proc/&#60;previous_process_ID/fd/1</TT
>.</P
></LI
><LI
><P
>If the standard output of the current command is being piped to the standard input of the next command, then <TT
CLASS="filename"
>/proc/&#60;current_process_ID&#62;/fd/1</TT
> is updated to target another anonymous pipe.</P
></LI
><LI
><P
>Redirection for the current command is processed from left to right.</P
></LI
><LI
><P
>Redirection <SPAN
CLASS="QUOTE"
>"N&#62;&#38;M"</SPAN
> or <SPAN
CLASS="QUOTE"
>"N&#60;&#38;M"</SPAN
> after a command has the effect of creating or updating the symbolic link <TT
CLASS="filename"
>/proc/self/fd/N</TT
> with the same target as the symbolic link <TT
CLASS="filename"
>/proc/self/fd/M</TT
>.</P
></LI
><LI
><P
>The redirections <SPAN
CLASS="QUOTE"
>"N&#62; file"</SPAN
> and <SPAN
CLASS="QUOTE"
>"N&#60; file"</SPAN
> have the effect of creating or updating the symbolic link <TT
CLASS="filename"
>/proc/self/fd/N</TT
> with the target file.</P
></LI
><LI
><P
>File descriptor closure <SPAN
CLASS="QUOTE"
>"N&#62;&#38;-"</SPAN
> has the effect of deleting the symbolic link <TT
CLASS="filename"
>/proc/self/fd/N</TT
>.</P
></LI
><LI
><P
>Only now is the current command executed.</P
></LI
></UL
><P
>When you run a script from the command line, nothing much changes because the child shell process will use the same file descriptors as the parent.  When no such parent is available, for instance when you run a script using the <EM
>cron</EM
> facility, the standard file descriptors are pipes or other (temporary) files, unless some form of redirection is used.  This is demonstrated in the example below, which shows output from a simple <B
CLASS="command"
>at</B
> script:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>michel ~&#62;</TT
> <B
CLASS="command"
>date</B
>
Fri Jan 24 11:05:50 CET 2003

<TT
CLASS="prompt"
>michel ~&#62;</TT
> <B
CLASS="command"
>at <TT
CLASS="parameter"
><I
>1107</I
></TT
></B
>
warning: commands will be executed using (in order) 
a) $SHELL b) login shell c)/bin/sh
<TT
CLASS="prompt"
>at&#62;</TT
> <B
CLASS="command"
>ls <TT
CLASS="option"
>-l</TT
> <TT
CLASS="filename"
>/proc/self/fd/</TT
> &#62; <TT
CLASS="filename"
>/var/tmp/fdtest.at</TT
></B
>
<TT
CLASS="prompt"
>at&#62;</TT
> <B
CLASS="command"
>&#60;EOT&#62;</B
>
job 10 at 2003-01-24 11:07

<TT
CLASS="prompt"
>michel ~&#62;</TT
> <B
CLASS="command"
>cat <TT
CLASS="filename"
>/var/tmp/fdtest.at</TT
></B
>
total 0
lr-x------    1 michel michel  64 Jan 24 11:07 0 -&#62; /var/spool/at/!0000c010959eb (deleted)
l-wx------    1 michel michel  64 Jan 24 11:07 1 -&#62; /var/tmp/fdtest.at
l-wx------    1 michel michel  64 Jan 24 11:07 2 -&#62; /var/spool/at/spool/a0000c010959eb
lr-x------    1 michel michel  64 Jan 24 11:07 3 -&#62; /proc/21949/fd
</PRE
></FONT
></TD
></TR
></TABLE
><P
>And one with <B
CLASS="command"
>cron</B
>:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>michel ~&#62;</TT
> <B
CLASS="command"
>crontab <TT
CLASS="option"
>-l</TT
></B
>
# DO NOT EDIT THIS FILE - edit the master and reinstall.
# (/tmp/crontab.21968 installed on Fri Jan 24 11:30:41 2003)
# (Cron version -- $Id: chap8.xml,v 1.9 2006/09/28 09:42:45 tille Exp $)
32 11 * * * ls -l /proc/self/fd/ &#62; /var/tmp/fdtest.cron

<TT
CLASS="prompt"
>michel ~&#62;</TT
> <B
CLASS="command"
>cat <TT
CLASS="filename"
>/var/tmp/fdtest.cron</TT
></B
>
total 0
lr-x------    1 michel michel  64 Jan 24 11:32 0 -&#62; pipe:[124440]
l-wx------    1 michel michel  64 Jan 24 11:32 1 -&#62; /var/tmp/fdtest.cron
l-wx------    1 michel michel  64 Jan 24 11:32 2 -&#62; pipe:[124441]
lr-x------    1 michel michel  64 Jan 24 11:32 3 -&#62; /proc/21974/fd
</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="sect_08_02_03_02"
></A
>8.2.3.2. Redirection of errors</H3
><P
>From the previous examples, it is clear that you can provide input and output files for a script (see <A
HREF="#sect_08_02_04"
>Section 8.2.4</A
> for more), but some tend to forget about redirecting errors - output which might be depended upon later on.  Also, if you are lucky, errors will be mailed to you and eventual causes of failure might get revealed.  If you are not as lucky, errors will cause your script to fail and won't be caught or sent anywhere, so that you can't start to do any worthwhile debugging.</P
><P
>When redirecting errors, note that the order of precedence is significant.  For example, this command, issued in <TT
CLASS="filename"
>/var/spool</TT
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<B
CLASS="command"
>ls <TT
CLASS="option"
>-l</TT
> <TT
CLASS="filename"
>*</TT
> <TT
CLASS="parameter"
><I
>2</I
></TT
>&#62; <TT
CLASS="filename"
>/var/tmp/unaccessible-in-spool</TT
></B
>
</PRE
></FONT
></TD
></TR
></TABLE
><P
>will redirect standard output of the <B
CLASS="command"
>ls</B
> command to the file <TT
CLASS="filename"
>unaccessible-in-spool</TT
> in <TT
CLASS="filename"
>/var/tmp</TT
>.  The command</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<B
CLASS="command"
>ls <TT
CLASS="option"
>-l</TT
> <TT
CLASS="filename"
>*</TT
> &#62; <TT
CLASS="filename"
>/var/tmp/spoollist</TT
> <TT
CLASS="parameter"
><I
>2</I
></TT
>&#62;&#38;<TT
CLASS="parameter"
><I
>1</I
></TT
></B
>
</PRE
></FONT
></TD
></TR
></TABLE
><P
>will direct both standard input and standard error to the file <TT
CLASS="filename"
>spoollist</TT
>.  The command</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<B
CLASS="command"
>ls <TT
CLASS="option"
>-l</TT
> <TT
CLASS="filename"
>*</TT
> <TT
CLASS="parameter"
><I
>2</I
></TT
> &#62;&#38; <TT
CLASS="parameter"
><I
>1</I
></TT
> &#62; <TT
CLASS="filename"
>/var/tmp/spoollist</TT
></B
>
</PRE
></FONT
></TD
></TR
></TABLE
><P
>directs only the standard output to the destination file, because the standard error is copied to standard output before the standard output is redirected.</P
><P
>For convenience, errors are often redirected to <TT
CLASS="filename"
>/dev/null</TT
>, if it is sure they will not be needed.  Hundreds of examples can be found in the startup scripts for your system.</P
><P
>Bash allows for both standard output and standard error to be redirected to the file whose name is the result of the expansion of <TT
CLASS="filename"
>FILE</TT
> with this construct:</P
><P
><B
CLASS="command"
>&#38;&#62; <TT
CLASS="filename"
>FILE</TT
></B
> </P
><P
>This is the equivalent of <B
CLASS="command"
>&#62; <TT
CLASS="filename"
>FILE</TT
> 2&#62;&#38;1</B
>, the construct used in the previous set of examples.  It is also often combined with redirection to <TT
CLASS="filename"
>/dev/null</TT
>, for instance when you just want a command to execute, no matter what output or errors it gives.</P
></DIV
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_08_02_04"
></A
>8.2.4. File input and output</H2
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="sect_08_02_04_01"
></A
>8.2.4.1. Using /dev/fd</H3
><P
>The <TT
CLASS="filename"
>/dev/fd</TT
> directory contains entries named <TT
CLASS="filename"
>0</TT
>, <TT
CLASS="filename"
>1</TT
>, <TT
CLASS="filename"
>2</TT
>, and so on.  Opening the file <TT
CLASS="filename"
>/dev/fd/N</TT
> is equivalent to duplicating file descriptor <EM
>N</EM
>.  If your system provides <TT
CLASS="filename"
>/dev/stdin</TT
>, <TT
CLASS="filename"
>/dev/stdout</TT
> and <TT
CLASS="filename"
>/dev/stderr</TT
>, you will see that these are equivalent to <TT
CLASS="filename"
>/dev/fd/0</TT
>, <TT
CLASS="filename"
>/dev/fd/1</TT
> and <TT
CLASS="filename"
>/dev/fd/2</TT
>, respectively.</P
><P
>The main use of the <TT
CLASS="filename"
>/dev/fd</TT
> files is from the shell.  This mechanism allows for programs that use pathname arguments to handle standard input and standard output in the same way as other pathnames.  If <TT
CLASS="filename"
>/dev/fd</TT
> is not available on a system, you'll have to find a way to bypass the problem.  This can be done for instance using a hyphen (<EM
>-</EM
>) to indicate that a program should read from a pipe.  An example:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>michel ~&#62;</TT
> <B
CLASS="command"
>filter <TT
CLASS="filename"
>body.txt.gz</TT
> | cat <TT
CLASS="filename"
>header.txt</TT
> - <TT
CLASS="filename"
>footer.txt</TT
></B
>
This text is printed at the beginning of each print job and thanks the sysadmin
for setting us up such a great printing infrastructure.

Text to be filtered.

This text is printed at the end of each print job.
</PRE
></FONT
></TD
></TR
></TABLE
><P
>The <B
CLASS="command"
>cat</B
> command first reads the file <TT
CLASS="filename"
>header.txt</TT
>, next its standard input which is the output of the <B
CLASS="command"
>filter</B
> command, and last the <TT
CLASS="filename"
>footer.txt</TT
> file.  The special meaning of the hyphen as a command-line argument to refer to the standard input or standard output is a misconception that has crept into many programs.  There might also be problems when specifying hyphen as the first argument, since it might be interpreted as an option to the preceding command.  Using <TT
CLASS="filename"
>/dev/fd</TT
> allows for uniformity and prevents confusion:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>michel ~&#62;</TT
> <B
CLASS="command"
>filter <TT
CLASS="filename"
>body.txt</TT
> | cat <TT
CLASS="filename"
>header.txt /dev/fd/0 footer.txt</TT
> | lp</B
>
</PRE
></FONT
></TD
></TR
></TABLE
><P
>In this clean example, all output is additionally piped through <B
CLASS="command"
>lp</B
> to send it to the default printer.</P
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="sect_08_02_04_02"
></A
>8.2.4.2. Read and exec</H3
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
NAME="sect_08_02_04_02_01"
></A
>8.2.4.2.1. Assigning file descriptors to files</H4
><P
>Another way of looking at file descriptors is thinking of them as a way to assign a numeric value to a file.  Instead of using the file name, you can use the file descriptor number.  The <B
CLASS="command"
>exec</B
> built-in command can be used to replace the shell of the current process or to alter the file descriptors of the current shell.  For example, it can be used to assign a file descriptor to a file.  Use</P
><P
><B
CLASS="command"
>exec fdN&#62; <TT
CLASS="filename"
>file</TT
></B
> </P
><P
>for assigning file descriptor N to <TT
CLASS="filename"
>file</TT
> for output, and</P
><P
><B
CLASS="command"
>exec fdN&#60; <TT
CLASS="filename"
>file</TT
></B
> </P
><P
>for assigning file descriptor N to <TT
CLASS="filename"
>file</TT
> for input.  After a file descriptor has been assigned to a file, it can be used with the shell redirection operators, as is demonstrated in the following example:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>michel ~&#62;</TT
> <B
CLASS="command"
>exec <TT
CLASS="filename"
>4</TT
>&#62; <TT
CLASS="filename"
>result.txt</TT
></B
>

<TT
CLASS="prompt"
>michel ~&#62;</TT
> <B
CLASS="command"
>filter <TT
CLASS="filename"
>body.txt</TT
> | cat <TT
CLASS="filename"
>header.txt /dev/fd/0 footer.txt</TT
> &#62;&#38; <TT
CLASS="filename"
>4</TT
></B
>

<TT
CLASS="prompt"
>michel ~&#62;</TT
> <B
CLASS="command"
>cat <TT
CLASS="filename"
>result.txt</TT
></B
>
This text is printed at the beginning of each print job and thanks the sysadmin
for setting us up such a great printing infrastructure.

Text to be filtered.

This text is printed at the end of each print job.
</PRE
></FONT
></TD
></TR
></TABLE
><DIV
CLASS="note"
><P
></P
><TABLE
CLASS="note"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>File descriptor 5</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Using this file descriptor might cause problems, see <A
HREF="http://www.tldp.org/LDP/abs/html/io-redirection.html"
TARGET="_top"
>the Advanced Bash-Scripting Guide</A
>, chapter 16.  You are strongly advised not to use it.</P
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="sect4"
><HR><H4
CLASS="sect4"
><A
NAME="sect_08_02_04_02_02"
></A
>8.2.4.2.2. Read in scripts</H4
><P
>The following is an example that shows how you can alternate between file input and command line input:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>michel ~/testdir&#62;</TT
> <B
CLASS="command"
>cat <TT
CLASS="filename"
>sysnotes.sh</TT
></B
>
#!/bin/bash

# This script makes an index of important config files, puts them together in
# a backup file and allows for adding comment for each file.

CONFIG=/var/tmp/sysconfig.out
rm "$CONFIG" 2&#62;/dev/null

echo "Output will be saved in $CONFIG."

# create fd 7 with same target as fd 0 (save stdin "value")
exec 7&#60;&#38;0

# update fd 0 to target file /etc/passwd
exec &#60; /etc/passwd

# Read the first line of /etc/passwd
read rootpasswd

echo "Saving root account info..."
echo "Your root account info:" &#62;&#62; "$CONFIG"
echo $rootpasswd &#62;&#62; "$CONFIG"

# update fd 0 to target fd 7 target (old fd 0 target); delete fd 7
exec 0&#60;&#38;7 7&#60;&#38;-

echo -n "Enter comment or [ENTER] for no comment: "
read comment; echo $comment &#62;&#62; "$CONFIG"

echo "Saving hosts information..."

# first prepare a hosts file not containing any comments
TEMP="/var/tmp/hosts.tmp"
cat /etc/hosts | grep -v "^#" &#62; "$TEMP"

exec 7&#60;&#38;0
exec &#60; "$TEMP"

read ip1 name1 alias1
read ip2 name2 alias2

echo "Your local host configuration:" &#62;&#62; "$CONFIG"

echo "$ip1 $name1 $alias1" &#62;&#62; "$CONFIG"
echo "$ip2 $name2 $alias2" &#62;&#62; "$CONFIG"

exec 0&#60;&#38;7 7&#60;&#38;-

echo -n "Enter comment or [ENTER] for no comment: "
read comment; echo $comment &#62;&#62; "$CONFIG"
rm "$TEMP"

<TT
CLASS="prompt"
>michel ~/testdir&#62;</TT
> <B
CLASS="command"
>sysnotes.sh</B
>
Output will be saved in /var/tmp/sysconfig.out.
Saving root account info...
Enter comment or [ENTER] for no comment: hint for password: blue lagoon
Saving hosts information...
Enter comment or [ENTER] for no comment: in central DNS

<TT
CLASS="prompt"
>michel ~/testdir&#62;</TT
> <B
CLASS="command"
>cat <TT
CLASS="filename"
>/var/tmp/sysconfig.out</TT
></B
>
Your root account info:
root:x:0:0:root:/root:/bin/bash
hint for password: blue lagoon
Your local host configuration:
127.0.0.1 localhost.localdomain localhost
192.168.42.1 tintagel.kingarthur.com tintagel
in central DNS
</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="sect_08_02_04_03"
></A
>8.2.4.3. Closing file descriptors</H3
><P
>Since child processes inherit open file descriptors, it is good practice to close a file descriptor when it is no longer needed.  This is done using the</P
><P
><B
CLASS="command"
>exec fd&#60;&#38;-</B
> </P
><P
>syntax.  In the above example, file descriptor 7, which has been assigned to standard input, is closed each time the user needs to have access to the actual standard input device, usually the keyboard.</P
><P
>The following is a simple example redirecting only standard error to a pipe:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>michel ~&#62;</TT
> <B
CLASS="command"
>cat <TT
CLASS="filename"
>listdirs.sh</TT
></B
>
#!/bin/bash

# This script prints standard output unchanged, while standard error is 
# redirected for processing by awk.

INPUTDIR="$1"

# fd 6 targets fd 1 target (console out) in current shell
exec 6&#62;&#38;1

# fd 1 targets pipe, fd 2 targets fd 1 target (pipe),
# fd 1 targets fd 6 target (console out), fd 6 closed, execute ls
ls "$INPUTDIR"/* 2&#62;&#38;1 &#62;&#38;6 6&#62;&#38;- \
				# Closes fd 6 for awk, but not for ls.

| awk 'BEGIN { FS=":" } { print "YOU HAVE NO ACCESS TO" $2 }' 6&#62;&#38;-

# fd 6 closed for current shell
exec 6&#62;&#38;-
</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="sect_08_02_04_04"
></A
>8.2.4.4. <EM
>Here</EM
> documents</H3
><P
>Frequently, your script might call on another program or script that requires input.  The <EM
>here</EM
> document provides a way of instructing the shell to read input from the current source until a line containing only the search string is found (no trailing blanks).  All of the lines read up to that point are then used as the standard input for a command.</P
><P
>The result is that you don't need to call on separate files; you can use shell-special characters, and it looks nicer than a bunch of <B
CLASS="command"
>echo</B
>'s:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>michel ~&#62;</TT
> <B
CLASS="command"
>cat <TT
CLASS="filename"
>startsurf.sh</TT
></B
>
#!/bin/bash

# This script provides an easy way for users to choose between browsers.

echo "These are the web browsers on this system:"
 
# Start here document
cat &#60;&#60; BROWSERS
mozilla
links
lynx
konqueror
opera
netscape
BROWSERS
# End here document

echo -n "Which is your favorite? "
read browser

echo "Starting $browser, please wait..."
$browser &#38;

<TT
CLASS="prompt"
>michel ~&#62;</TT
> <B
CLASS="command"
>startsurf.sh</B
>
These are the web browsers on this system:
mozilla
links
lynx
konqueror
opera
netscape
<TT
CLASS="prompt"
>Which is your favorite?</TT
> <B
CLASS="command"
>opera</B
>
Starting opera, please wait...
</PRE
></FONT
></TD
></TR
></TABLE
><P
>Although we talk about a <EM
>here document</EM
>, it is supposed to be a construct within the same script.  This is an example that installs a package automatically, eventhough you should normally confirm:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;#!/bin/bash
 
# This script installs packages automatically, using yum.
 
if [ $# -lt 1 ]; then
        echo "Usage: $0 package."
        exit 1
fi
 
yum install $1 &#60;&#60; CONFIRM
y
CONFIRM
</PRE
></FONT
></TD
></TR
></TABLE
><P
>And this is how the script runs.  When prompted with the <SPAN
CLASS="QUOTE"
>"Is this ok [y/N]"</SPAN
> string, the script answers <SPAN
CLASS="QUOTE"
>"y"</SPAN
> automatically:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>[root@picon bin]#</TT
> <B
CLASS="command"
>./install.sh <TT
CLASS="parameter"
><I
>tuxracer</I
></TT
></B
>
Gathering header information file(s) from server(s)
Server: Fedora Linux 2 - i386 - core
Server: Fedora Linux 2 - i386 - freshrpms
Server: JPackage 1.5 for Fedora Core 2
Server: JPackage 1.5, generic
Server: Fedora Linux 2 - i386 - updates
Finding updated packages
Downloading needed headers
Resolving dependencies
Dependencies resolved
I will do the following:
[install: tuxracer 0.61-26.i386]
<TT
CLASS="prompt"
>Is this ok [y/N]:</TT
> <B
CLASS="command"
><B
CLASS="keycap"
>Enter</B
></B
>Downloading Packages
Running test transaction:
Test transaction complete, Success!
tuxracer 100 % done 1/1
Installed:  tuxracer 0.61-26.i386
Transaction(s) Complete
</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="sect_08_03"
></A
>8.3. Summary</H1
><P
>In this chapter, we learned how to provide user comments and how to prompt for user input.  This is usually done using the <B
CLASS="command"
>echo</B
>/<B
CLASS="command"
>read</B
> combination.  We also discussed how files can be used as input and output using file descriptors and redirection, and how this can be combined with getting input from the user.</P
><P
>We stressed the importance of providing ample message for the users of our scripts.  As always when others use your scripts, it is better to give too much information than not enough.  <EM
>Here</EM
> documents is a type of shell construct that allows creation of lists, holding choices for the users.  This construct can also be used to execute otherwise interactive tasks in the background, without intervention.</P
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="sect_08_04"
></A
>8.4. Exercises</H1
><P
>These exercises are practical applications of the constructs discussed in this chapter.  When writing the scripts, you may test by using a test directory that does not contain too much data.  Write each step, then test that portion of code, rather than writing everything at once.</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Write a script that asks for the user's age.  If it is equal to or higher than 16, print a message saying that this user is allowed to drink alcohol.  If the user's age is below 16, print a message telling the user how many years he or she has to wait before legally being allowed to drink.</P
><P
>As an extra, calculate how much beer an 18+ user has drunk statistically (100 liters/year) and print this information for the user.</P
></LI
><LI
><P
>Write a script that takes one file as an argument.  Use a <EM
>here</EM
> document that presents the user with a couple of choices for compressing the file.  Possible choices could be <B
CLASS="command"
>gzip</B
>, <B
CLASS="command"
>bzip2</B
>, <B
CLASS="command"
>compress</B
> and <B
CLASS="command"
>zip</B
>. </P
></LI
><LI
><P
>Write a script called <TT
CLASS="filename"
>homebackup</TT
> that automates <B
CLASS="command"
>tar</B
> so the person executing the script always uses the desired options (<TT
CLASS="option"
>cvp</TT
>) and backup destination directory (<TT
CLASS="filename"
>/var/backups</TT
>) to make a backup of his or her home directory.  Implement the following features:</P
><P
></P
><UL
><LI
><P
>Test for the number of arguments.  The script should run without arguments.  If any arguments are present, exit after printing a usage message.</P
></LI
><LI
><P
>Determine whether the <TT
CLASS="filename"
>backups</TT
> directory has enough free space to hold the backup.</P
></LI
><LI
><P
>Ask the user whether a full or an incremental backup is wanted.  If the user does not have a full backup file yet, print a message that a full backup will be taken.  In case of an incremental backup, only do this if the full backup is not older than a week.</P
></LI
><LI
><P
>Compress the backup using any compression tool.  Inform the user that the script is doing this, because it might take some time, during which the user might start worrying if no output appears on the screen.</P
></LI
><LI
><P
>Print a message informing the user about the size of the compressed backup.</P
></LI
></UL
><P
>See <B
CLASS="command"
>info tar</B
> or <A
HREF="http://tille.garrels.be/training/tldp/c4540.html#sect_09_01_01"
TARGET="_top"
>Introduction to Linux</A
>, chapter 9: <SPAN
CLASS="QUOTE"
>"Preparing your data"</SPAN
> for background information.</P
></LI
><LI
><P
>Write a script called <TT
CLASS="filename"
>simple-useradd.sh</TT
> that adds a local user to the system.  This script should:</P
><P
></P
><UL
><LI
><P
>Take only one argument, or else exit after printing a usage message.</P
></LI
><LI
><P
>Check <TT
CLASS="filename"
>/etc/passwd</TT
> and decide on the first free user ID.  Print a message containing this ID.</P
></LI
><LI
><P
>Create a private group for this user, checking the <TT
CLASS="filename"
>/etc/group</TT
> file.  Print a message containing the group ID.</P
></LI
><LI
><P
>Gather information from the operator user: a comment describing this user, choice from a list of shells (test for acceptability, else exit printing a message), expiration date for this account, extra groups of which the new user should be a member.</P
></LI
><LI
><P
>With the obtained information, add a line to <TT
CLASS="filename"
>/etc/passwd</TT
>, <TT
CLASS="filename"
>/etc/group</TT
> and <TT
CLASS="filename"
>/etc/shadow</TT
>; create the user's home directory (with correct permissions!); add the user to the desired secondary groups.</P
></LI
><LI
><P
>Set the password for this user to a default known string.</P
></LI
></UL
></LI
><LI
><P
>Rewrite the script from <A
HREF="#sect_07_02_01_04"
>Section 7.2.1.4</A
> so that it reads input from the user instead of taking it from the first argument.</P
></LI
></OL
></DIV
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="chap_09"
></A
>Chapter 9. Repetitive tasks</H1
><BLOCKQUOTE
CLASS="ABSTRACT"
><DIV
CLASS="abstract"
><A
NAME="AEN5864"
></A
><P
></P
><P
>Upon completion of this chapter, you will be able to</P
><P
>&#13;<P
></P
><UL
><LI
><P
>Use <B
CLASS="command"
>for</B
>, <B
CLASS="command"
>while</B
> and <B
CLASS="command"
>until</B
> loops, and decide which loop fits which occasion.</P
></LI
><LI
><P
>Use the <B
CLASS="command"
>break</B
> and <B
CLASS="command"
>continue</B
> Bash built-ins.</P
></LI
><LI
><P
>Write scripts using the <B
CLASS="command"
>select</B
> statement.</P
></LI
><LI
><P
>Write scripts that take a variable number of arguments.</P
></LI
></UL
></P
><P
></P
></DIV
></BLOCKQUOTE
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="sect_09_01"
></A
>9.1. The for loop</H1
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="sect_09_01_01"
></A
>9.1.1. How does it work?</H2
><P
>The <B
CLASS="command"
>for</B
> loop is the first of the three shell looping constructs.  This loop allows for specification of a list of values.  A list of commands is executed for each value in the list.</P
><P
>The syntax for this loop is:</P
><P
><B
CLASS="command"
>for <TT
CLASS="varname"
>NAME</TT
> [in LIST ]; do COMMANDS; done</B
> </P
><P
>If <B
CLASS="command"
>[in LIST]</B
> is not present, it is replaced with <B
CLASS="command"
>in <TT
CLASS="varname"
>$@</TT
></B
> and <B
CLASS="command"
>for</B
> executes the <B
CLASS="command"
>COMMANDS</B
> once for each positional parameter that is set (see <A
HREF="#sect_03_02_05"
>Section 3.2.5</A
> and <A
HREF="#sect_07_02_01_02"
>Section 7.2.1.2</A
>).</P
><P
>The return status is the exit status of the last command that executes.  If no commands are executed because <TT
CLASS="varname"
>LIST</TT
> does not expand to any items, the return status is zero.</P
><P
><TT
CLASS="varname"
>NAME</TT
> can be any variable name, although <TT
CLASS="varname"
>i</TT
> is used very often.  <TT
CLASS="varname"
>LIST</TT
> can be any list of words, strings or numbers, which can be literal or generated by any command.  The <B
CLASS="command"
>COMMANDS</B
> to execute can also be any operating system commands, script, program or shell statement.  The first time through the loop, <TT
CLASS="varname"
>NAME</TT
> is set to the first item in <TT
CLASS="varname"
>LIST</TT
>.  The second time, its value is set to the second item in the list, and so on.  The loop terminates when <TT
CLASS="varname"
>NAME</TT
> has taken on each of the values from <TT
CLASS="varname"
>LIST</TT
> and no items are left in <TT
CLASS="varname"
>LIST</TT
>.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_09_01_02"
></A
>9.1.2. Examples</H2
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="sect_09_01_02_03"
></A
>9.1.2.1. Using command substitution for specifying LIST items</H3
><P
>The first is a command line example, demonstrating the use of a <B
CLASS="command"
>for</B
> loop that makes a backup copy of each <TT
CLASS="filename"
>.xml</TT
> file.  After issuing the command, it is safe to start working on your sources:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>[carol@octarine ~/articles]</TT
> <B
CLASS="command"
>ls <TT
CLASS="filename"
>*.xml</TT
></B
>
file1.xml  file2.xml  file3.xml

<TT
CLASS="prompt"
>[carol@octarine ~/articles]</TT
> <B
CLASS="command"
>ls <TT
CLASS="filename"
>*.xml</TT
> &#62; <TT
CLASS="filename"
>list</TT
></B
>

<TT
CLASS="prompt"
>[carol@octarine ~/articles]</TT
> <B
CLASS="command"
>for <TT
CLASS="varname"
>i</TT
> in <TT
CLASS="parameter"
><I
>`cat list`</I
></TT
>; do cp <TT
CLASS="filename"
>"$i" "$i".bak</TT
> ; done</B
>

<TT
CLASS="prompt"
>[carol@octarine ~/articles]</TT
> <B
CLASS="command"
>ls <TT
CLASS="filename"
>*.xml*</TT
></B
>
file1.xml  file1.xml.bak  file2.xml  file2.xml.bak  file3.xml  file3.xml.bak
</PRE
></FONT
></TD
></TR
></TABLE
><P
>This one lists the files in <TT
CLASS="filename"
>/sbin</TT
> that are just plain text files, and possibly scripts:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<B
CLASS="command"
>for <TT
CLASS="varname"
>i</TT
> in <TT
CLASS="parameter"
><I
>`ls /sbin`</I
></TT
>; do file <TT
CLASS="filename"
>/sbin/$i</TT
> | grep <TT
CLASS="parameter"
><I
>ASCII</I
></TT
>; done</B
>
</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="sect_09_01_02_02"
></A
>9.1.2.2. Using the content of a variable to specify LIST items</H3
><P
>The following is a specific application script for converting HTML files, compliant with a certain scheme, to PHP files.  The conversion is done by taking out the first 25 and the last 21 lines, replacing these with two PHP tags that provide header and footer lines:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>[carol@octarine ~/html]</TT
> <B
CLASS="command"
>cat <TT
CLASS="filename"
>html2php.sh</TT
></B
>
#!/bin/bash
# specific conversion script for my html files to php
LIST="$(ls *.html)"
for i in "$LIST"; do
     NEWNAME=$(ls "$i" | sed -e 's/html/php/')
     cat beginfile &#62; "$NEWNAME"
     cat "$i" | sed -e '1,25d' | tac | sed -e '1,21d'| tac &#62;&#62; "$NEWNAME"
     cat endfile &#62;&#62; "$NEWNAME"
done
</PRE
></FONT
></TD
></TR
></TABLE
><P
>Since we don't do a line count here, there is no way of knowing the line number from which to start deleting lines until reaching the end.  The problem is solved using <B
CLASS="command"
>tac</B
>, which reverses the lines in a file.</P
><DIV
CLASS="tip"
><P
></P
><TABLE
CLASS="tip"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="images/tip.gif"
HSPACE="5"
ALT="Tip"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>The basename command</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Instead of using <B
CLASS="command"
>sed</B
> to replace the <TT
CLASS="filename"
>html</TT
> suffix with <TT
CLASS="filename"
>php</TT
>, it would be cleaner to use the <B
CLASS="command"
>basename</B
> command.  Read the man page for more info.</P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="warning"
><P
></P
><TABLE
CLASS="warning"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="images/warning.gif"
HSPACE="5"
ALT="Warning"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>Odd characters</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>You will run into problems if the list expands to file names containing spaces and other irregular characters.  A more ideal construct to obtain the list would be to use the shell's globbing feature, like this:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;for i in $PATHNAME/*; do
	commands
done
</PRE
></FONT
></TD
></TR
></TABLE
></TD
></TR
></TABLE
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="sect_09_02"
></A
>9.2. The while loop</H1
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="sect_09_02_01"
></A
>9.2.1. What is it?</H2
><P
>The <B
CLASS="command"
>while</B
> construct allows for repetitive execution of a list of commands, as long as the command controlling the <B
CLASS="command"
>while</B
> loop executes successfully (exit status of zero).  The syntax is:</P
><P
><B
CLASS="command"
>while CONTROL-COMMAND; do CONSEQUENT-COMMANDS; done</B
> </P
><P
><B
CLASS="command"
>CONTROL-COMMAND</B
> can be any command(s) that can exit with a success or failure status.  The <B
CLASS="command"
>CONSEQUENT-COMMANDS</B
> can be any program, script or shell construct.</P
><P
>As soon as the <B
CLASS="command"
>CONTROL-COMMAND</B
> fails, the loop exits.  In a script, the command following the <B
CLASS="command"
>done</B
> statement is executed.</P
><P
>The return status is the exit status of the last <B
CLASS="command"
>CONSEQUENT-COMMANDS</B
> command, or zero if none was executed.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_09_02_02"
></A
>9.2.2. Examples</H2
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="sect_09_02_02_01"
></A
>9.2.2.1. Simple example using while</H3
><P
>Here is an example for the impatient:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;#!/bin/bash

# This script opens 4 terminal windows.

i="0"

while [ $i -lt 4 ]
do
xterm &#38;
i=$[$i+1]
done
</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="sect_09_02_02_02"
></A
>9.2.2.2. Nested while loops</H3
><P
>The example below was written to copy pictures that are made with a webcam to a web directory.  Every five minutes a picture is taken.  Every hour, a new directory is created, holding the images for that hour.  Every day, a new directory is created containing 24 subdirectories.  The script runs in the background.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;#!/bin/bash

# This script copies files from my homedirectory into the webserver directory.
# (use scp and SSH keys for a remote directory)
# A new directory is created every hour.

PICSDIR=/home/carol/pics
WEBDIR=/var/www/carol/webcam

while true; do 
	DATE=`date +%Y%m%d`
	HOUR=`date +%H`
	mkdir $WEBDIR/"$DATE"
	
	while [ $HOUR -ne "00" ]; do 
		DESTDIR=$WEBDIR/"$DATE"/"$HOUR"
		mkdir "$DESTDIR"
		mv $PICDIR/*.jpg "$DESTDIR"/
		sleep 3600
		HOUR=`date +%H`
	done
done
</PRE
></FONT
></TD
></TR
></TABLE
><P
>Note the use of the <B
CLASS="command"
>true</B
> statement.  This means: continue execution until we are forcibly interrupted (with <B
CLASS="command"
>kill</B
> or <B
CLASS="keycap"
>Ctrl</B
>+<B
CLASS="keycap"
>C</B
>).</P
><P
>This small script can be used for simulation testing; it generates files:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;#!/bin/bash

# This generates a file every 5 minutes

while true; do
touch pic-`date +%s`.jpg
sleep 300
done
</PRE
></FONT
></TD
></TR
></TABLE
><P
>Note the use of the <B
CLASS="command"
>date</B
> command to generate all kinds of file and directory names.  See the man page for more.</P
><DIV
CLASS="note"
><P
></P
><TABLE
CLASS="note"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>Use the system</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The previous example is for the sake of demonstration.  Regular checks can easily be achieved using the system's <EM
>cron</EM
> facility.  Do not forget to redirect output and errors when using scripts that are executed from your crontab!</P
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="sect_09_02_02_03"
></A
>9.2.2.3. Using keyboard input to control the while loop</H3
><P
>This script can be interrupted by the user when a <B
CLASS="keycap"
>Ctrl</B
>+<B
CLASS="keycap"
>C</B
> sequence is entered:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;#!/bin/bash

# This script provides wisdom

FORTUNE=/usr/games/fortune

while true; do
echo "On which topic do you want advice?"
cat &#60;&#60; topics
politics
startrek
kernelnewbies
sports
bofh-excuses
magic
love
literature
drugs
education
topics

echo
echo -n "Make your choice: "
read topic
echo
echo "Free advice on the topic of $topic: "
echo
$FORTUNE $topic
echo

done
</PRE
></FONT
></TD
></TR
></TABLE
><P
>A <EM
>here</EM
> document is used to present the user with possible choices.  And again, the <B
CLASS="command"
>true</B
> test repeats the commands from the <B
CLASS="command"
>CONSEQUENT-COMMANDS</B
> list over and over again.</P
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="sect_09_02_02_04"
></A
>9.2.2.4. Calculating an average</H3
><P
>This script calculates the average of user input, which is tested before it is processed: if input is not within range, a message is printed.  If <B
CLASS="keycap"
>q</B
> is pressed, the loop exits:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;#!/bin/bash

# Calculate the average of a series of numbers.

SCORE="0"
AVERAGE="0"
SUM="0"
NUM="0"

while true; do

  echo -n "Enter your score [0-100%] ('q' for quit): "; read SCORE;

  if (("$SCORE" &#60; "0"))  || (("$SCORE" &#62; "100")); then
    echo "Be serious.  Common, try again: "
  elif [ "$SCORE" == "q" ]; then
    echo "Average rating: $AVERAGE%."
    break
  else
    SUM=$[$SUM + $SCORE]
    NUM=$[$NUM + 1]
    AVERAGE=$[$SUM / $NUM]
  fi

done

echo "Exiting."
</PRE
></FONT
></TD
></TR
></TABLE
><P
>Note how the variables in the last lines are left unquoted in order to do arithmetic.</P
></DIV
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="sect_09_03"
></A
>9.3. The until loop</H1
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="sect_09_03_01"
></A
>9.3.1. What is it?</H2
><P
>The <B
CLASS="command"
>until</B
> loop is very similar to the <B
CLASS="command"
>while</B
> loop, except that the loop executes until the <B
CLASS="command"
>TEST-COMMAND</B
> executes successfully.  As long as this command fails, the loop continues.  The syntax is the same as for the <B
CLASS="command"
>while</B
> loop:</P
><P
><B
CLASS="command"
>until TEST-COMMAND; do CONSEQUENT-COMMANDS; done</B
> </P
><P
>The return status is the exit status of the last command executed in the <B
CLASS="command"
>CONSEQUENT-COMMANDS</B
> list, or zero if none was executed.  <B
CLASS="command"
>TEST-COMMAND</B
> can, again, be any command that can exit with a success or failure status, and <B
CLASS="command"
>CONSEQUENT-COMMANDS</B
> can be any UNIX command, script or shell construct.</P
><P
>As we already explained previously, the <SPAN
CLASS="QUOTE"
>";"</SPAN
> may be replaced with one or more newlines wherever it appears.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_09_03_02"
></A
>9.3.2. Example</H2
><P
>An improved <TT
CLASS="filename"
>picturesort.sh</TT
> script (see <A
HREF="#sect_09_02_02_02"
>Section 9.2.2.2</A
>), which tests for available disk space.  If not enough disk space is available, remove pictures from the previous months:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;#!/bin/bash

# This script copies files from my homedirectory into the webserver directory.
# A new directory is created every hour.
# If the pics are taking up too much space, the oldest are removed.

while true; do 
	DISKFUL=$(df -h $WEBDIR | grep -v File | awk '{print $5 }' | cut -d "%" -f1 -)

	until [ $DISKFUL -ge "90" ]; do 

        	DATE=`date +%Y%m%d`
        	HOUR=`date +%H`
        	mkdir $WEBDIR/"$DATE"
                                                                                
        	while [ $HOUR -ne "00" ]; do
                	DESTDIR=$WEBDIR/"$DATE"/"$HOUR"
                	mkdir "$DESTDIR"
                	mv $PICDIR/*.jpg "$DESTDIR"/
                	sleep 3600
                	HOUR=`date +%H`
        	done

	DISKFULL=$(df -h $WEBDIR | grep -v File | awk '{ print $5 }' | cut -d "%" -f1 -)
	done

	TOREMOVE=$(find $WEBDIR -type d -a -mtime +30)
	for i in $TOREMOVE; do
		rm -rf "$i";
	done

done
</PRE
></FONT
></TD
></TR
></TABLE
><P
>Note the initialization of the <TT
CLASS="varname"
>HOUR</TT
> and <TT
CLASS="varname"
>DISKFULL</TT
> variables and the use of options with <B
CLASS="command"
>ls</B
> and <B
CLASS="command"
>date</B
> in order to obtain a correct listing for <TT
CLASS="varname"
>TOREMOVE</TT
>.</P
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="sect_09_04"
></A
>9.4. I/O redirection and loops</H1
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="sect_09_04_01"
></A
>9.4.1. Input redirection</H2
><P
>Instead of controlling a loop by testing the result of a command or by user input, you can specify a file from which to read input that controls the loop.  In such cases, <B
CLASS="command"
>read</B
> is often the controlling command.  As long as input lines are fed into the loop, execution of the loop commands continues.  As soon as all the input lines are read the loop exits.</P
><P
>Since the loop construct is considered to be one command structure (such as <B
CLASS="command"
>while TEST-COMMAND; do CONSEQUENT-COMMANDS; done</B
>), the redirection should occur after the <B
CLASS="command"
>done</B
> statement, so that it complies with the form</P
><P
><B
CLASS="command"
>command &#60; <TT
CLASS="filename"
>file</TT
></B
> </P
><P
>This kind of redirection also works with other kinds of loops.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_09_04_02"
></A
>9.4.2. Output redirection</H2
><P
>In the example below, output of the <B
CLASS="command"
>find</B
> command is used as input for the <B
CLASS="command"
>read</B
> command controlling a <B
CLASS="command"
>while</B
> loop:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>[carol@octarine ~/testdir]</TT
> <B
CLASS="command"
>cat <TT
CLASS="filename"
>archiveoldstuff.sh</TT
></B
>
#!/bin/bash

# This script creates a subdirectory in the current directory, to which old
# files are moved.
# Might be something for cron (if slightly adapted) to execute weekly or 
# monthly.

ARCHIVENR=`date +%Y%m%d`
DESTDIR="$PWD/archive-$ARCHIVENR"

mkdir "$DESTDIR"

# using quotes to catch file names containing spaces, using read -d for more 
# fool-proof usage:
find "$PWD" -type f -a -mtime +5 | while read -d $'\000' file

do
gzip "$file"; mv "$file".gz "$DESTDIR"
echo "$file archived"
done
</PRE
></FONT
></TD
></TR
></TABLE
><P
>Files are compressed before they are moved into the archive directory.</P
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="sect_09_05"
></A
>9.5. Break and continue</H1
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="sect_09_05_01"
></A
>9.5.1. The break built-in</H2
><P
>The <B
CLASS="command"
>break</B
> statement is used to exit the current loop before its normal ending.  This is done when you don't know in advance how many times the loop will have to execute, for instance because it is dependent on user input.</P
><P
>The example below demonstrates a <B
CLASS="command"
>while</B
> loop that can be interrupted.  This is a slightly improved version of the <TT
CLASS="filename"
>wisdom.sh</TT
> script from <A
HREF="#sect_09_02_02_03"
>Section 9.2.2.3</A
>.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;#!/bin/bash

# This script provides wisdom
# You can now exit in a decent way.

FORTUNE=/usr/games/fortune

while true; do
echo "On which topic do you want advice?"
echo "1.  politics"
echo "2.  startrek"
echo "3.  kernelnewbies"
echo "4.  sports"
echo "5.  bofh-excuses"
echo "6.  magic"
echo "7.  love"
echo "8.  literature"
echo "9.  drugs"
echo "10. education"
echo

echo -n "Enter your choice, or 0 for exit: "
read choice
echo

case $choice in
     1)
     $FORTUNE politics
     ;;
     2)
     $FORTUNE startrek
     ;;
     3)
     $FORTUNE kernelnewbies
     ;;
     4)
     echo "Sports are a waste of time, energy and money."
     echo "Go back to your keyboard."
     echo -e "\t\t\t\t -- \"Unhealthy is my middle name\" Soggie."
     ;;
     5)
     $FORTUNE bofh-excuses
     ;;
     6)
     $FORTUNE magic
     ;;
     7)
     $FORTUNE love
     ;;
     8)
     $FORTUNE literature
     ;;
     9)
     $FORTUNE drugs
     ;;
     10)
     $FORTUNE education
     ;;
     0)
     echo "OK, see you!"
     break
     ;;
     *)
     echo "That is not a valid choice, try a number from 0 to 10."
     ;;
esac  
done
</PRE
></FONT
></TD
></TR
></TABLE
><P
>Mind that <B
CLASS="command"
>break</B
> exits the loop, not the script.  This can be demonstrated by adding an <B
CLASS="command"
>echo</B
> command at the end of the script.  This <B
CLASS="command"
>echo</B
> will also be executed upon input that causes <B
CLASS="command"
>break</B
> to be executed (when the user types <SPAN
CLASS="QUOTE"
>"0"</SPAN
>).</P
><P
>In nested loops, <B
CLASS="command"
>break</B
> allows for specification of which loop to exit.  See the Bash <B
CLASS="command"
>info</B
> pages for more.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_09_05_02"
></A
>9.5.2. The continue built-in</H2
><P
>The <B
CLASS="command"
>continue</B
> statement resumes iteration of an enclosing <B
CLASS="command"
>for</B
>, <B
CLASS="command"
>while</B
>, <B
CLASS="command"
>until</B
> or <B
CLASS="command"
>select</B
> loop.</P
><P
>When used in a <B
CLASS="command"
>for</B
> loop, the controlling variable takes on the value of the next element in the list.  When used in a <B
CLASS="command"
>while</B
> or <B
CLASS="command"
>until</B
> construct, on the other hand, execution resumes with <B
CLASS="command"
>TEST-COMMAND</B
> at the top of the loop.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_09_05_03"
></A
>9.5.3. Examples</H2
><P
>In the following example, file names are converted to lower case.  If no conversion needs to be done, a <B
CLASS="command"
>continue</B
> statement restarts execution of the loop.  These commands don't eat much system resources, and most likely, similar problems can be solved using <B
CLASS="command"
>sed</B
> and <B
CLASS="command"
>awk</B
>.  However, it is useful to know about this kind of construction when executing heavy jobs, that might not even be necessary when tests are inserted at the correct locations in a script, sparing system resources.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>[carol@octarine ~/test]</TT
> <B
CLASS="command"
>cat <TT
CLASS="filename"
>tolower.sh</TT
></B
>
#!/bin/bash

# This script converts all file names containing upper case characters into file# names containing only lower cases.

LIST="$(ls)"

for name in "$LIST"; do

if [[ "$name" != *[[:upper:]]* ]]; then
continue
fi

ORIG="$name"
NEW=`echo $name | tr 'A-Z' 'a-z'`

mv "$ORIG" "$NEW"
echo "new name for $ORIG is $NEW"
done
</PRE
></FONT
></TD
></TR
></TABLE
><P
>This script has at least one disadvantage: it overwrites existing files.  The <TT
CLASS="option"
>noclobber</TT
> option to Bash is only useful when redirection occurs.  The <TT
CLASS="option"
>-b</TT
> option to the <B
CLASS="command"
>mv</B
> command provides more security, but is only safe in case of one accidental overwrite, as is demonstrated in this test:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>[carol@octarine ~/test]</TT
> <B
CLASS="command"
>rm <TT
CLASS="filename"
>*</TT
></B
>

<TT
CLASS="prompt"
>[carol@octarine ~/test]</TT
> <B
CLASS="command"
>touch <TT
CLASS="filename"
>test Test TEST</TT
></B
>

<TT
CLASS="prompt"
>[carol@octarine ~/test]</TT
> <B
CLASS="command"
>bash <TT
CLASS="option"
>-x</TT
> <TT
CLASS="filename"
>tolower.sh</TT
></B
>
++ ls
+ LIST=test
Test
TEST
+ [[ test != *[[:upper:]]* ]]
+ continue
+ [[ Test != *[[:upper:]]* ]]
+ ORIG=Test
++ echo Test
++ tr A-Z a-z
+ NEW=test
+ mv -b Test test
+ echo 'new name for Test is test'
new name for Test is test
+ [[ TEST != *[[:upper:]]* ]]
+ ORIG=TEST
++ echo TEST
++ tr A-Z a-z
+ NEW=test
+ mv -b TEST test
+ echo 'new name for TEST is test'
new name for TEST is test

<TT
CLASS="prompt"
>[carol@octarine ~/test]</TT
> <B
CLASS="command"
>ls <TT
CLASS="option"
>-a</TT
></B
>
./  ../  test  test~
</PRE
></FONT
></TD
></TR
></TABLE
><P
>The <B
CLASS="command"
>tr</B
> is part of the <EM
>textutils</EM
> package; it can perform all kinds of character transformations.</P
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="sect_09_06"
></A
>9.6. Making menus with the select built-in</H1
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="sect_09_06_01"
></A
>9.6.1. General</H2
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="sect_09_06_01_01"
></A
>9.6.1.1. Use of select</H3
><P
>The <B
CLASS="command"
>select</B
> construct allows easy menu generation.  The syntax is quite similar to that of the <B
CLASS="command"
>for</B
> loop:</P
><P
><B
CLASS="command"
>select <TT
CLASS="varname"
>WORD</TT
> [in <TT
CLASS="varname"
>LIST</TT
>]; do RESPECTIVE-COMMANDS; done</B
> </P
><P
><TT
CLASS="varname"
>LIST</TT
> is expanded, generating a list of items.  The expansion is printed to standard error; each item is preceded by a number.  If <B
CLASS="command"
>in <TT
CLASS="varname"
>LIST</TT
></B
> is not present, the positional parameters are printed, as if <B
CLASS="command"
>in <TT
CLASS="varname"
>$@</TT
></B
> would have been specified.  <TT
CLASS="varname"
>LIST</TT
> is only printed once.</P
><P
>Upon printing all the items, the <TT
CLASS="varname"
>PS3</TT
> prompt is printed and one line from standard input is read.  If this line consists of a number corresponding to one of the items, the value of <TT
CLASS="varname"
>WORD</TT
> is set to the name of that item.  If the line is empty, the items and the <TT
CLASS="varname"
>PS3</TT
> prompt are displayed again.  If an <EM
>EOF</EM
> (End Of File) character is read, the loop exits.  Since most users don't have a clue which key combination is used for the EOF sequence, it is more user-friendly to have a <B
CLASS="command"
>break</B
> command as one of the items.  Any other value of the read line will set <TT
CLASS="varname"
>WORD</TT
> to be a null string.</P
><P
>The read line is saved in the <TT
CLASS="varname"
>REPLY</TT
> variable.</P
><P
>The <B
CLASS="command"
>RESPECTIVE-COMMANDS</B
> are executed after each selection until the number representing the <B
CLASS="command"
>break</B
> is read.  This exits the loop.</P
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="sect_09_06_01_02"
></A
>9.6.1.2. Examples</H3
><P
>This is a very simple example, but as you can see, it is not very user-friendly:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>[carol@octarine testdir]</TT
> <B
CLASS="command"
>cat <TT
CLASS="filename"
>private.sh</TT
></B
>
#!/bin/bash

echo "This script can make any of the files in this directory private."
echo "Enter the number of the file you want to protect:"

select FILENAME in *;
do
     echo "You picked $FILENAME ($REPLY), it is now only accessible to you."
     chmod go-rwx "$FILENAME"
done

<TT
CLASS="prompt"
>[carol@octarine testdir]</TT
> <B
CLASS="command"
>./private.sh</B
>
This script can make any of the files in this directory private.
Enter the number of the file you want to protect:
1) archive-20030129
2) bash
3) private.sh
#? 1
You picked archive-20030129 (1)
#?
</PRE
></FONT
></TD
></TR
></TABLE
><P
>Setting the <TT
CLASS="varname"
>PS3</TT
> prompt and adding a possibility to quit makes it better:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;#!/bin/bash

echo "This script can make any of the files in this directory private."
echo "Enter the number of the file you want to protect:"

PS3="Your choice: "
QUIT="QUIT THIS PROGRAM - I feel safe now."
touch "$QUIT"

select FILENAME in *;
do
  case $FILENAME in
        "$QUIT")
          echo "Exiting."
          break
          ;;
        *)
          echo "You picked $FILENAME ($REPLY)"
          chmod go-rwx "$FILENAME"
          ;;
  esac
done
rm "$QUIT"
</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_09_06_02"
></A
>9.6.2. Submenus</H2
><P
>Any statement within a <B
CLASS="command"
>select</B
> construct can be another <B
CLASS="command"
>select</B
> loop, enabling (a) submenu(s) within a menu.</P
><P
>By default, the <TT
CLASS="varname"
>PS3</TT
> variable is not changed when entering a nested <B
CLASS="command"
>select</B
> loop.  If you want a different prompt in the submenu, be sure to set it at the appropriate time(s).</P
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="sect_09_07"
></A
>9.7. The shift built-in</H1
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="sect_09_07_01"
></A
>9.7.1. What does it do?</H2
><P
>The <B
CLASS="command"
>shift</B
> command is one of the Bourne shell built-ins that comes with Bash.  This command takes one argument, a number.  The positional parameters are shifted to the left by this number, <EM
>N</EM
>.  The positional parameters from <TT
CLASS="varname"
>N+1</TT
> to <TT
CLASS="varname"
>$#</TT
> are renamed to variable names from <TT
CLASS="varname"
>$1</TT
> to <TT
CLASS="varname"
>$# - N+1</TT
>.</P
><P
>Say you have a command that takes 10 arguments, and N is 4, then <TT
CLASS="varname"
>$4</TT
> becomes <TT
CLASS="varname"
>$1</TT
>, <TT
CLASS="varname"
>$5</TT
> becomes <TT
CLASS="varname"
>$2</TT
> and so on.  <TT
CLASS="varname"
>$10</TT
> becomes <TT
CLASS="varname"
>$7</TT
> and the original <TT
CLASS="varname"
>$1</TT
>, <TT
CLASS="varname"
>$2</TT
> and <TT
CLASS="varname"
>$3</TT
> are thrown away.</P
><P
>If N is zero or greater than <TT
CLASS="varname"
>$#</TT
>, the positional parameters are not changed (the total number of arguments, see <A
HREF="#sect_07_02_01_02"
>Section 7.2.1.2</A
>) and the command has no effect.  If N is not present, it is assumed to be 1.  The return status is zero unless N is greater than <TT
CLASS="varname"
>$#</TT
> or less than zero; otherwise it is non-zero.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_09_07_02"
></A
>9.7.2. Examples</H2
><P
>A shift statement is typically used when the number of arguments to a command is not known in advance, for instance when users can give as many arguments as they like.  In such cases, the arguments are usually processed in a <B
CLASS="command"
>while</B
> loop with a test condition of <B
CLASS="command"
>(( $# ))</B
>.  This condition is true as long as the number of arguments is greater than zero.  The <TT
CLASS="varname"
>$1</TT
> variable and the <B
CLASS="command"
>shift</B
> statement process each argument.  The number of arguments is reduced each time <B
CLASS="command"
>shift</B
> is executed and eventually becomes zero, upon which the <B
CLASS="command"
>while</B
> loop exits.</P
><P
>The example below, <TT
CLASS="filename"
>cleanup.sh</TT
>, uses <B
CLASS="command"
>shift</B
> statements to process each file in the list generated by <B
CLASS="command"
>find</B
>:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;#!/bin/bash

# This script can clean up files that were last accessed over 365 days ago.

USAGE="Usage: $0 dir1 dir2 dir3 ... dirN"

if [ "$#" == "0" ]; then
	echo "$USAGE"
	exit 1
fi

while (( "$#" )); do

if [[ $(ls "$1") == "" ]]; then 
	echo "Empty directory, nothing to be done."
  else 
	find "$1" -type f -a -atime +365 -exec rm -i {} \;
fi

shift

done
</PRE
></FONT
></TD
></TR
></TABLE
><DIV
CLASS="note"
><P
></P
><TABLE
CLASS="note"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>-exec vs. xargs</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The above <B
CLASS="command"
>find</B
> command can be replaced with the following:</P
><P
><B
CLASS="command"
>find <TT
CLASS="option"
>options</TT
> | xargs [commands_to_execute_on_found_files]</B
> </P
><P
>The <B
CLASS="command"
>xargs</B
> command builds and executes command lines from standard input.  This has the advantage that the command line is filled until the system limit is reached.  Only then will the command to execute be called, in the above example this would be <B
CLASS="command"
>rm</B
>.  If there are more arguments, a new command line will be used, until that one is full or until there are no more arguments.  The same thing using <B
CLASS="command"
>find <TT
CLASS="option"
>-exec</TT
></B
> calls on the command to execute on the found files every time a file is found.  Thus, using <B
CLASS="command"
>xargs</B
> greatly speeds up your scripts and the performance of your machine.</P
></TD
></TR
></TABLE
></DIV
><P
>In the next example, we modified the script from <A
HREF="#sect_08_02_04_04"
>Section 8.2.4.4</A
> so that it accepts multiple packages to install at once:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;#!/bin/bash
if [ $# -lt 1 ]; then
        echo "Usage: $0 package(s)"
        exit 1
fi
while (($#)); do
	yum install "$1" &#60;&#60; CONFIRM
y
CONFIRM
shift
done
</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="sect_09_08"
></A
>9.8. Summary</H1
><P
>In this chapter, we discussed how repetitive commands can be incorporated in loop constructs.  Most common loops are built using the <B
CLASS="command"
>for</B
>, <B
CLASS="command"
>while</B
> or <B
CLASS="command"
>until</B
> statements, or a combination of these commands.  The <B
CLASS="command"
>for</B
> loop executes a task a defined number of times.  If you don't know how many times a command should execute, use either <B
CLASS="command"
>until</B
> or <B
CLASS="command"
>while</B
> to specify when the loop should end.</P
><P
>Loops can be interrupted or reiterated using the <B
CLASS="command"
>break</B
> and <B
CLASS="command"
>continue</B
> statements.</P
><P
>A file can be used as input for a loop using the input redirection operator, loops can also read output from commands that is fed into the loop using a pipe.</P
><P
>The <B
CLASS="command"
>select</B
> construct is used for printing menus in interactive scripts.  Looping through the command line arguments to a script can be done using the <B
CLASS="command"
>shift</B
> statement.</P
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="sect_09_09"
></A
>9.9. Exercises</H1
><P
>Remember: when building scripts, work in steps and test each step before incorporating it in your script.</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Create a script that will take a (recursive) copy of files in <TT
CLASS="filename"
>/etc</TT
> so that a beginning system administrator can edit files without fear.</P
></LI
><LI
><P
>Write a script that takes exactly one argument, a directory name.  If the number of arguments is more or less than one, print a usage message.  If the argument is not a directory, print another message.  For the given directory, print the five biggest files and the five files that were most recently modified.</P
></LI
><LI
><P
>Can you explain why it is so important to put the variables in between double quotes in the example from <A
HREF="#sect_09_04_02"
>Section 9.4.2</A
>?</P
></LI
><LI
><P
>Write a script similar to the one in <A
HREF="#sect_09_05_01"
>Section 9.5.1</A
>, but think of a way of quitting after the user has executed 3 loops.</P
></LI
><LI
><P
>Think of a better solution than <B
CLASS="command"
>move <TT
CLASS="option"
>-b</TT
></B
> for the script from <A
HREF="#sect_09_05_03"
>Section 9.5.3</A
> to prevent overwriting of existing files.  For instance, test whether or not a file exists.  Don't do unnecessary work!</P
></LI
><LI
><P
>Rewrite the <TT
CLASS="filename"
>whichdaemon.sh</TT
> script from <A
HREF="#sect_07_02_04"
>Section 7.2.4</A
>, so that it:</P
><P
></P
><UL
><LI
><P
>Prints a list of servers to check, such as Apache, the SSH server, the NTP daemon, a name daemon, a power management daemon, and so on.</P
></LI
><LI
><P
>For each choice the user can make, print some sensible information, like the name of the web server, NTP trace information, and so on.</P
></LI
><LI
><P
>Optionally, build in a possibility for users to check other servers than the ones listed.  For such cases, check that at least the given process is running.</P
></LI
><LI
><P
>Review the script from <A
HREF="#sect_09_02_02_04"
>Section 9.2.2.4</A
>.  Note how character input other than <B
CLASS="keycap"
>q</B
> is processed.  Rebuild this script so that it prints a message if characters are given as input.</P
></LI
></UL
></LI
></OL
></DIV
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="chap_10"
></A
>Chapter 10. More on variables</H1
><BLOCKQUOTE
CLASS="ABSTRACT"
><DIV
CLASS="abstract"
><A
NAME="AEN6296"
></A
><P
></P
><P
>In this chapter, we will discuss the advanced use of variables and arguments.  Upon completion, you will be able to:</P
><P
>&#13;<P
></P
><UL
><LI
><P
>Declare and use an array of variables</P
></LI
><LI
><P
>Specify the sort of variable you want to use</P
></LI
><LI
><P
>Make variables read-only</P
></LI
><LI
><P
>Use <B
CLASS="command"
>set</B
> to assign a value to a variable</P
></LI
></UL
>
</P
><P
></P
></DIV
></BLOCKQUOTE
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="sect_10_01"
></A
>10.1. Types of variables</H1
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="sect_10_01_01"
></A
>10.1.1. General assignment of values</H2
><P
>As we already saw, Bash understands many different kinds of variables or parameters.  Thus far, we haven't bothered much with what kind of variables we assigned, so our variables could hold any value that we assigned to them.  A simple command line example demonstrates this:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>[bob in ~]</TT
> <B
CLASS="command"
><TT
CLASS="varname"
>VARIABLE</TT
>=<TT
CLASS="parameter"
><I
>12</I
></TT
></B
>

<TT
CLASS="prompt"
>[bob in ~]</TT
> <B
CLASS="command"
>echo <TT
CLASS="varname"
>$VARIABLE</TT
></B
>
12

<TT
CLASS="prompt"
>[bob in ~]</TT
> <B
CLASS="command"
><TT
CLASS="varname"
>VARIABLE</TT
>=<TT
CLASS="parameter"
><I
>string</I
></TT
></B
>

<TT
CLASS="prompt"
>[bob in ~]</TT
> <B
CLASS="command"
>echo <TT
CLASS="varname"
>$VARIABLE</TT
></B
>
string
</PRE
></FONT
></TD
></TR
></TABLE
><P
>There are cases when you want to avoid this kind of behavior, for instance when handling telephone and other numbers.  Apart from integers and variables, you may also want to specify a variable that is a constant.  This is often done at the beginning of a script, when the value of the constant is declared.  After that, there are only references to the constant variable name, so that when the constant needs to be changed, it only has to be done once.  A variable may also be a series of variables of any type, a so-called <EM
>array</EM
> of variables (<TT
CLASS="varname"
>VAR0</TT
><TT
CLASS="varname"
>VAR1</TT
>, <TT
CLASS="varname"
>VAR2</TT
>, ... <TT
CLASS="varname"
>VARN</TT
>).</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_10_01_02"
></A
>10.1.2. Using the declare built-in</H2
><P
>Using a <B
CLASS="command"
>declare</B
> statement, we can limit the value assignment to variables.</P
><P
>The syntax for <B
CLASS="command"
>declare</B
> is the following:</P
><P
><B
CLASS="command"
>declare <TT
CLASS="option"
>OPTION(s)</TT
> <TT
CLASS="varname"
>VARIABLE</TT
>=value</B
> </P
><P
>The following options are used to determine the type of data the variable can hold and to assign it attributes:</P
><DIV
CLASS="table"
><A
NAME="tab_10_01"
></A
><P
><B
>Table 10-1. Options to the declare built-in</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
>Option</TH
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
>Meaning</TH
></TR
></THEAD
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><TT
CLASS="option"
>-a</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Variable is an array.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><TT
CLASS="option"
>-f</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Use function names only.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><TT
CLASS="option"
>-i</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>The variable is to be treated as an integer; arithmetic evaluation is performed when the variable is assigned a value (see <A
HREF="#sect_03_04_05"
>Section 3.4.6</A
>).</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><TT
CLASS="option"
>-p</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Display the attributes and values of each variable.  When <TT
CLASS="option"
>-p</TT
> is used, additional options are ignored.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><TT
CLASS="option"
>-r</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Make variables read-only.  These variables cannot then be assigned values by subsequent assignment statements, nor can they be unset.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><TT
CLASS="option"
>-t</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Give each variable the <EM
>trace</EM
> attribute.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><TT
CLASS="option"
>-x</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Mark each variable for export to subsequent commands via the environment.</TD
></TR
></TBODY
></TABLE
></DIV
><P
>Using <TT
CLASS="option"
>+</TT
> instead of <TT
CLASS="option"
>-</TT
> turns off the attribute instead.  When used in a function, <B
CLASS="command"
>declare</B
> creates local variables.</P
><P
>The following example shows how assignment of a type to a variable influences the value.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>[bob in ~]</TT
> <B
CLASS="command"
>declare <TT
CLASS="option"
>-i</TT
> <TT
CLASS="varname"
>VARIABLE</TT
>=<TT
CLASS="parameter"
><I
>12</I
></TT
></B
>

<TT
CLASS="prompt"
>[bob in ~]</TT
> <B
CLASS="command"
><TT
CLASS="varname"
>VARIABLE</TT
>=<TT
CLASS="parameter"
><I
>string</I
></TT
></B
>

<TT
CLASS="prompt"
>[bob in ~]</TT
> <B
CLASS="command"
>echo <TT
CLASS="varname"
>$VARIABLE</TT
></B
>
0

<TT
CLASS="prompt"
>[bob in ~]</TT
> <B
CLASS="command"
>declare <TT
CLASS="option"
>-p</TT
> <TT
CLASS="varname"
>VARIABLE</TT
></B
>
declare -i VARIABLE="0"
</PRE
></FONT
></TD
></TR
></TABLE
><P
>Note that Bash has an option to declare a numeric value, but none for declaring string values.  This is because, by default, if no specifications are given, a variable can hold any type of data:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>[bob in ~]</TT
> <B
CLASS="command"
><TT
CLASS="varname"
>OTHERVAR</TT
>=<TT
CLASS="parameter"
><I
>blah</I
></TT
></B
>

<TT
CLASS="prompt"
>[bob in ~]</TT
> <B
CLASS="command"
>declare <TT
CLASS="option"
>-p</TT
> <TT
CLASS="varname"
>OTHERVAR</TT
></B
>
declare -- OTHERVAR="blah"
</PRE
></FONT
></TD
></TR
></TABLE
><P
>As soon as you restrict assignment of values to a variable, it can only hold that type of data.  Possible restrictions are either integer, constant or array.</P
><P
>See the Bash info pages for information on return status.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_10_01_03"
></A
>10.1.3. Constants</H2
><P
>In Bash, constants are created by making a variable read-only.  The <B
CLASS="command"
>readonly</B
> built-in marks each specified variable as unchangeable.  The syntax is:</P
><P
><B
CLASS="command"
>readonly <TT
CLASS="option"
>OPTION</TT
> <TT
CLASS="varname"
>VARIABLE(s)</TT
></B
> </P
><P
>The values of these variables can then no longer be changed by subsequent assignment.  If the <TT
CLASS="option"
>-f</TT
> option is given, each variable refers to a shell function; see <A
HREF="#chap_11"
>Chapter 11</A
>.  If <TT
CLASS="option"
>-a</TT
> is specified, each variable refers to an array of variables.  If no arguments are given, or if <TT
CLASS="option"
>-p</TT
> is supplied, a list of all read-only variables is displayed.  Using the <TT
CLASS="option"
>-p</TT
> option, the output can be reused as input.</P
><P
>The return status is zero, unless an invalid option was specified, one of the variables or functions does not exist, or <TT
CLASS="option"
>-f</TT
> was supplied for a variable name instead of for a function name.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>[bob in ~]</TT
> <B
CLASS="command"
>readonly <TT
CLASS="varname"
>TUX</TT
>=<TT
CLASS="parameter"
><I
>penguinpower</I
></TT
></B
>

<TT
CLASS="prompt"
>[bob in ~]</TT
> <B
CLASS="command"
><TT
CLASS="varname"
>TUX</TT
>=<TT
CLASS="parameter"
><I
>Mickeysoft</I
></TT
></B
>
bash: TUX: readonly variable
</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="sect_10_02"
></A
>10.2. Array variables</H1
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="sect_10_02_01"
></A
>10.2.1. Creating arrays</H2
><P
>An array is a variable containing multiple values.  Any variable may be used as an array.  There is no maximum limit to the size of an array, nor any requirement that member variables be indexed or assigned contiguously.  Arrays are zero-based: the first element is indexed with the number 0.</P
><P
>Indirect declaration is done using the following syntax to declare a variable:</P
><P
><B
CLASS="command"
><TT
CLASS="varname"
>ARRAY[INDEXNR]</TT
>=value</B
> </P
><P
>The <EM
>INDEXNR</EM
> is treated as an arithmetic expression that must evaluate to a positive number.</P
><P
>Explicit declaration of an array is done using the <B
CLASS="command"
>declare</B
> built-in:</P
><P
><B
CLASS="command"
>declare <TT
CLASS="option"
>-a</TT
> <TT
CLASS="varname"
>ARRAYNAME</TT
></B
> </P
><P
>A declaration with an index number will also be accepted, but the index number will be ignored.  Attributes to the array may be specified using the <B
CLASS="command"
>declare</B
> and <B
CLASS="command"
>readonly</B
> built-ins.  Attributes apply to all variables in the array; you can't have mixed arrays.</P
><P
>Array variables may also be created using compound assignments in this format:</P
><P
><B
CLASS="command"
><TT
CLASS="varname"
>ARRAY</TT
>=(value1 value2 ... valueN)</B
> </P
><P
>Each value is then in the form of <EM
>[indexnumber=]string</EM
>.  The index number is optional.  If it is supplied, that index is assigned to it; otherwise the index of the element assigned is the number of the last index that was assigned, plus one.  This format is accepted by <B
CLASS="command"
>declare</B
> as well.  If no index numbers are supplied, indexing starts at zero.</P
><P
>Adding missing or extra members in an array is done using the syntax:</P
><P
><B
CLASS="command"
><TT
CLASS="varname"
>ARRAYNAME[indexnumber]</TT
>=value</B
> </P
><P
>Remember that the <B
CLASS="command"
>read</B
> built-in provides the <TT
CLASS="option"
>-a</TT
> option, which allows for reading and assigning values for member variables of an array.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_10_02_02"
></A
>10.2.2. Dereferencing the variables in an array</H2
><P
>In order to refer to the content of an item in an array, use curly braces.  This is necessary, as you can see from the following example, to bypass the shell interpretation of expansion operators.  If the index number is <EM
>@</EM
> or <EM
>*</EM
>, all members of an array are referenced.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>[bob in ~]</TT
> <B
CLASS="command"
><TT
CLASS="varname"
>ARRAY</TT
>=<TT
CLASS="parameter"
><I
>(one two three)</I
></TT
></B
>

<TT
CLASS="prompt"
>[bob in ~]</TT
> <B
CLASS="command"
>echo <TT
CLASS="varname"
>${ARRAY[*]}</TT
></B
>
one two three

<TT
CLASS="prompt"
>[bob in ~]</TT
> <B
CLASS="command"
>echo <TT
CLASS="varname"
>$ARRAY[*]</TT
></B
>
one[*]

<TT
CLASS="prompt"
>[bob in ~]</TT
> <B
CLASS="command"
>echo <TT
CLASS="varname"
>${ARRAY[2]}</TT
></B
>
three

<TT
CLASS="prompt"
>[bob in ~]</TT
> <B
CLASS="command"
><TT
CLASS="varname"
>ARRAY[3]</TT
>=<TT
CLASS="parameter"
><I
>four</I
></TT
></B
>

<TT
CLASS="prompt"
>[bob in ~]</TT
> <B
CLASS="command"
>echo <TT
CLASS="varname"
>${ARRAY[*]}</TT
></B
>
one two three four
</PRE
></FONT
></TD
></TR
></TABLE
><P
>Referring to the content of a member variable of an array without providing an index number is the same as referring to the content of the first element, the one referenced with index number zero.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_10_02_03"
></A
>10.2.3. Deleting array variables</H2
><P
>The <B
CLASS="command"
>unset</B
> built-in is used to destroy arrays or member variables of an array:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>[bob in ~]</TT
> <B
CLASS="command"
>unset <TT
CLASS="varname"
>ARRAY[1]</TT
></B
>

<TT
CLASS="prompt"
>[bob in ~]</TT
> <B
CLASS="command"
>echo <TT
CLASS="varname"
>${ARRAY[*]}</TT
></B
>
one three four

<TT
CLASS="prompt"
>[bob in ~]</TT
> <B
CLASS="command"
>unset <TT
CLASS="varname"
>ARRAY</TT
></B
>

<TT
CLASS="prompt"
>[bob in ~]</TT
> <B
CLASS="command"
>echo <TT
CLASS="varname"
>${ARRAY[*]}</TT
></B
>
&#60;--no output--&#62;
</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_10_02_04"
></A
>10.2.4. Examples of arrays</H2
><P
>Practical examples of the usage of arrays are hard to find.  You will find plenty of scripts that don't really do anything on your system but that do use arrays to calculate mathematical series, for instance.  And that would be one of the more interesting examples...most scripts just show what you can do with an array in an oversimplified and theoretical way.</P
><P
>The reason for this dullness is that arrays are rather complex structures.  You will find that most practical examples for which arrays could be used are already implemented on your system using arrays, however on a lower level, in the C programming language in which most UNIX commands are written.  A good example is the Bash <B
CLASS="command"
>history</B
> built-in command.  Those readers who are interested might check the <TT
CLASS="filename"
>built-ins</TT
> directory in the Bash source tree and take a look at <TT
CLASS="filename"
>fc.def</TT
>, which is processed when compiling the built-ins.</P
><P
>Another reason good examples are hard to find is that not all shells support arrays, so they break compatibility.</P
><P
>After long days of searching, I finally found this example operating at an Internet provider.  It distributes Apache web server configuration files onto hosts in a web farm:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;#!/bin/bash

if [ $(whoami) != 'root' ]; then
        echo "Must be root to run $0"
        exit 1;
fi
if [ -z $1 ]; then
        echo "Usage: $0 &#60;/path/to/httpd.conf&#62;"
        exit 1
fi

httpd_conf_new=$1
httpd_conf_path="/usr/local/apache/conf"
login=htuser

farm_hosts=(web03 web04 web05 web06 web07)

for i in ${farm_hosts[@]}; do
        su $login -c "scp $httpd_conf_new ${i}:${httpd_conf_path}"
        su $login -c "ssh $i sudo /usr/local/apache/bin/apachectl graceful"

done
exit 0
</PRE
></FONT
></TD
></TR
></TABLE
><P
>First two tests are performed to check whether the correct user is running the script with the correct arguments.  The names of the hosts that need to be configured are listed in the array <TT
CLASS="varname"
>farm_hosts</TT
>.  Then all these hosts are provided with the Apache configuration file, after which the daemon is restarted.  Note the use of commands from the Secure Shell suite, encrypting the connections to remote hosts.</P
><P
>Thanks, Eugene and colleague, for this contribution.</P
><P
>Dan Richter contributed the following example.  This is the problem he was confronted with:</P
><P
><SPAN
CLASS="QUOTE"
>"...In my company, we have demos on our web site, and every week someone has to test all of them.  So I have a cron job that fills an array with the possible candidates, uses <B
CLASS="command"
>date <TT
CLASS="option"
>+%W</TT
></B
> to find the week of the year, and does a modulo operation to find the correct index. The lucky person gets notified by e-mail."</SPAN
></P
><P
>And this was his way of solving it:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;#!/bin/bash
# This is get-tester-address.sh 
#
# First, we test whether bash supports arrays.
# (Support for arrays was only added recently.)
#
whotest[0]='test' || (echo 'Failure: arrays not supported in this version of
bash.' &#38;&#38; exit 2)
                                                                                
#
# Our list of candidates. (Feel free to add or
# remove candidates.)
#
wholist=(
     'Bob Smith &#60;bob@example.com&#62;'
     'Jane L. Williams &#60;jane@example.com&#62;'
     'Eric S. Raymond &#60;esr@example.com&#62;'
     'Larry Wall &#60;wall@example.com&#62;'
     'Linus Torvalds &#60;linus@example.com&#62;'
   )
#
# Count the number of possible testers.
# (Loop until we find an empty string.)
#
count=0
while [ "x${wholist[count]}" != "x" ]
do
   count=$(( $count + 1 ))
done
                                                                                
#
# Now we calculate whose turn it is.
#
week=`date '+%W'`    	# The week of the year (0..53).
week=${week#0}       	# Remove possible leading zero.
                                                                                
let "index = $week % $count"   # week modulo count = the lucky person

email=${wholist[index]}     # Get the lucky person's e-mail address.
                                                                                
echo $email     	# Output the person's e-mail address.
</PRE
></FONT
></TD
></TR
></TABLE
><P
>This script is then used in other scripts, such as this one, which uses a <EM
>here</EM
> document:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;email=`get-tester-address.sh`   # Find who to e-mail.
hostname=`hostname`    		# This machine's name.
                                                                                
#
# Send e-mail to the right person.
#
mail $email -s '[Demo Testing]' &#60;&#60;EOF
The lucky tester this week is: $email
                                                                                
Reminder: the list of demos is here:
    http://web.example.com:8080/DemoSites
                                                                                
(This e-mail was generated by $0 on ${hostname}.)
EOF
</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="sect_10_03"
></A
>10.3. Operations on variables</H1
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="sect_10_03_01"
></A
>10.3.1. Arithmetic on variables</H2
><P
>We discussed this already in <A
HREF="#sect_03_04_05"
>Section 3.4.6</A
>.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_10_03_02"
></A
>10.3.2. Length of a variable</H2
><P
>Using the <B
CLASS="command"
>${#<TT
CLASS="varname"
>VAR</TT
>}</B
> syntax will calculate the number of characters in a variable.  If <TT
CLASS="varname"
>VAR</TT
> is <SPAN
CLASS="QUOTE"
>"*"</SPAN
> or <SPAN
CLASS="QUOTE"
>"@"</SPAN
>, this value is substituted with the number of positional parameters or number of elements in an array in general.  This is demonstrated in the example below:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>[bob in ~]</TT
> <B
CLASS="command"
>echo <TT
CLASS="varname"
>$SHELL</TT
></B
>
/bin/bash

<TT
CLASS="prompt"
>[bob in ~]</TT
> <B
CLASS="command"
>echo <TT
CLASS="varname"
>${#SHELL}</TT
></B
>
9

<TT
CLASS="prompt"
>[bob in ~]</TT
> <B
CLASS="command"
><TT
CLASS="varname"
>ARRAY</TT
>=<TT
CLASS="parameter"
><I
>(one two three)</I
></TT
></B
>

<TT
CLASS="prompt"
>[bob in ~]</TT
> <B
CLASS="command"
>echo <TT
CLASS="varname"
>${#ARRAY}</TT
></B
>
3
</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_10_03_03"
></A
>10.3.3. Transformations of variables</H2
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="sect_10_03_03_01"
></A
>10.3.3.1. Substitution</H3
><P
><B
CLASS="command"
>${<TT
CLASS="varname"
>VAR</TT
>:-<TT
CLASS="parameter"
><I
>WORD</I
></TT
>}</B
> </P
><P
>If <TT
CLASS="varname"
>VAR</TT
> is not defined or null, the expansion of <TT
CLASS="parameter"
><I
>WORD</I
></TT
> is substituted; otherwise the value of <TT
CLASS="varname"
>VAR</TT
> is substituted:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>[bob in ~]</TT
> <B
CLASS="command"
>echo <TT
CLASS="varname"
>${TEST:-test}</TT
></B
>
test

<TT
CLASS="prompt"
>[bob in ~]</TT
> <B
CLASS="command"
>echo <TT
CLASS="varname"
>$TEST</TT
></B
>
 

<TT
CLASS="prompt"
>[bob in ~]</TT
> <B
CLASS="command"
>export <TT
CLASS="varname"
>TEST</TT
>=<TT
CLASS="parameter"
><I
>a_string</I
></TT
></B
>

<TT
CLASS="prompt"
>[bob in ~]</TT
> <B
CLASS="command"
>echo <TT
CLASS="varname"
>${TEST:-test}</TT
></B
>
a_string

<TT
CLASS="prompt"
>[bob in ~]</TT
> <B
CLASS="command"
>echo <TT
CLASS="varname"
>${TEST2:-$TEST}</TT
></B
>
a_string
</PRE
></FONT
></TD
></TR
></TABLE
><P
>This form is often used in conditional tests, for instance in this one:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<B
CLASS="command"
><TT
CLASS="parameter"
><I
>[ -z "${COLUMNS:-}" ]</I
></TT
> &#38;&#38; <TT
CLASS="varname"
>COLUMNS</TT
>=<TT
CLASS="parameter"
><I
>80</I
></TT
></B
>
</PRE
></FONT
></TD
></TR
></TABLE
><P
>It is a shorter notation for</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<B
CLASS="command"
>if <TT
CLASS="parameter"
><I
>[ -z "${COLUMNS:-}" ]</I
></TT
>; then
	<TT
CLASS="varname"
>COLUMNS</TT
>=<TT
CLASS="parameter"
><I
>80</I
></TT
>
fi</B
>
</PRE
></FONT
></TD
></TR
></TABLE
><P
>See <A
HREF="#sect_07_01_02_03"
>Section 7.1.2.3</A
> for more information about this type of condition testing.</P
><P
>If the hyphen (-) is replaced with the equal sign (=), the value is assigned to the parameter if it does not exist:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>[bob in ~]</TT
> <B
CLASS="command"
>echo <TT
CLASS="varname"
>$TEST2</TT
></B
>


<TT
CLASS="prompt"
>[bob in ~]</TT
> <B
CLASS="command"
>echo <TT
CLASS="varname"
>${TEST2:=$TEST}</TT
></B
>
a_string

<TT
CLASS="prompt"
>[bob in ~]</TT
> <B
CLASS="command"
>echo <TT
CLASS="varname"
>$TEST2</TT
></B
>
a_string
</PRE
></FONT
></TD
></TR
></TABLE
><P
>The following syntax tests the existence of a variable.  If it is not set, the expansion of <TT
CLASS="parameter"
><I
>WORD</I
></TT
> is printed to standard out and non-interactive shells quit.  A demonstration:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>[bob in ~]</TT
> <B
CLASS="command"
>cat <TT
CLASS="filename"
>vartest.sh</TT
></B
>
#!/bin/bash
 
# This script tests whether a variable is set.  If not,
# it exits printing a message.
 
echo ${TESTVAR:?"There's so much I still wanted to do..."}
echo "TESTVAR is set, we can proceed."

<TT
CLASS="prompt"
>[bob in testdir]</TT
> <B
CLASS="command"
>./vartest.sh</B
>
./vartest.sh: line 6: TESTVAR: There's so much I still wanted to do...

<TT
CLASS="prompt"
>[bob in testdir]</TT
> <B
CLASS="command"
>export <TT
CLASS="varname"
>TESTVAR</TT
>=<TT
CLASS="parameter"
><I
>present</I
></TT
></B
>

<TT
CLASS="prompt"
>[bob in testdir]</TT
> <B
CLASS="command"
>./vartest.sh</B
>
present
TESTVAR is set, we can proceed.
</PRE
></FONT
></TD
></TR
></TABLE
><P
>Using <SPAN
CLASS="QUOTE"
>"+"</SPAN
> instead of the exclamation mark sets the variable to the expansion of <TT
CLASS="parameter"
><I
>WORD</I
></TT
>; if it does not exist, nothing happens.</P
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="sect_10_03_03_02"
></A
>10.3.3.2. Removing substrings</H3
><P
>To strip a number of characters, equal to <TT
CLASS="parameter"
><I
>OFFSET</I
></TT
>, from a variable, use this syntax:</P
><P
><B
CLASS="command"
>${<TT
CLASS="varname"
>VAR</TT
>:<TT
CLASS="parameter"
><I
>OFFSET</I
></TT
>:<TT
CLASS="parameter"
><I
>LENGTH</I
></TT
>}</B
> </P
><P
>The <TT
CLASS="parameter"
><I
>LENGTH</I
></TT
> parameter defines how many characters to keep, starting from the first character after the offset point.  If <TT
CLASS="parameter"
><I
>LENGTH</I
></TT
> is omitted, the remainder of the variable content is taken:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>[bob in ~]</TT
> <B
CLASS="command"
>export <TT
CLASS="varname"
>STRING</TT
>=<TT
CLASS="parameter"
><I
>"thisisaverylongname"</I
></TT
></B
>

<TT
CLASS="prompt"
>[bob in ~]</TT
> <B
CLASS="command"
>echo <TT
CLASS="varname"
>${STRING:4}</TT
></B
>
isaverylongname

<TT
CLASS="prompt"
>[bob in ~]</TT
> <B
CLASS="command"
>echo <TT
CLASS="varname"
>${STRING:6:5}</TT
></B
>
avery
</PRE
></FONT
></TD
></TR
></TABLE
><P
><B
CLASS="command"
>${<TT
CLASS="varname"
>VAR</TT
>#<TT
CLASS="parameter"
><I
>WORD</I
></TT
>}</B
> </P
><P
>and</P
><P
><B
CLASS="command"
>${<TT
CLASS="varname"
>VAR</TT
>##<TT
CLASS="parameter"
><I
>WORD</I
></TT
>}</B
> </P
><P
>These constructs are used for deleting the pattern matching the expansion of <TT
CLASS="parameter"
><I
>WORD</I
></TT
> in <TT
CLASS="varname"
>VAR</TT
>.  <TT
CLASS="parameter"
><I
>WORD</I
></TT
> is expanded to produce a pattern just as in file name expansion.  If the pattern matches the beginning of the expanded value of <TT
CLASS="varname"
>VAR</TT
>, then the result of the expansion is the expanded value of <TT
CLASS="varname"
>VAR</TT
> with the shortest matching pattern (<SPAN
CLASS="QUOTE"
>"#"</SPAN
>) or the longest matching pattern (indicated with <SPAN
CLASS="QUOTE"
>"##"</SPAN
>).</P
><P
>If <TT
CLASS="varname"
>VAR</TT
> is <TT
CLASS="varname"
>*</TT
> or <TT
CLASS="varname"
>@</TT
>, the pattern removal operation is applied to each positional parameter in turn, and the expansion is the resultant list.</P
><P
>If <TT
CLASS="varname"
>VAR</TT
> is an array variable subscribed with <SPAN
CLASS="QUOTE"
>"*"</SPAN
> or <SPAN
CLASS="QUOTE"
>"@"</SPAN
>, the pattern removal operation is applied to each member of the array in turn, and the expansion is the resultant list.  This is shown in the examples below:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>[bob in ~]</TT
> <B
CLASS="command"
>echo <TT
CLASS="varname"
>${ARRAY[*]}</TT
></B
>
one two one three one four

<TT
CLASS="prompt"
>[bob in ~]</TT
> <B
CLASS="command"
>echo <TT
CLASS="varname"
>${ARRAY[*]#one}</TT
></B
>
two three four

<TT
CLASS="prompt"
>[bob in ~]</TT
> <B
CLASS="command"
>echo <TT
CLASS="varname"
>${ARRAY[*]#t}</TT
></B
>
one wo one hree one four

<TT
CLASS="prompt"
>[bob in ~]</TT
> <B
CLASS="command"
>echo <TT
CLASS="varname"
>${ARRAY[*]#t*}</TT
></B
>
one wo one hree one four

<TT
CLASS="prompt"
>[bob in ~]</TT
> <B
CLASS="command"
>echo <TT
CLASS="varname"
>${ARRAY[*]##t*}</TT
></B
>
one one one four
</PRE
></FONT
></TD
></TR
></TABLE
><P
>The opposite effect is obtained using <SPAN
CLASS="QUOTE"
>"%"</SPAN
> and <SPAN
CLASS="QUOTE"
>"%%"</SPAN
>, as in this example below.  <TT
CLASS="parameter"
><I
>WORD</I
></TT
> should match a trailing portion of string:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>[bob in ~]</TT
> <B
CLASS="command"
>echo <TT
CLASS="varname"
>$STRING</TT
></B
>
thisisaverylongname

<TT
CLASS="prompt"
>[bob in ~]</TT
> <B
CLASS="command"
>echo <TT
CLASS="varname"
>${STRING%name}</TT
></B
>
thisisaverylong
</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="sect_10_03_03_03"
></A
>10.3.3.3. Replacing parts of variable names</H3
><P
>This is done using the</P
><P
><B
CLASS="command"
>${<TT
CLASS="varname"
>VAR</TT
>/<TT
CLASS="parameter"
><I
>PATTERN</I
></TT
>/<TT
CLASS="parameter"
><I
>STRING</I
></TT
>}</B
> </P
><P
>or</P
><P
><B
CLASS="command"
>${<TT
CLASS="varname"
>VAR</TT
>//<TT
CLASS="parameter"
><I
>PATTERN</I
></TT
>/<TT
CLASS="parameter"
><I
>STRING</I
></TT
>}</B
> </P
><P
>syntax.  The first form replaces only the first match, the second replaces all matches of <TT
CLASS="parameter"
><I
>PATTERN</I
></TT
> with <TT
CLASS="parameter"
><I
>STRING</I
></TT
>:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>[bob in ~]</TT
> <B
CLASS="command"
>echo <TT
CLASS="varname"
>${STRING/name/string}</TT
></B
>
thisisaverylongstring
</PRE
></FONT
></TD
></TR
></TABLE
><P
>More information can be found in the Bash info pages.</P
></DIV
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="sect_10_04"
></A
>10.4. Summary</H1
><P
>Normally, a variable can hold any type of data, unless variables are declared explicitly.  Constant variables are set using the <B
CLASS="command"
>readonly</B
> built-in command.</P
><P
>An array holds a set of variables.  If a type of data is declared, then all elements in the array will be set to hold only this type of data.</P
><P
>Bash features allow for substitution and transformation of variables <SPAN
CLASS="QUOTE"
>"on the fly"</SPAN
>.  Standard operations include calculating the length of a variable, arithmetic on variables, substituting variable content and substituting part of the content.</P
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="sect_10_05"
></A
>10.5. Exercises</H1
><P
>Here are some brain crackers:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Write a script that does the following:</P
><P
></P
><UL
><LI
><P
>Display the name of the script being executed.</P
></LI
><LI
><P
>Display the first, third and tenth argument given to the script.</P
></LI
><LI
><P
>Display the total number of arguments passed to the script.</P
></LI
><LI
><P
>If there were more than three positional parameters, use <B
CLASS="command"
>shift</B
> to move all the values 3 places to the left.</P
></LI
><LI
><P
>Print all the values of the remaining arguments.</P
></LI
><LI
><P
>Print the number of arguments.</P
></LI
></UL
><P
>Test with zero, one, three and over ten arguments.</P
></LI
><LI
><P
>Write a script that implements a simple web browser (in text mode), using <B
CLASS="command"
>wget</B
> and <B
CLASS="command"
>links <TT
CLASS="option"
>-dump</TT
></B
> to display HTML pages to the user.  The user has 3 choices: enter a URL, enter <B
CLASS="keycap"
>b</B
> for back and <B
CLASS="keycap"
>q</B
> to quit.  The last 10 URLs entered by the user are stored in an array, from which the user can restore the URL by using the <EM
>back</EM
> functionality.</P
></LI
></OL
></DIV
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="chap_11"
></A
>Chapter 11. Functions</H1
><BLOCKQUOTE
CLASS="ABSTRACT"
><DIV
CLASS="abstract"
><A
NAME="AEN6815"
></A
><P
></P
><P
>In this chapter, we will discuss</P
><P
>&#13;
<P
></P
><UL
><LI
><P
>What functions are</P
></LI
><LI
><P
>Creation and displaying of functions from the command line</P
></LI
><LI
><P
>Functions in scripts</P
></LI
><LI
><P
>Passing arguments to functions</P
></LI
><LI
><P
>When to use functions</P
></LI
></UL
>
</P
><P
></P
></DIV
></BLOCKQUOTE
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="sect_11_01"
></A
>11.1. Introduction</H1
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="sect_11_01_01"
></A
>11.1.1. What are functions?</H2
><P
>Shell functions are a way to group commands for later execution, using a single name for this group, or <EM
>routine</EM
>.  The name of the routine must be unique within the shell or script.  All the commands that make up a function are executed like regular commands.  When calling on a function as a simple command name, the list of commands associated with that function name is executed.  A function is executed within the shell in which it has been declared: no new process is created to interpret the commands.</P
><P
>Special built-in commands are found before shell functions during command lookup.  The special built-ins are: <B
CLASS="command"
>break</B
>, <B
CLASS="command"
>:</B
>, <B
CLASS="command"
>.</B
>, <B
CLASS="command"
>continue</B
>, <B
CLASS="command"
>eval</B
>, <B
CLASS="command"
>exec</B
>, <B
CLASS="command"
>exit</B
>, <B
CLASS="command"
>export</B
>, <B
CLASS="command"
>readonly</B
>, <B
CLASS="command"
>return</B
>, <B
CLASS="command"
>set</B
>, <B
CLASS="command"
>shift</B
>, <B
CLASS="command"
>trap</B
> and <B
CLASS="command"
>unset</B
>.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_11_01_02"
></A
>11.1.2. Function syntax</H2
><P
>Functions either use the syntax</P
><P
><B
CLASS="command"
>function FUNCTION { COMMANDS; }</B
> </P
><P
>or</P
><P
><B
CLASS="command"
>FUNCTION () { COMMANDS; }</B
> </P
><P
>Both define a shell function <B
CLASS="command"
>FUNCTION</B
>.  The use of the built-in command <B
CLASS="command"
>function</B
> is optional; however, if it is not used, parentheses are needed.</P
><P
>The commands listed between curly braces make up the body of the function.  These commands are executed whenever <B
CLASS="command"
>FUNCTION</B
> is specified as the name of a command.  The exit status is the exit status of the last command executed in the body.</P
><DIV
CLASS="note"
><P
></P
><TABLE
CLASS="note"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>Common mistakes</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The curly braces must be separated from the body by spaces, otherwise they are interpreted in the wrong way.</P
><P
>The body of a function should end in a semicolon or a newline.</P
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_11_01_03"
></A
>11.1.3. Positional parameters in functions</H2
><P
>Functions are like mini-scripts: they can accept parameters, they can use variables only known within the function (using the <B
CLASS="command"
>local</B
> shell built-in) and they can return values to the calling shell.</P
><P
>A function also has a system for interpreting positional parameters.  However, the positional parameters passed to a function are not the same as the ones passed to a command or script.</P
><P
>When a function is executed, the arguments to the function become the positional parameters during its execution.  The special parameter <TT
CLASS="varname"
>#</TT
> that expands to the number of positional parameters is updated to reflect the change. Positional parameter <TT
CLASS="varname"
>0</TT
> is unchanged.  The Bash variable <TT
CLASS="varname"
>FUNCNAME</TT
> is set to the name of the function, while it is executing.</P
><P
>If the <B
CLASS="command"
>return</B
> built-in is executed in a function, the function completes and execution resumes with the next command after the function call.  When a function completes, the values of the positional parameters and the special parameter <TT
CLASS="varname"
>#</TT
> are restored to the values they had prior to the function's execution.  If a numeric argument is given to <B
CLASS="command"
>return</B
>, that status is returned.  A simple example:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>[lydia@cointreau ~/test]</TT
> <B
CLASS="command"
>cat <TT
CLASS="filename"
>showparams.sh</TT
></B
>
#!/bin/bash
                                                                                
echo "This script demonstrates function arguments."
echo
                                                                                
echo "Positional parameter 1 for the script is $1."
echo
                                                                                
test ()
{
echo "Positional parameter 1 in the function is $1."
RETURN_VALUE=$?
echo "The exit code of this function is $RETURN_VALUE."
}
                                                                                
test other_param

<TT
CLASS="prompt"
>[lydia@cointreau ~/test]</TT
> <B
CLASS="command"
>./showparams.sh <TT
CLASS="parameter"
><I
>parameter1</I
></TT
></B
>
This script demonstrates function arguments.
 
Positional parameter 1 for the script is parameter1.
 
Positional parameter 1 in the function is other_param.
The exit code of this function is 0.

<TT
CLASS="prompt"
>[lydia@cointreau ~/test]</TT
>
</PRE
></FONT
></TD
></TR
></TABLE
><P
>Note that the return value or exit code of the function is often storen in a variable, so that it can be probed at a later point.  The init scripts on your system often use the technique of probing the <TT
CLASS="varname"
>RETVAL</TT
> variable in a conditional test, like this one:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<B
CLASS="command"
>if <TT
CLASS="parameter"
><I
>[ $RETVAL -eq 0 ]</I
></TT
>; then
	&#60;start the daemon&#62;</B
>
</PRE
></FONT
></TD
></TR
></TABLE
><P
>Or like this example from the <TT
CLASS="filename"
>/etc/init.d/amd</TT
> script, where Bash's optimization features are used:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<B
CLASS="command"
><TT
CLASS="parameter"
><I
>[ $RETVAL = 0 ]</I
></TT
> &#38;&#38; touch <TT
CLASS="filename"
>/var/lock/subsys/amd</TT
></B
>
</PRE
></FONT
></TD
></TR
></TABLE
><P
>The commands after <B
CLASS="command"
>&#38;&#38;</B
> are only executed when the test proves to be true; this is a shorter way to represent an <B
CLASS="command"
>if/then/fi</B
> structure.</P
><P
>The return code of the function is often used as exit code of the entire script.  You'll see a lot of initscripts ending in something like <B
CLASS="command"
>exit <TT
CLASS="varname"
>$RETVAL</TT
></B
>.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_11_01_04"
></A
>11.1.4. Displaying functions</H2
><P
>All functions known by the current shell can be displayed using the <B
CLASS="command"
>set</B
> built-in without options.  Functions are retained after they are used, unless they are <B
CLASS="command"
>unset</B
> after use.  The <B
CLASS="command"
>which</B
> command also displays functions:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>[lydia@cointreau ~]</TT
> <B
CLASS="command"
>which <TT
CLASS="filename"
>zless</TT
></B
>
zless is a function
zless ()
{
    zcat "$@" | "$PAGER"
}

<TT
CLASS="prompt"
>[lydia@cointreau ~]</TT
> <B
CLASS="command"
>echo <TT
CLASS="varname"
>$PAGER</TT
></B
>
less
</PRE
></FONT
></TD
></TR
></TABLE
><P
>This is the sort of function that is typically configured in the user's shell resource configuration files.  Functions are more flexible than aliases and provide a simple and easy way of adapting the user environment.</P
><P
>Here's one for DOS users:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;dir ()
{
    ls -F --color=auto -lF --color=always "$@" | less -r
}
</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="sect_11_02"
></A
>11.2. Examples of functions in scripts</H1
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="sect_11_02_01"
></A
>11.2.1. Recycling</H2
><P
>There are plenty of scripts on your system that use functions as a structured way of handling series of commands.  On some Linux systems, for instance, you will find the <TT
CLASS="filename"
>/etc/rc.d/init.d/functions</TT
> definition file, which is sourced in all init scripts.  Using this method, common tasks such as checking if a process runs, starting or stopping a daemon and so on, only have to be written once, in a general way.  If the same task is needed again, the code is recycled.</P
><P
>You could make your own <TT
CLASS="filename"
>/etc/functions</TT
> file that contains all functions that you use regularly on your system, in different scripts.  Just put the line </P
><P
><B
CLASS="command"
>. <TT
CLASS="filename"
>/etc/functions</TT
></B
> </P
><P
>somewhere at the start of the script and you can recycle functions.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_11_02_02"
></A
>11.2.2. Setting the path</H2
><P
>This section might be found in your <TT
CLASS="filename"
>/etc/profile</TT
> file.  The function <B
CLASS="command"
>pathmunge</B
> is defined and then used to set the path for the <EM
>root</EM
> and other users:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;pathmunge () {
        if ! echo $PATH | /bin/egrep -q "(^|:)$1($|:)" ; then
           if [ "$2" = "after" ] ; then
              PATH=$PATH:$1
           else
              PATH=$1:$PATH
           fi
        fi
}

# Path manipulation
if [ `id -u` = 0 ]; then
        pathmunge /sbin
        pathmunge /usr/sbin
        pathmunge /usr/local/sbin
fi

pathmunge /usr/X11R6/bin after

unset pathmunge
</PRE
></FONT
></TD
></TR
></TABLE
><P
>The function takes its first argument to be a path name.  If this path name is not yet in the current path, it is added.  The second argument to the function defines if the path will be added in front or after the current <TT
CLASS="varname"
>PATH</TT
> definition.</P
><P
>Normal users only get <TT
CLASS="filename"
>/usr/X11R6/bin</TT
> added to their paths, while <EM
>root</EM
> gets a couple of extra directories containing system commands.  After being used, the function is unset so that it is not retained.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_11_02_03"
></A
>11.2.3. Remote backups</H2
><P
>The following example is one that I use for making backups of the files for my books.  It uses SSH keys for enabling the remote connection.  Two functions are defined, <B
CLASS="command"
>buplinux</B
> and <B
CLASS="command"
>bupbash</B
>, that each make a <TT
CLASS="filename"
>.tar</TT
> file, which is then compressed and sent to a remote server.  After that, the local copy is cleaned up.</P
><P
>On Sunday, only <B
CLASS="command"
>bupbash</B
> is executed.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;#/bin/bash

LOGFILE="/nethome/tille/log/backupscript.log"
echo "Starting backups for `date`" &#62;&#62; "$LOGFILE"

buplinux()
{
DIR="/nethome/tille/xml/db/linux-basics/"
TAR="Linux.tar"
BZIP="$TAR.bz2"
SERVER="rincewind"
RDIR="/var/www/intra/tille/html/training/"

cd "$DIR"
tar cf "$TAR" src/*.xml src/images/*.png src/images/*.eps
echo "Compressing $TAR..." &#62;&#62; "$LOGFILE"
bzip2 "$TAR"
echo "...done." &#62;&#62; "$LOGFILE"
echo "Copying to $SERVER..." &#62;&#62; "$LOGFILE"
scp "$BZIP" "$SERVER:$RDIR" &#62; /dev/null 2&#62;&#38;1
echo "...done." &#62;&#62; "$LOGFILE"
echo -e "Done backing up Linux course:\nSource files, PNG and EPS images.\nRubbish removed." &#62;&#62; "$LOGFILE"
rm "$BZIP"
}

bupbash()
{
DIR="/nethome/tille/xml/db/"
TAR="Bash.tar"
BZIP="$TAR.bz2"
FILES="bash-programming/"
SERVER="rincewind"
RDIR="/var/www/intra/tille/html/training/"

cd "$DIR"
tar cf "$TAR" "$FILES"
echo "Compressing $TAR..." &#62;&#62; "$LOGFILE"
bzip2 "$TAR"
echo "...done." &#62;&#62; "$LOGFILE"
echo "Copying to $SERVER..." &#62;&#62; "$LOGFILE"
scp "$BZIP" "$SERVER:$RDIR" &#62; /dev/null 2&#62;&#38;1
echo "...done." &#62;&#62; "$LOGFILE"

echo -e "Done backing up Bash course:\n$FILES\nRubbish removed." &#62;&#62; "$LOGFILE"
rm "$BZIP"
}

DAY=`date +%w`

if [ "$DAY" -lt "2" ]; then
  echo "It is `date +%A`, only backing up Bash course." &#62;&#62; "$LOGFILE"
  bupbash
else
  buplinux
  bupbash
fi


echo -e "Remote backup `date` SUCCESS\n----------" &#62;&#62; "$LOGFILE"
</PRE
></FONT
></TD
></TR
></TABLE
><P
>This script runs from cron, meaning without user interaction, so we redirect standard error from the <B
CLASS="command"
>scp</B
> command to <TT
CLASS="filename"
>/dev/null</TT
>.</P
><P
>It might be argued that all the separate steps can be combined in a command such as</P
><P
><B
CLASS="command"
>tar <TT
CLASS="option"
>c</TT
> <TT
CLASS="filename"
>dir_to_backup/</TT
> | bzip2 | ssh <TT
CLASS="option"
>server</TT
> "cat &#62; <TT
CLASS="filename"
>backup.tar.bz2</TT
>"</B
> </P
><P
>However, if you are interested in intermediate results, which might be recovered upon failure of the script, this is not what you want.</P
><P
>The expression</P
><P
><B
CLASS="command"
>command &#38;&#62; <TT
CLASS="filename"
>file</TT
></B
> </P
><P
>is equivalent to</P
><P
><B
CLASS="command"
>command &#62; <TT
CLASS="filename"
>file</TT
> 2&#62;&#38;1</B
> </P
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="sect_11_03"
></A
>11.3. Summary</H1
><P
>Functions provide an easy way of grouping commands that you need to execute repetitively.  When a function is running, the positional parameters are changed to those of the function.  When it stops, they are reset to those of the calling program.  Functions are like mini-scripts, and just like a script, they generate exit or return codes.</P
><P
>While this was a short chapter, it contains important knowledge needed for achieving the ultimate state of laziness that is the typical goal of any system administrator.</P
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="sect_11_04"
></A
>11.4. Exercises</H1
><P
>Here are some useful things you can do using functions:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Add a function to your <TT
CLASS="filename"
>~/.bashrc</TT
> config file that automates the printing of man pages.  The result should be that you type something like <B
CLASS="command"
>printman &#60;command&#62;</B
>, upon which the first appropriate man page rolls out of your printer.  Check using a pseudo printer device for testing purposes.</P
><P
>As an extra, build in a possibility for the user to supply the section number of the man page he or she wants to print.</P
></LI
><LI
><P
>Create a subdirectory in your home directory in which you can store function definitions.  Put a couple of functions in that directory.  Useful functions might be, amongs others, that you have the same commands as on DOS or a commercial UNIX when working with Linux, or vice versa.  These functions should then be imported in your shell environment when <TT
CLASS="filename"
>~/.bashrc</TT
> is read.</P
></LI
></OL
></DIV
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="chap_12"
></A
>Chapter 12. Catching signals</H1
><BLOCKQUOTE
CLASS="ABSTRACT"
><DIV
CLASS="abstract"
><A
NAME="AEN7003"
></A
><P
></P
><P
>In this chapter, we will discuss the following subjects:</P
><P
>&#13;<P
></P
><UL
><LI
><P
>Available signals</P
></LI
><LI
><P
>Use of the signals</P
></LI
><LI
><P
>Use of the <B
CLASS="command"
>trap</B
> statement</P
></LI
><LI
><P
>How to prevent users from interrupting your programs</P
></LI
></UL
>
</P
><P
></P
></DIV
></BLOCKQUOTE
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="sect_12_01"
></A
>12.1. Signals</H1
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="sect_12_01_01"
></A
>12.1.1. Introduction</H2
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="sect_12_01_01_01"
></A
>12.1.1.1. Finding the signal man page</H3
><P
>Your system contains a man page listing all the available signals, but depending on your operating system, it might be opened in a different way.  On most Linux systems, this will be <B
CLASS="command"
>man <TT
CLASS="option"
>7</TT
> signal</B
>.  When in doubt, locate the exact man page and section using commands like</P
><P
><B
CLASS="command"
>man <TT
CLASS="option"
>-k</TT
> signal | grep <TT
CLASS="option"
>list</TT
></B
> </P
><P
>or</P
><P
><B
CLASS="command"
>apropos signal | grep <TT
CLASS="option"
>list</TT
></B
> </P
><P
>Signal names can be found using <B
CLASS="command"
>kill -l</B
>.</P
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="sect_12_01_01_02"
></A
>12.1.1.2. Signals to your Bash shell</H3
><P
>In the absence of any traps, an interactive Bash shell ignores <EM
>SIGTERM</EM
> and <EM
>SIGQUIT</EM
>.  <EM
>SIGINT</EM
> is caught and handled, and if job control is active, <EM
>SIGTTIN</EM
>, <EM
>SIGTTOU</EM
> and <EM
>SIGTSTP</EM
> are also ignored.  Commands that are run as the result of a command substitution also ignore these signals, when keyboard generated.</P
><P
><EM
>SIGHUP</EM
> by default exits a shell.  An interactive shell will send a <EM
>SIGHUP</EM
> to all jobs, running or stopped; see the documentation on the <B
CLASS="command"
>disown</B
> built-in if you want to disable this default behavior for a particular process.  Use the <TT
CLASS="option"
>huponexit</TT
> option for killing all jobs upon receiving a <EM
>SIGHUP</EM
> signal, using the <B
CLASS="command"
>shopt</B
> built-in.</P
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="sect_12_01_01_03"
></A
>12.1.1.3. Sending signals using the shell</H3
><P
>The following signals can be sent using the Bash shell:</P
><DIV
CLASS="table"
><A
NAME="tab_12_01"
></A
><P
><B
>Table 12-1. Control signals in Bash</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
>Standard key combination</TH
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
>Meaning</TH
></TR
></THEAD
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="keycap"
>Ctrl</B
>+<B
CLASS="keycap"
>C</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>The interrupt signal, sends SIGINT to the job running in the foreground.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="keycap"
>Ctrl</B
>+<B
CLASS="keycap"
>Y</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>The <EM
>delayed suspend</EM
> character.  Causes a running process to be stopped when it attempts to read input from the terminal.  Control is returned to the shell, the user can foreground, background or kill the process.  Delayed suspend is only available on operating systems supporting this feature.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="keycap"
>Ctrl</B
>+<B
CLASS="keycap"
>Z</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>The <EM
>suspend</EM
> signal, sends a <EM
>SIGTSTP</EM
> to a running program, thus stopping it and returning control to the shell.</TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="note"
><P
></P
><TABLE
CLASS="note"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>Terminal settings</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Check your <B
CLASS="command"
>stty</B
> settings.  Suspend and resume of output is usually disabled if you are using <SPAN
CLASS="QUOTE"
>"modern"</SPAN
> terminal emulations.  The standard <B
CLASS="command"
>xterm</B
> supports <B
CLASS="keycap"
>Ctrl</B
>+<B
CLASS="keycap"
>S</B
> and <B
CLASS="keycap"
>Ctrl</B
>+<B
CLASS="keycap"
>Q</B
> by default.</P
></TD
></TR
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_12_01_02"
></A
>12.1.2. Usage of signals with kill</H2
><P
>Most modern shells, Bash included, have a built-in <B
CLASS="command"
>kill</B
> function.  In Bash, both signal names and numbers are accepted as options, and arguments may be job or process IDs.  An exit status can be reported using the <TT
CLASS="option"
>-l</TT
> option: zero when at least one signal was successfully sent, non-zero if an error occurred.</P
><P
>Using the <B
CLASS="command"
>kill</B
> command from <TT
CLASS="filename"
>/usr/bin</TT
>, your system might enable extra options, such as the ability to kill processes from other than your own user ID and specifying processes by name, like with <B
CLASS="command"
>pgrep</B
> and <B
CLASS="command"
>pkill</B
>.</P
><P
>Both <B
CLASS="command"
>kill</B
> commands send the <EM
>TERM</EM
> signal if none is given.</P
><P
>This is a list of the most common signals:</P
><DIV
CLASS="table"
><A
NAME="tab_12_02"
></A
><P
><B
>Table 12-2. Common kill signals</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
>Signal name</TH
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
>Signal value</TH
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
>Effect</TH
></TR
></THEAD
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>SIGHUP</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>1</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Hangup</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>SIGINT</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>2</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Interrupt from keyboard</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>SIGKILL</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>9</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Kill signal</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>SIGTERM</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>15</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Termination signal</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>SIGSTOP</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>17,19,23</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Stop the process</TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="note"
><P
></P
><TABLE
CLASS="note"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>SIGKILL and SIGSTOP</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><EM
>SIGKILL</EM
> and <EM
>SIGSTOP</EM
> can not be caught, blocked or ignored.</P
></TD
></TR
></TABLE
></DIV
><P
>When killing a process or series of processes, it is common sense to start trying with the least dangerous signal, <EM
>SIGTERM</EM
>.  That way, programs that care about an orderly shutdown get the chance to follow the procedures that they have been designed to execute when getting the <EM
>SIGTERM</EM
> signal, such as cleaning up and closing open files.  If you send a <EM
>SIGKILL</EM
> to a process, you remove any chance for the process to do a tidy cleanup and shutdown, which might have unfortunate consequences.</P
><P
>But if a clean termination does not work, the <EM
>INT</EM
> or<EM
>KILL</EM
> signals might be the only way.  For instance, when a process does not die using <B
CLASS="keycap"
>Ctrl</B
>+<B
CLASS="keycap"
>C</B
>, it is best to use the <B
CLASS="command"
>kill <TT
CLASS="option"
>-9</TT
></B
> on that process ID:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>maud: ~&#62;</TT
> <B
CLASS="command"
>ps <TT
CLASS="option"
>-ef</TT
> | grep <TT
CLASS="parameter"
><I
>stuck_process</I
></TT
></B
>
maud    5607   2214  0 20:05 pts/5    00:00:02 stuck_process

<TT
CLASS="prompt"
>maud: ~&#62;</TT
> <B
CLASS="command"
>kill <TT
CLASS="option"
>-9</TT
> <TT
CLASS="parameter"
><I
>5607</I
></TT
></B
>

<TT
CLASS="prompt"
>maud: ~&#62;</TT
> <B
CLASS="command"
>ps <TT
CLASS="option"
>-ef</TT
> | grep <TT
CLASS="parameter"
><I
>stuck_process</I
></TT
></B
>
maud    5614    2214 0 20:15 pts/5    00:00:00 grep stuck_process
[1]+ Killed		stuck_process
</PRE
></FONT
></TD
></TR
></TABLE
><P
>When a process starts up several instances, <B
CLASS="command"
>killall</B
> might be easier.  It takes the same option as the <B
CLASS="command"
>kill</B
> command, but applies on all instances of a given process.  Test this command before using it in a production environment, since it might not work as expected on some of the commercial Unices.</P
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="sect_12_02"
></A
>12.2. Traps</H1
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="sect_12_02_01"
></A
>12.2.1. General</H2
><P
>There might be situations when you don't want users of your scripts to exit untimely using keyboard abort sequences, for example because input has to be provided or cleanup has to be done.  The <B
CLASS="command"
>trap</B
> statement catches these sequences and can be programmed to execute a list of commands upon catching those signals.</P
><P
>The syntax for the <B
CLASS="command"
>trap</B
> statement is straightforward:</P
><P
><B
CLASS="command"
>trap [COMMANDS] [SIGNALS]</B
> </P
><P
>This instructs the <B
CLASS="command"
>trap</B
> command to catch the listed <EM
>SIGNALS</EM
>, which may be signal names with or without the <EM
>SIG</EM
> prefix, or signal numbers.  If a signal is <EM
>0</EM
> or <EM
>EXIT</EM
>, the <B
CLASS="command"
>COMMANDS</B
> are executed when the shell exits.  If one of the signals is <EM
>DEBUG</EM
>, the list of <B
CLASS="command"
>COMMANDS</B
> is executed after every simple command.  A signal may also be specified as <EM
>ERR</EM
>; in that case <B
CLASS="command"
>COMMANDS</B
> are executed each time a simple command exits with a non-zero status.  Note that these commands will not be executed when the non-zero exit status comes from part of an <B
CLASS="command"
>if</B
> statement, or from a <B
CLASS="command"
>while</B
> or <B
CLASS="command"
>until</B
> loop.  Neither will they be executed if a logical <EM
>AND</EM
> (&#38;&#38;) or <EM
>OR</EM
> (||) result in a non-zero exit code, or when a command's return status is inverted using the <EM
>!</EM
> operator.</P
><P
>The return status of the <B
CLASS="command"
>trap</B
> command itself is zero unless an invalid signal specification is encountered.  The <B
CLASS="command"
>trap</B
> command takes a couple of options, which are documented in the Bash info pages.</P
><P
>Here is a very simple example, catching <B
CLASS="keycap"
>Ctrl</B
>+<B
CLASS="keycap"
>C</B
> from the user, upon which a message is printed.  When you try to kill this program without specifying the <EM
>KILL</EM
> signal, nothing will happen:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;#!/bin/bash
# traptest.sh

trap "echo Booh!" SIGINT SIGTERM
echo "pid is $$"

while :			# This is the same as "while true".
do
        sleep 60	# This script is not really doing anything.
done
</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_12_02_02"
></A
>12.2.2. How Bash interprets traps</H2
><P
>When Bash receives a signal for which a trap has been set while waiting for a command to complete, the trap will not be executed until the command completes.  When Bash is waiting for an asynchronous command via the <B
CLASS="command"
>wait</B
> built-in, the reception of a signal for which a trap has been set will cause the <B
CLASS="command"
>wait</B
> built-in to return immediately with an exit status greater than 128, immediately after which the trap is executed.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sect_12_02_03"
></A
>12.2.3. More examples</H2
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="sect_12_02_03_01"
></A
>12.2.3.1. Detecting when a variable is used</H3
><P
>When debugging longer scripts, you might want to give a variable the <EM
>trace</EM
> attribute and trap <EM
>DEBUG</EM
> messages for that variable.  Normally you would just declare a variable using an assignment like <B
CLASS="command"
><TT
CLASS="varname"
>VARIABLE</TT
>=value</B
>.  Replacing the declaration of the variable with the following lines might provide valuable information about what your script is doing:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;declare -t VARIABLE=value

trap "echo VARIABLE is being used here." DEBUG

# rest of the script
</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="sect_12_02_03_02"
></A
>12.2.3.2. Removing rubbish upon exit</H3
><P
>The <B
CLASS="command"
>whatis</B
> command relies on a database which is regularly built using the <TT
CLASS="filename"
>makewhatis.cron</TT
> script with cron:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;#!/bin/bash

LOCKFILE=/var/lock/makewhatis.lock

# Previous makewhatis should execute successfully:

[ -f $LOCKFILE ] &#38;&#38; exit 0

# Upon exit, remove lockfile.

trap "{ rm -f $LOCKFILE ; exit 255; }" EXIT

touch $LOCKFILE
makewhatis -u -w
exit 0
</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="sect_12_03"
></A
>12.3. Summary</H1
><P
>Signals can be sent to your programs using the <B
CLASS="command"
>kill</B
> command or keyboard shortcuts.  These signals can be caught, upon which action can be performed, using the <B
CLASS="command"
>trap</B
> statement.</P
><P
>Some programs ignore signals.  The only signal that no program can ignore is the <EM
>KILL</EM
> signal.</P
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="sect_12_04"
></A
>12.4. Exercises</H1
><P
>A couple of practical examples:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Create a script that writes a boot image to a diskette using the <B
CLASS="command"
>dd</B
> utility.  If the user tries to interrupt the script using <B
CLASS="keycap"
>Ctrl</B
>+<B
CLASS="keycap"
>C</B
>, display a message that this action will make the diskette unusable.</P
></LI
><LI
><P
>Write a script that automates the installation of a third-party package of your choice.  The package must be downloaded from the Internet.  It must be decompressed, unarchived and compiled if these actions are appropriate.  Only the actual installation of the package should be uninterruptable.</P
></LI
></OL
></DIV
></DIV
><DIV
CLASS="appendix"
><HR><H1
><A
NAME="app3"
></A
>Appendix A. Shell Features</H1
><BLOCKQUOTE
CLASS="ABSTRACT"
><DIV
CLASS="abstract"
><A
NAME="AEN7241"
></A
><P
></P
><P
>This document gives an overview of common shell features (the same in every shell flavour) and differing shell features (shell specific features).</P
><P
></P
></DIV
></BLOCKQUOTE
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="AEN7243"
></A
>A.1. Common features</H1
><P
>&#13;The following features are standard in every shell.  Note that the stop, suspend, jobs, bg and fg commands are only available on systems that support job control.
</P
><DIV
CLASS="table"
><A
NAME="AEN7246"
></A
><P
><B
>Table A-1. Common Shell Features</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
>Command</TH
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
>Meaning</TH
></TR
></THEAD
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>&#62;</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Redirect output</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>&#62;&#62;</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Append to file</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>&#60;</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Redirect input</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>&#60;&#60;</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>"Here" document (redirect input)</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>|</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Pipe output</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>&#38;</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Run process in background.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>;</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Separate commands on same line</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>*</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Match any character(s) in filename</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>?</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Match single character in filename</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>[ ]</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Match any characters enclosed</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>( )</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Execute in subshell</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>` `</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Substitute output of enclosed command</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>" "</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Partial quote (allows variable and command expansion)</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>' '</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Full quote (no expansion)</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>\</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Quote following character</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>$var</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Use value for variable</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>$$</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Process id</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>$0</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Command name</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>$n</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>nth argument (n from 0 to 9)</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><TT
CLASS="literal"
>#</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Begin comment</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>bg</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Background execution</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>break</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Break from loop statements</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>cd</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Change directories</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>continue</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Resume a program loop</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>echo</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Display output</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>eval</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Evaluate arguments</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>exec</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Execute a new shell</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>fg</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Foreground execution</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>jobs</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Show active jobs</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>kill</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Terminate running jobs</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>newgrp</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Change to a new group</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>shift</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Shift positional parameters</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>stop</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Suspend a background job</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>suspend</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Suspend a foreground job</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>time</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Time a command</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>umask</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Set or list file permissions</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>unset</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Erase variable or function definitions</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>wait</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Wait for a background job to finish</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="AEN7369"
></A
>A.2. Differing features</H1
><P
>The table below shows major differences between the standard shell (<B
CLASS="command"
>sh</B
>), Bourne Again SHell (<B
CLASS="command"
>bash</B
>), Korn shell (<B
CLASS="command"
>ksh</B
>) and the C shell (<B
CLASS="command"
>csh</B
>).</P
><DIV
CLASS="note"
><P
></P
><TABLE
CLASS="note"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>Shell compatibility</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Since the Bourne Again SHell is a superset of <B
CLASS="command"
>sh</B
>, all <B
CLASS="command"
>sh</B
> commands will also work in <B
CLASS="command"
>bash</B
> - but not vice versa.  <B
CLASS="command"
>bash</B
> has many more features of its own, and, as the table below demonstrates, many features incorporated from other shells.</P
><P
>Since the Turbo C shell is a superset of <B
CLASS="command"
>csh</B
>, all <B
CLASS="command"
>csh</B
> commands will work in <B
CLASS="command"
>tcsh</B
>, but not the other way round.</P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="table"
><A
NAME="AEN7387"
></A
><P
><B
>Table A-2. Differing Shell Features</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>sh</B
></TH
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>bash</B
></TH
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>ksh</B
></TH
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>csh</B
></TH
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
>Meaning/Action</TH
></TR
></THEAD
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>$</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>$</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>$</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>%</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Default user prompt</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>&#62;|</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>&#62;|</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>&#62;!</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Force redirection</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>&#62; <TT
CLASS="filename"
>file</TT
> 2&#62;&#38;1</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>&#38;&#62; <TT
CLASS="filename"
>file</TT
></B
> or <B
CLASS="command"
>&#62; <TT
CLASS="filename"
>file</TT
> 2&#62;&#38;1</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>&#62; <TT
CLASS="filename"
>file</TT
> 2&#62;&#38;1</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>&#62;&#38; <TT
CLASS="filename"
>file</TT
></B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Redirect stdout and stderr to <TT
CLASS="filename"
>file</TT
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>{ }</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>{ }</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Expand elements in list</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>`command`</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>`command`</B
> or <B
CLASS="command"
>$(command)</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>$(command)</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>`command`</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Substitute output of enclosed <B
CLASS="command"
>command</B
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><TT
CLASS="varname"
>$HOME</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><TT
CLASS="varname"
>$HOME</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><TT
CLASS="varname"
>$HOME</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><TT
CLASS="varname"
>$home</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Home directory</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>~</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>~</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>~</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Home directory symbol</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><TT
CLASS="filename"
>~+</TT
>, <TT
CLASS="filename"
>~-</TT
>, <B
CLASS="command"
>dirs</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><TT
CLASS="filename"
>~+</TT
>, <TT
CLASS="filename"
>~-</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><TT
CLASS="filename"
>=-</TT
>, <TT
CLASS="filename"
>=N</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Access directory stack</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
><TT
CLASS="varname"
>var</TT
>=value</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
><TT
CLASS="varname"
>VAR</TT
>=value</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
><TT
CLASS="varname"
>var</TT
>=value</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>set <TT
CLASS="varname"
>var</TT
>=value</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Variable assignment</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>export <TT
CLASS="varname"
>var</TT
></B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>export <TT
CLASS="varname"
>VAR</TT
>=value</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>export <TT
CLASS="varname"
>var</TT
>=val</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>setenv <TT
CLASS="varname"
>var</TT
> <TT
CLASS="parameter"
><I
>val</I
></TT
></B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Set environment variable</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><TT
CLASS="varname"
>${nnnn}</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><TT
CLASS="varname"
>${nn}</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>More than 9 arguments can be referenced</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>"<TT
CLASS="varname"
>$@</TT
>"</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>"<TT
CLASS="varname"
>$@</TT
>"</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>"<TT
CLASS="varname"
>$@</TT
>"</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>All arguments as separate words</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><TT
CLASS="varname"
>$#</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><TT
CLASS="varname"
>$#</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><TT
CLASS="varname"
>$#</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><TT
CLASS="varname"
>$#argv</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Number of arguments</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><TT
CLASS="varname"
>$?</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><TT
CLASS="varname"
>$?</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><TT
CLASS="varname"
>$?</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><TT
CLASS="varname"
>$status</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Exit status of the most recently executed command</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><TT
CLASS="varname"
>$!</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><TT
CLASS="varname"
>$!</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><TT
CLASS="varname"
>$!</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>PID of most recently backgrounded process</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><TT
CLASS="varname"
>$-</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><TT
CLASS="varname"
>$-</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><TT
CLASS="varname"
>$-</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Current options</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>. <TT
CLASS="filename"
>file</TT
></B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>source <TT
CLASS="filename"
>file</TT
></B
> or <B
CLASS="command"
>. <TT
CLASS="filename"
>file</TT
></B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>. <TT
CLASS="filename"
>file</TT
></B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>source <TT
CLASS="filename"
>file</TT
></B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Read commands in file</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>alias x='y'</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>alias x=y</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>alias x y</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Name <B
CLASS="command"
>x</B
> stands for command <B
CLASS="command"
>y</B
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>case</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>case</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>case</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>switch</B
> or <B
CLASS="command"
>case</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Choose alternatives</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>done</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>done</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>done</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>end</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>End a loop statement</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>esac</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>esac</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>esac</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>endsw</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>End <B
CLASS="command"
>case</B
> or <B
CLASS="command"
>switch</B
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>exit <TT
CLASS="parameter"
><I
>n</I
></TT
></B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>exit <TT
CLASS="parameter"
><I
>n</I
></TT
></B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>exit <TT
CLASS="parameter"
><I
>n</I
></TT
></B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>exit <TT
CLASS="parameter"
><I
>(expr)</I
></TT
></B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Exit with a status</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>for</B
>/<B
CLASS="command"
>do</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>for</B
>/<B
CLASS="command"
>do</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>for</B
>/<B
CLASS="command"
>do</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>foreach</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Loop through variables</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>set <TT
CLASS="option"
>-f</TT
></B
>, <B
CLASS="command"
>set <TT
CLASS="option"
>-o nullglob|dotglob|nocaseglob|noglob</TT
></B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>noglob</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Ignore substitution characters for filename generation</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>hash</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>hash</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>alias <TT
CLASS="option"
>-t</TT
></B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>hashstat</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Display hashed commands (tracked aliases)</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>hash <TT
CLASS="parameter"
><I
>cmds</I
></TT
></B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>hash <TT
CLASS="parameter"
><I
>cmds</I
></TT
></B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>alias <TT
CLASS="option"
>-t</TT
> <TT
CLASS="parameter"
><I
>cmds</I
></TT
></B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>rehash</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Remember command locations</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>hash <TT
CLASS="option"
>-r</TT
></B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>hash <TT
CLASS="option"
>-r</TT
></B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>unhash</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Forget command locations</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>history</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>history</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>history</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>List previous commands</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="keycap"
>ArrowUp</B
>+<B
CLASS="keycap"
>Enter</B
> or <B
CLASS="command"
>!!</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>r</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>!!</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Redo previous command</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>!<TT
CLASS="parameter"
><I
>str</I
></TT
></B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>r <TT
CLASS="parameter"
><I
>str</I
></TT
></B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>!<TT
CLASS="parameter"
><I
>str</I
></TT
></B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Redo last command that starts with <SPAN
CLASS="QUOTE"
>"str"</SPAN
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>!<TT
CLASS="parameter"
><I
>cmd</I
></TT
>:s/<TT
CLASS="parameter"
><I
>x</I
></TT
>/<TT
CLASS="parameter"
><I
>y</I
></TT
>/</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>r <TT
CLASS="parameter"
><I
>x</I
></TT
>=<TT
CLASS="parameter"
><I
>y</I
></TT
> <TT
CLASS="parameter"
><I
>cmd</I
></TT
></B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>!<TT
CLASS="parameter"
><I
>cmd</I
></TT
>:s/<TT
CLASS="parameter"
><I
>x</I
></TT
>/<TT
CLASS="parameter"
><I
>y</I
></TT
>/</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Replace <SPAN
CLASS="QUOTE"
>"x"</SPAN
> with <SPAN
CLASS="QUOTE"
>"y"</SPAN
> in most recent command starting with <SPAN
CLASS="QUOTE"
>"cmd"</SPAN
>, then execute.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>if [ <TT
CLASS="varname"
>$i</TT
> -eq <TT
CLASS="parameter"
><I
>5</I
></TT
> ]</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>if [ <TT
CLASS="varname"
>$i</TT
> -eq <TT
CLASS="parameter"
><I
>5</I
></TT
> ]</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>if ((<TT
CLASS="varname"
>i</TT
>==<TT
CLASS="parameter"
><I
>5</I
></TT
>))</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>if (<TT
CLASS="varname"
>$i</TT
>==<TT
CLASS="parameter"
><I
>5</I
></TT
>)</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Sample condition test</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>fi</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>fi</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>fi</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>endif</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>End <B
CLASS="command"
>if</B
> statement</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>ulimit</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>ulimit</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>ulimit</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>limit</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Set resource limits</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>pwd</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>pwd</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>pwd</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>dirs</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Print working directory</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>read</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>read</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>read</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>$&#60;</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Read from terminal</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>trap <TT
CLASS="parameter"
><I
>2</I
></TT
></B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>trap <TT
CLASS="parameter"
><I
>2</I
></TT
></B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>trap <TT
CLASS="parameter"
><I
>2</I
></TT
></B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>onintr</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Ignore interrupts</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>unalias</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>unalias</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>unalias</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Remove aliases</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>until</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>until</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>until</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Begin <B
CLASS="command"
>until</B
> loop</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>while</B
>/<B
CLASS="command"
>do</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>while</B
>/<B
CLASS="command"
>do</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>while</B
>/<B
CLASS="command"
>do</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>while</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Begin <B
CLASS="command"
>while</B
> loop</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The Bourne Again SHell has many more features not listed here.  This table is just to give you an idea of how this shell incorporates all useful ideas from other shells: there are no blanks in the column for <B
CLASS="command"
>bash</B
>.  More information on features found only in Bash can be retrieved from the Bash info pages, in the <SPAN
CLASS="QUOTE"
>"Bash Features"</SPAN
> section.</P
><P
>More information:</P
><P
>You should at least read one manual, being the manual of your shell.  The preferred choice would be <B
CLASS="command"
>info bash</B
>, <B
CLASS="command"
>bash</B
> being the GNU shell and easiest for beginners.  Print it out and take it home, study it whenever you have 5 minutes.</P
></DIV
></DIV
><DIV
CLASS="GLOSSARY"
><H1
><A
NAME="glossary"
></A
>Glossary</H1
><BLOCKQUOTE
CLASS="ABSTRACT"
><DIV
CLASS="abstract"
><A
NAME="AEN7869"
></A
><P
></P
><P
>This section contains an alphabetical overview of common UNIX commands.  More information about the usage can be found in the man or info pages.</P
><P
></P
></DIV
></BLOCKQUOTE
><DIV
CLASS="glossdiv"
><H1
CLASS="glossdiv"
><A
NAME="A"
></A
>A</H1
><DL
><DT
><A
NAME="a2ps"
></A
><B
>a2ps</B
></DT
><DD
><P
>Format files for printing on a PostScript printer.</P
></DD
><DT
><A
NAME="acroread"
></A
><B
>acroread</B
></DT
><DD
><P
>PDF viewer.</P
></DD
><DT
><A
NAME="adduser"
></A
><B
>adduser</B
></DT
><DD
><P
>Create a new user or update default new user information.</P
></DD
><DT
><A
NAME="alias"
></A
><B
>alias</B
></DT
><DD
><P
>Create a shell alias for a command.</P
></DD
><DT
><A
NAME="anacron"
></A
><B
>anacron</B
></DT
><DD
><P
>Execute commands periodically, does not assume continuously running machine.</P
></DD
><DT
><A
NAME="apropos"
></A
><B
>apropos</B
></DT
><DD
><P
>Search the whatis database for strings.</P
></DD
><DT
><A
NAME="apt-get"
></A
><B
>apt-get</B
></DT
><DD
><P
>APT package handling utility.</P
></DD
><DT
><A
NAME="aspell"
></A
><B
>aspell</B
></DT
><DD
><P
>Spell checker.</P
></DD
><DT
><A
NAME="at"
></A
><B
>at, atq, atrm</B
></DT
><DD
><P
>Queue, examine or delete jobs for later execution.</P
></DD
><DT
><A
NAME="aumix"
></A
><B
>aumix</B
></DT
><DD
><P
>Adjust audio mixer.</P
></DD
><DT
><A
NAME="awk"
></A
><B
>(g)awk</B
></DT
><DD
><P
>Pattern scanning and processing language.</P
></DD
></DL
></DIV
><DIV
CLASS="glossdiv"
><H1
CLASS="glossdiv"
><A
NAME="B"
></A
>B</H1
><DL
><DT
><A
NAME="bash"
></A
><B
>bash</B
></DT
><DD
><P
>Bourne Again SHell.</P
></DD
><DT
><A
NAME="batch"
></A
><B
>batch</B
></DT
><DD
><P
>Queue, examine or delete jobs for later execution.</P
></DD
><DT
><A
NAME="bg"
></A
><B
>bg</B
></DT
><DD
><P
>Run a job in the background.</P
></DD
><DT
><A
NAME="bitmap"
></A
><B
>bitmap</B
></DT
><DD
><P
>Bitmap editor and converter utilities for the X window System.</P
></DD
><DT
><A
NAME="bzip2"
></A
><B
>bzip2</B
></DT
><DD
><P
>A block-sorting file compressor.</P
></DD
></DL
></DIV
><DIV
CLASS="glossdiv"
><H1
CLASS="glossdiv"
><A
NAME="C"
></A
>C</H1
><DL
><DT
><A
NAME="cat"
></A
><B
>cat</B
></DT
><DD
><P
>Concatenate files and print to standard output.</P
></DD
><DT
><A
NAME="cd"
></A
><B
>cd</B
></DT
><DD
><P
>Change directory.</P
></DD
><DT
><A
NAME="cdp"
></A
><B
>cdp/cdplay</B
></DT
><DD
><P
>An interactive text-mode program for controlling and playing
       audio CD Roms under Linux.</P
></DD
><DT
><A
NAME="cdparanoia"
></A
><B
>cdparanoia</B
></DT
><DD
><P
>An audio CD reading utility which
       includes extra data verification features.</P
></DD
><DT
><A
NAME="cdrecord"
></A
><B
>cdrecord</B
></DT
><DD
><P
>Record a CD-R.</P
></DD
><DT
><A
NAME="chattr"
></A
><B
>chattr</B
></DT
><DD
><P
>Change file attributes.</P
></DD
><DT
><A
NAME="chgrp"
></A
><B
>chgrp</B
></DT
><DD
><P
>Change group ownership.</P
></DD
><DT
><A
NAME="chkconfig"
></A
><B
>chkconfig</B
></DT
><DD
><P
>Update or query run level information for system services.</P
></DD
><DT
><A
NAME="chmod"
></A
><B
>chmod</B
></DT
><DD
><P
>Change file access permissions.</P
></DD
><DT
><A
NAME="chown"
></A
><B
>chown</B
></DT
><DD
><P
>Change file owner and group.</P
></DD
><DT
><A
NAME="compress"
></A
><B
>compress</B
></DT
><DD
><P
>Compress files.</P
></DD
><DT
><A
NAME="cp"
></A
><B
>cp</B
></DT
><DD
><P
>Copy files and directories.</P
></DD
><DT
><A
NAME="crontab"
></A
><B
>crontab</B
></DT
><DD
><P
>Maintain crontab files.</P
></DD
><DT
><A
NAME="csh"
></A
><B
>csh</B
></DT
><DD
><P
>Open a C shell.</P
></DD
><DT
><A
NAME="cut"
></A
><B
>cut</B
></DT
><DD
><P
>Remove sections from each line of file(s).</P
></DD
></DL
></DIV
><DIV
CLASS="glossdiv"
><H1
CLASS="glossdiv"
><A
NAME="D"
></A
>D</H1
><DL
><DT
><A
NAME="date"
></A
><B
>date</B
></DT
><DD
><P
>Print or set system date and time.</P
></DD
><DT
><A
NAME="dd"
></A
><B
>dd</B
></DT
><DD
><P
>Convert and copy a file (disk dump).</P
></DD
><DT
><A
NAME="df"
></A
><B
>df</B
></DT
><DD
><P
>Report file system disk usage.</P
></DD
><DT
><A
NAME="dhcpcd"
></A
><B
>dhcpcd</B
></DT
><DD
><P
>DHCP client daemon.</P
></DD
><DT
><A
NAME="diff"
></A
><B
>diff</B
></DT
><DD
><P
>Find differences between two files.</P
></DD
><DT
><A
NAME="dig"
></A
><B
>dig</B
></DT
><DD
><P
>Send domain name query packets to name servers.</P
></DD
><DT
><A
NAME="dmesg"
></A
><B
>dmesg</B
></DT
><DD
><P
>Print or control the kernel ring buffer.</P
></DD
><DT
><A
NAME="du"
></A
><B
>du</B
></DT
><DD
><P
>Estimate file space usage.</P
></DD
></DL
></DIV
><DIV
CLASS="glossdiv"
><H1
CLASS="glossdiv"
><A
NAME="E"
></A
>E</H1
><DL
><DT
><A
NAME="echo"
></A
><B
>echo</B
></DT
><DD
><P
>Display a line of text.</P
></DD
><DT
><A
NAME="ediff"
></A
><B
>ediff</B
></DT
><DD
><P
>Diff to English translator.</P
></DD
><DT
><A
NAME="egrep"
></A
><B
>egrep</B
></DT
><DD
><P
>Extended grep.</P
></DD
><DT
><A
NAME="eject"
></A
><B
>eject</B
></DT
><DD
><P
>Unmount and eject removable media.</P
></DD
><DT
><A
NAME="emacs"
></A
><B
>emacs</B
></DT
><DD
><P
>Start the Emacs editor.</P
></DD
><DT
><A
NAME="exec"
></A
><B
>exec</B
></DT
><DD
><P
>Invoke subprocess(es).</P
></DD
><DT
><A
NAME="exit"
></A
><B
>exit</B
></DT
><DD
><P
>Exit current shell.</P
></DD
><DT
><A
NAME="export"
></A
><B
>export</B
></DT
><DD
><P
>Add function(s) to the shell environment.</P
></DD
></DL
></DIV
><DIV
CLASS="glossdiv"
><H1
CLASS="glossdiv"
><A
NAME="F"
></A
>F</H1
><DL
><DT
><A
NAME="fax2ps"
></A
><B
>fax2ps</B
></DT
><DD
><P
>Convert a TIFF facsimile to PostScript.</P
></DD
><DT
><A
NAME="fdformat"
></A
><B
>fdformat</B
></DT
><DD
><P
>Format floppy disk.</P
></DD
><DT
><A
NAME="fdisk"
></A
><B
>fdisk</B
></DT
><DD
><P
>Partition table manipulator for Linux.</P
></DD
><DT
><A
NAME="fetchmail"
></A
><B
>fetchmail</B
></DT
><DD
><P
>Fetch mail from a POP, IMAP, ETRN or ODMR-capable server.</P
></DD
><DT
><A
NAME="fg"
></A
><B
>fg</B
></DT
><DD
><P
>Bring a job in the foreground.</P
></DD
><DT
><A
NAME="file"
></A
><B
>file</B
></DT
><DD
><P
>Determine file type.</P
></DD
><DT
><A
NAME="find"
></A
><B
>find</B
></DT
><DD
><P
>Find files.</P
></DD
><DT
><A
NAME="formail"
></A
><B
>formail</B
></DT
><DD
><P
>Mail (re)formatter.</P
></DD
><DT
><A
NAME="fortune"
></A
><B
>fortune</B
></DT
><DD
><P
>Print a random, hopefully interesting adage.</P
></DD
><DT
><A
NAME="ftp"
></A
><B
>ftp</B
></DT
><DD
><P
>Transfer files (unsafe unless anonymous account is used!)services.</P
></DD
></DL
></DIV
><DIV
CLASS="glossdiv"
><H1
CLASS="glossdiv"
><A
NAME="G"
></A
>G</H1
><DL
><DT
><A
NAME="galeon"
></A
><B
>galeon</B
></DT
><DD
><P
>Graphical web browser.</P
></DD
><DT
><A
NAME="gdm"
></A
><B
>gdm</B
></DT
><DD
><P
>Gnome Display Manager.</P
></DD
><DT
><A
NAME="getty"
></A
><B
>(min/a)getty</B
></DT
><DD
><P
>Control console devices.</P
></DD
><DT
><A
NAME="gimp"
></A
><B
>gimp</B
></DT
><DD
><P
>Image manipulation program.</P
></DD
><DT
><A
NAME="grep"
></A
><B
>grep</B
></DT
><DD
><P
>Print lines matching a pattern.</P
></DD
><DT
><A
NAME="grub"
></A
><B
>grub</B
></DT
><DD
><P
>The grub shell.</P
></DD
><DT
><A
NAME="gv"
></A
><B
>gv</B
></DT
><DD
><P
>A PostScript and PDF viewer.</P
></DD
><DT
><A
NAME="gzip"
></A
><B
>gzip</B
></DT
><DD
><P
>Compress or expand files.</P
></DD
></DL
></DIV
><DIV
CLASS="glossdiv"
><H1
CLASS="glossdiv"
><A
NAME="H"
></A
>H</H1
><DL
><DT
><A
NAME="halt"
></A
><B
>halt</B
></DT
><DD
><P
>Stop the system.</P
></DD
><DT
><A
NAME="head"
></A
><B
>head</B
></DT
><DD
><P
>Output the first part of files.</P
></DD
><DT
><A
NAME="help"
></A
><B
>help</B
></DT
><DD
><P
>Display help on a shell built-in command.</P
></DD
><DT
><A
NAME="host"
></A
><B
>host</B
></DT
><DD
><P
>DNS lookup utility.</P
></DD
><DT
><A
NAME="httpd"
></A
><B
>httpd</B
></DT
><DD
><P
>Apache hypertext transfer protocol server.</P
></DD
></DL
></DIV
><DIV
CLASS="glossdiv"
><H1
CLASS="glossdiv"
><A
NAME="I"
></A
>I</H1
><DL
><DT
><A
NAME="id"
></A
><B
>id</B
></DT
><DD
><P
>Print real and effective UIDs and GIDs.</P
></DD
><DT
><A
NAME="ifconfig"
></A
><B
>ifconfig</B
></DT
><DD
><P
>Configure network interface or show configuration.</P
></DD
><DT
><A
NAME="info"
></A
><B
>info</B
></DT
><DD
><P
>Read Info documents.</P
></DD
><DT
><A
NAME="init"
></A
><B
>init</B
></DT
><DD
><P
>Process control initialization.</P
></DD
><DT
><A
NAME="iostat"
></A
><B
>iostat</B
></DT
><DD
><P
>Display I/O statistics.</P
></DD
><DT
><A
NAME="ip"
></A
><B
>ip</B
></DT
><DD
><P
>Display/change network interface status.</P
></DD
><DT
><A
NAME="ipchains"
></A
><B
>ipchains</B
></DT
><DD
><P
>IP firewall administration.</P
></DD
><DT
><A
NAME="iptables"
></A
><B
>iptables</B
></DT
><DD
><P
>IP packet filter administration.</P
></DD
></DL
></DIV
><DIV
CLASS="glossdiv"
><H1
CLASS="glossdiv"
><A
NAME="J"
></A
>J</H1
><DL
><DT
><A
NAME="jar"
></A
><B
>jar</B
></DT
><DD
><P
>Java archive tool.</P
></DD
><DT
><A
NAME="jobs"
></A
><B
>jobs</B
></DT
><DD
><P
>List backgrounded tasks.</P
></DD
></DL
></DIV
><DIV
CLASS="glossdiv"
><H1
CLASS="glossdiv"
><A
NAME="K"
></A
>K</H1
><DL
><DT
><A
NAME="kdm"
></A
><B
>kdm</B
></DT
><DD
><P
>Desktop manager for KDE.</P
></DD
><DT
><A
NAME="kill"
></A
><B
>kill(all)</B
></DT
><DD
><P
>Terminate process(es).</P
></DD
><DT
><A
NAME="ksh"
></A
><B
>ksh</B
></DT
><DD
><P
>Open a Korn shell.</P
></DD
></DL
></DIV
><DIV
CLASS="glossdiv"
><H1
CLASS="glossdiv"
><A
NAME="L"
></A
>L</H1
><DL
><DT
><A
NAME="ldapmodify"
></A
><B
>ldapmodify</B
></DT
><DD
><P
>Modify an LDAP entry.</P
></DD
><DT
><A
NAME="ldapsearch"
></A
><B
>ldapsearch</B
></DT
><DD
><P
>LDAP search tool.</P
></DD
><DT
><A
NAME="less"
></A
><B
>less</B
></DT
><DD
><P
><B
CLASS="command"
>more</B
> with features.</P
></DD
><DT
><A
NAME="lilo"
></A
><B
>lilo</B
></DT
><DD
><P
>Linux boot loader.</P
></DD
><DT
><A
NAME="links"
></A
><B
>links</B
></DT
><DD
><P
>Text mode WWW browser.</P
></DD
><DT
><A
NAME="ln"
></A
><B
>ln</B
></DT
><DD
><P
>Make links between files.</P
></DD
><DT
><A
NAME="loadkeys"
></A
><B
>loadkeys</B
></DT
><DD
><P
>Load keyboard translation tables.</P
></DD
><DT
><A
NAME="locate"
></A
><B
>locate</B
></DT
><DD
><P
>Find files.</P
></DD
><DT
><A
NAME="logout"
></A
><B
>logout</B
></DT
><DD
><P
>Close current shell.</P
></DD
><DT
><A
NAME="lp"
></A
><B
>lp</B
></DT
><DD
><P
>Send requests to the LP print service.</P
></DD
><DT
><A
NAME="lpc"
></A
><B
>lpc</B
></DT
><DD
><P
>Line printer control program.</P
></DD
><DT
><A
NAME="lpq"
></A
><B
>lpq</B
></DT
><DD
><P
>Print spool queue examination program.</P
></DD
><DT
><A
NAME="lpr"
></A
><B
>lpr</B
></DT
><DD
><P
>Offline print.</P
></DD
><DT
><A
NAME="lprm"
></A
><B
>lprm</B
></DT
><DD
><P
>Remove print requests.</P
></DD
><DT
><A
NAME="ls"
></A
><B
>ls</B
></DT
><DD
><P
>List directory content.</P
></DD
><DT
><A
NAME="lynx"
></A
><B
>lynx</B
></DT
><DD
><P
>Text mode WWW browser.</P
></DD
></DL
></DIV
><DIV
CLASS="glossdiv"
><H1
CLASS="glossdiv"
><A
NAME="M"
></A
>M</H1
><DL
><DT
><A
NAME="mail"
></A
><B
>mail</B
></DT
><DD
><P
>Send and receive mail.</P
></DD
><DT
><A
NAME="man"
></A
><B
>man</B
></DT
><DD
><P
>Read man pages.</P
></DD
><DT
><A
NAME="mcopy"
></A
><B
>mcopy</B
></DT
><DD
><P
>Copy MSDOS files to/from Unix.</P
></DD
><DT
><A
NAME="mdir"
></A
><B
>mdir</B
></DT
><DD
><P
>Display an MSDOS directory.</P
></DD
><DT
><A
NAME="memusage"
></A
><B
>memusage</B
></DT
><DD
><P
>Display memory usage.</P
></DD
><DT
><A
NAME="memusagestat"
></A
><B
>memusagestat</B
></DT
><DD
><P
>Display memory usage statistics.</P
></DD
><DT
><A
NAME="mesg"
></A
><B
>mesg</B
></DT
><DD
><P
>Control write access to your terminal.</P
></DD
><DT
><A
NAME="mformat"
></A
><B
>mformat</B
></DT
><DD
><P
>Add an MSDOS file system to a low-level formatted floppy disk.</P
></DD
><DT
><A
NAME="mkbootdisk"
></A
><B
>mkbootdisk</B
></DT
><DD
><P
>Creates a stand-alone boot floppy for the running system.</P
></DD
><DT
><A
NAME="mkdir"
></A
><B
>mkdir</B
></DT
><DD
><P
>Create directory.</P
></DD
><DT
><A
NAME="mkisofs"
></A
><B
>mkisofs</B
></DT
><DD
><P
>Create a hybrid ISO9660 filesystem.</P
></DD
><DT
><A
NAME="more"
></A
><B
>more</B
></DT
><DD
><P
>Filter for displaying text one screen at the time.</P
></DD
><DT
><A
NAME="mount"
></A
><B
>mount</B
></DT
><DD
><P
>Mount a file system or display information about mounted file systems.</P
></DD
><DT
><A
NAME="mozilla"
></A
><B
>mozilla</B
></DT
><DD
><P
>Web browser.</P
></DD
><DT
><A
NAME="mt"
></A
><B
>mt</B
></DT
><DD
><P
>Control magnetic tape drive operation.</P
></DD
><DT
><A
NAME="mtr"
></A
><B
>mtr</B
></DT
><DD
><P
>Network diagnostic tool.</P
></DD
><DT
><A
NAME="mv"
></A
><B
>mv</B
></DT
><DD
><P
>Rename files.</P
></DD
></DL
></DIV
><DIV
CLASS="glossdiv"
><H1
CLASS="glossdiv"
><A
NAME="N"
></A
>N</H1
><DL
><DT
><A
NAME="named"
></A
><B
>named</B
></DT
><DD
><P
>Internet domain name server.</P
></DD
><DT
><A
NAME="ncftp"
></A
><B
>ncftp</B
></DT
><DD
><P
>Browser program for ftp services (insecure!).</P
></DD
><DT
><A
NAME="netstat"
></A
><B
>netstat</B
></DT
><DD
><P
>Print network connections, routing tables, interface statistics, masquerade connections, and multi-cast memberships.</P
></DD
><DT
><A
NAME="nfsstat"
></A
><B
>nfsstat</B
></DT
><DD
><P
>Print statistics about networked file systems.</P
></DD
><DT
><A
NAME="nice"
></A
><B
>nice</B
></DT
><DD
><P
>Run a program with modified scheduling priority.</P
></DD
><DT
><A
NAME="nmap"
></A
><B
>nmap</B
></DT
><DD
><P
>Network exploration tool and security scanner.</P
></DD
><DT
><A
NAME="ntsysv"
></A
><B
>ntsysv</B
></DT
><DD
><P
>Simple interface for configuring run levels.</P
></DD
></DL
></DIV
><DIV
CLASS="glossdiv"
><H1
CLASS="glossdiv"
><A
NAME="P"
></A
>P</H1
><DL
><DT
><A
NAME="passwd"
></A
><B
>passwd</B
></DT
><DD
><P
>Change password.</P
></DD
><DT
><A
NAME="pdf2ps"
></A
><B
>pdf2ps</B
></DT
><DD
><P
>Ghostscript PDF to PostScript translator.</P
></DD
><DT
><A
NAME="perl"
></A
><B
>perl</B
></DT
><DD
><P
>Practical Extraction and Report Language.</P
></DD
><DT
><A
NAME="pg"
></A
><B
>pg</B
></DT
><DD
><P
>Page through text output.</P
></DD
><DT
><A
NAME="ping"
></A
><B
>ping</B
></DT
><DD
><P
>Send echo request to a host.</P
></DD
><DT
><A
NAME="pr"
></A
><B
>pr</B
></DT
><DD
><P
>Convert text files for printing.</P
></DD
><DT
><A
NAME="printenv"
></A
><B
>printenv</B
></DT
><DD
><P
>Print all or part of environment.</P
></DD
><DT
><A
NAME="procmail"
></A
><B
>procmail</B
></DT
><DD
><P
>Autonomous mail processor.</P
></DD
><DT
><A
NAME="ps"
></A
><B
>ps</B
></DT
><DD
><P
>Report process status.</P
></DD
><DT
><A
NAME="pstree"
></A
><B
>pstree</B
></DT
><DD
><P
>Display a tree of processes.</P
></DD
><DT
><A
NAME="pwd"
></A
><B
>pwd</B
></DT
><DD
><P
>Print present working directory.</P
></DD
></DL
></DIV
><DIV
CLASS="glossdiv"
><H1
CLASS="glossdiv"
><A
NAME="Q"
></A
>Q</H1
><DL
><DT
><A
NAME="quota"
></A
><B
>quota</B
></DT
><DD
><P
>Display disk usage and limits.</P
></DD
></DL
></DIV
><DIV
CLASS="glossdiv"
><H1
CLASS="glossdiv"
><A
NAME="R"
></A
>R</H1
><DL
><DT
><A
NAME="rcp"
></A
><B
>rcp</B
></DT
><DD
><P
>Remote copy (unsafe!)</P
></DD
><DT
><A
NAME="rdesktop"
></A
><B
>rdesktop</B
></DT
><DD
><P
>Remote Desktop Protocol client.</P
></DD
><DT
><A
NAME="reboot"
></A
><B
>reboot</B
></DT
><DD
><P
>Stop and restart the system.</P
></DD
><DT
><A
NAME="renice"
></A
><B
>renice</B
></DT
><DD
><P
>Alter priority of a running process.</P
></DD
><DT
><A
NAME="rlogin"
></A
><B
>rlogin</B
></DT
><DD
><P
>Remote login (telnet, insecure!).</P
></DD
><DT
><A
NAME="rm"
></A
><B
>rm</B
></DT
><DD
><P
>Remove a file.</P
></DD
><DT
><A
NAME="rmdir"
></A
><B
>rmdir</B
></DT
><DD
><P
>Remove a directory.</P
></DD
><DT
><A
NAME="rpm"
></A
><B
>rpm</B
></DT
><DD
><P
>RPM Package Manager.</P
></DD
><DT
><A
NAME="rsh"
></A
><B
>rsh</B
></DT
><DD
><P
>Remote shell (insecure!).</P
></DD
></DL
></DIV
><DIV
CLASS="glossdiv"
><H1
CLASS="glossdiv"
><A
NAME="S"
></A
>S</H1
><DL
><DT
><A
NAME="scp"
></A
><B
>scp</B
></DT
><DD
><P
>Secure remote copy.</P
></DD
><DT
><A
NAME="screen"
></A
><B
>screen</B
></DT
><DD
><P
>Screen manager with VT100 emulation.</P
></DD
><DT
><A
NAME="set"
></A
><B
>set</B
></DT
><DD
><P
>Display, set or change variable.</P
></DD
><DT
><A
NAME="setterm"
></A
><B
>setterm</B
></DT
><DD
><P
>Set terminal attributes.</P
></DD
><DT
><A
NAME="sftp"
></A
><B
>sftp</B
></DT
><DD
><P
>Secure (encrypted) ftp.</P
></DD
><DT
><A
NAME="sh"
></A
><B
>sh</B
></DT
><DD
><P
>Open a standard shell.</P
></DD
><DT
><A
NAME="shutdown"
></A
><B
>shutdown</B
></DT
><DD
><P
>Bring the system down.</P
></DD
><DT
><A
NAME="sleep"
></A
><B
>sleep</B
></DT
><DD
><P
>Wait for a given period.</P
></DD
><DT
><A
NAME="slocate"
></A
><B
>slocate</B
></DT
><DD
><P
>Security Enhanced version of the GNU Locate.</P
></DD
><DT
><A
NAME="slrnn"
></A
><B
>slrnn</B
></DT
><DD
><P
>text mode Usenet client.</P
></DD
><DT
><A
NAME="snort"
></A
><B
>snort</B
></DT
><DD
><P
>Network intrusion detection tool.</P
></DD
><DT
><A
NAME="sort"
></A
><B
>sort</B
></DT
><DD
><P
>Sort lines of text files.</P
></DD
><DT
><A
NAME="ssh"
></A
><B
>ssh</B
></DT
><DD
><P
>Secure shell.</P
></DD
><DT
><A
NAME="ssh-keygen"
></A
><B
>ssh-keygen</B
></DT
><DD
><P
>Authentication key generation.</P
></DD
><DT
><A
NAME="stty"
></A
><B
>stty</B
></DT
><DD
><P
>Change and print terminal line settings.</P
></DD
><DT
><A
NAME="su"
></A
><B
>su</B
></DT
><DD
><P
>Switch user.</P
></DD
></DL
></DIV
><DIV
CLASS="glossdiv"
><H1
CLASS="glossdiv"
><A
NAME="T"
></A
>T</H1
><DL
><DT
><A
NAME="tac"
></A
><B
>tac</B
></DT
><DD
><P
>Concatenate and print files in reverse.</P
></DD
><DT
><A
NAME="tail"
></A
><B
>tail</B
></DT
><DD
><P
>Output the last part of files.</P
></DD
><DT
><A
NAME="talk"
></A
><B
>talk</B
></DT
><DD
><P
>Talk to a user.</P
></DD
><DT
><A
NAME="tar"
></A
><B
>tar</B
></DT
><DD
><P
>Archiving utility.</P
></DD
><DT
><A
NAME="tcsh"
></A
><B
>tcsh</B
></DT
><DD
><P
>Open a Turbo C shell.</P
></DD
><DT
><A
NAME="telnet"
></A
><B
>telnet</B
></DT
><DD
><P
>User interface to the TELNET protocol (insecure!).</P
></DD
><DT
><A
NAME="tex"
></A
><B
>tex</B
></DT
><DD
><P
>Text formatting and typesetting.</P
></DD
><DT
><A
NAME="time"
></A
><B
>time</B
></DT
><DD
><P
>Time a simple command or give resource usage.</P
></DD
><DT
><A
NAME="tin"
></A
><B
>tin</B
></DT
><DD
><P
>News reading program.</P
></DD
><DT
><A
NAME="top"
></A
><B
>top</B
></DT
><DD
><P
>Display top CPU processes.</P
></DD
><DT
><A
NAME="touch"
></A
><B
>touch</B
></DT
><DD
><P
>Change file timestamps.</P
></DD
><DT
><A
NAME="traceroute"
></A
><B
>traceroute</B
></DT
><DD
><P
>Print the route packets take to network host.</P
></DD
><DT
><A
NAME="tripwire"
></A
><B
>tripwire</B
></DT
><DD
><P
>A file integrity checker for UNIX systems.</P
></DD
><DT
><A
NAME="twm"
></A
><B
>twm</B
></DT
><DD
><P
>Tab Window Manager for the X Window System.</P
></DD
></DL
></DIV
><DIV
CLASS="glossdiv"
><H1
CLASS="glossdiv"
><A
NAME="U"
></A
>U</H1
><DL
><DT
><A
NAME="ulimit"
></A
><B
>ulimit</B
></DT
><DD
><P
>Controll resources.</P
></DD
><DT
><A
NAME="umask"
></A
><B
>umask</B
></DT
><DD
><P
>Set user file creation mask.</P
></DD
><DT
><A
NAME="umount"
></A
><B
>umount</B
></DT
><DD
><P
>Unmount a file system.</P
></DD
><DT
><A
NAME="uncompress"
></A
><B
>uncompress</B
></DT
><DD
><P
>Decompress compressed files.</P
></DD
><DT
><A
NAME="uniq"
></A
><B
>uniq</B
></DT
><DD
><P
>Remove duplicate lines from a sorted file.</P
></DD
><DT
><A
NAME="update"
></A
><B
>update</B
></DT
><DD
><P
>Kernel daemon to flush dirty buffers back to disk.</P
></DD
><DT
><A
NAME="uptime"
></A
><B
>uptime</B
></DT
><DD
><P
>Display system uptime and average load.</P
></DD
><DT
><A
NAME="userdel"
></A
><B
>userdel</B
></DT
><DD
><P
>Delete a user account and related files.</P
></DD
></DL
></DIV
><DIV
CLASS="glossdiv"
><H1
CLASS="glossdiv"
><A
NAME="V"
></A
>V</H1
><DL
><DT
><A
NAME="vi"
></A
><B
>vi(m)</B
></DT
><DD
><P
>Start the vi (improved) editor.</P
></DD
><DT
><A
NAME="vimtutor"
></A
><B
>vimtutor</B
></DT
><DD
><P
>The Vim tutor.</P
></DD
><DT
><A
NAME="vmstat"
></A
><B
>vmstat</B
></DT
><DD
><P
>Report virtual memory statistics.</P
></DD
></DL
></DIV
><DIV
CLASS="glossdiv"
><H1
CLASS="glossdiv"
><A
NAME="W"
></A
>W</H1
><DL
><DT
><A
NAME="w"
></A
><B
>w</B
></DT
><DD
><P
>Show who is logged on and what they are doing.</P
></DD
><DT
><A
NAME="wall"
></A
><B
>wall</B
></DT
><DD
><P
>Send a message to everybody's terminal.</P
></DD
><DT
><A
NAME="wc"
></A
><B
>wc</B
></DT
><DD
><P
>Print the number of bytes, words and lines in files.</P
></DD
><DT
><A
NAME="which"
></A
><B
>which</B
></DT
><DD
><P
>Shows the full path of (shell) commands.</P
></DD
><DT
><A
NAME="who"
></A
><B
>who</B
></DT
><DD
><P
>Show who is logged on.</P
></DD
><DT
><A
NAME="whoami"
></A
><B
>who am i</B
></DT
><DD
><P
>Print effective user ID.</P
></DD
><DT
><A
NAME="whois"
></A
><B
>whois</B
></DT
><DD
><P
>Query a whois or nicname database.</P
></DD
><DT
><A
NAME="write"
></A
><B
>write</B
></DT
><DD
><P
>Send a message to another user.</P
></DD
></DL
></DIV
><DIV
CLASS="glossdiv"
><H1
CLASS="glossdiv"
><A
NAME="X"
></A
>X</H1
><DL
><DT
><A
NAME="xauth"
></A
><B
>xauth</B
></DT
><DD
><P
>X authority file utility.</P
></DD
><DT
><A
NAME="xcdroast"
></A
><B
>xcdroast</B
></DT
><DD
><P
>Graphical front end to cdrecord.</P
></DD
><DT
><A
NAME="xclock"
></A
><B
>xclock</B
></DT
><DD
><P
>Analog/digital clock for X.</P
></DD
><DT
><A
NAME="xconsole"
></A
><B
>xconsole</B
></DT
><DD
><P
>Monitor system console messages with X.</P
></DD
><DT
><A
NAME="xdm"
></A
><B
>xdm</B
></DT
><DD
><P
>X Display Manager with support for XDMCP, host chooser.</P
></DD
><DT
><A
NAME="xdvi"
></A
><B
>xdvi</B
></DT
><DD
><P
>DVI viewer.</P
></DD
><DT
><A
NAME="xfs"
></A
><B
>xfs</B
></DT
><DD
><P
>X font server.</P
></DD
><DT
><A
NAME="xhost"
></A
><B
>xhost</B
></DT
><DD
><P
>Server access control program for X</P
></DD
><DT
><A
NAME="xinetd"
></A
><B
>xinetd</B
></DT
><DD
><P
>The extended Internet services daemon.</P
></DD
><DT
><A
NAME="xload"
></A
><B
>xload</B
></DT
><DD
><P
>System load average display for X.</P
></DD
><DT
><A
NAME="xlsfonts"
></A
><B
>xlsfonts</B
></DT
><DD
><P
>Server font list displayer for X.</P
></DD
><DT
><A
NAME="xmms"
></A
><B
>xmms</B
></DT
><DD
><P
>Audio player for X.</P
></DD
><DT
><A
NAME="xpdf"
></A
><B
>xpdf</B
></DT
><DD
><P
>PDF viewer.</P
></DD
><DT
><A
NAME="xterm"
></A
><B
>xterm</B
></DT
><DD
><P
>Terminal emulator for X.</P
></DD
></DL
></DIV
><DIV
CLASS="glossdiv"
><H1
CLASS="glossdiv"
><A
NAME="Z"
></A
>Z</H1
><DL
><DT
><A
NAME="zcat"
></A
><B
>zcat</B
></DT
><DD
><P
>Compress or expand files.</P
></DD
><DT
><A
NAME="zgrep"
></A
><B
>zgrep</B
></DT
><DD
><P
>Search possibly compressed files for a regular expression.</P
></DD
><DT
><A
NAME="zmore"
></A
><B
>zmore</B
></DT
><DD
><P
>Filter for viewing compressed text.</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="GLOSSARY"
><H1
><A
NAME="glossary"
></A
>Index</H1
><DIV
CLASS="glossdiv"
><H1
CLASS="glossdiv"
><A
NAME="A"
></A
>A</H1
><DL
><DT
><A
NAME="aliases"
></A
><B
>aliases</B
></DT
><DD
><P
><A
HREF="#sect_03_05_01"
>Section 3.5.1</A
></P
></DD
><DT
><A
NAME="ansiquoting"
></A
><B
>ANSI-C quoting</B
></DT
><DD
><P
><A
HREF="#sect_03_03_05"
>Section 3.3.5</A
></P
></DD
><DT
><A
NAME="arguments"
></A
><B
>arguments</B
></DT
><DD
><P
><A
HREF="#sect_07_02_01_02"
>Section 7.2.1.2</A
></P
></DD
><DT
><A
NAME="arithmexpand"
></A
><B
>arithmetic expansion</B
></DT
><DD
><P
><A
HREF="#sect_03_04_06"
>Section 3.4.7</A
></P
></DD
><DT
><A
NAME="arithmops"
></A
><B
>arithmetic operators</B
></DT
><DD
><P
><A
HREF="#sect_03_04_06"
>Section 3.4.7</A
></P
></DD
><DT
><A
NAME="array"
></A
><B
>array</B
></DT
><DD
><P
><A
HREF="#sect_10_02_01"
>Section 10.2.1</A
></P
></DD
><DT
><A
NAME="awk"
></A
><B
>awk</B
></DT
><DD
><P
><A
HREF="#sect_06_01"
>Section 6.1</A
></P
></DD
><DT
><A
NAME="awkprogram"
></A
><B
>awkprogram</B
></DT
><DD
><P
><A
HREF="#sect_06_01_02"
>Section 6.1.2</A
></P
></DD
></DL
></DIV
><DIV
CLASS="glossdiv"
><H1
CLASS="glossdiv"
><A
NAME="B"
></A
>B</H1
><DL
><DT
><A
NAME="bash"
></A
><B
>bash</B
></DT
><DD
><P
><A
HREF="#sect_01_02"
>Section 1.2</A
></P
></DD
><DT
><A
NAME="bashlogin"
></A
><B
>.bash_login</B
></DT
><DD
><P
><A
HREF="#sect_03_01_02_02"
>Section 3.1.2.2</A
></P
></DD
><DT
><A
NAME="bash_logout"
></A
><B
>.bash_logout</B
></DT
><DD
><P
><A
HREF="#sect_03_01_02_05"
>Section 3.1.2.5</A
></P
></DD
><DT
><A
NAME="bashprofile"
></A
><B
>.bash_profile</B
></DT
><DD
><P
><A
HREF="#sect_03_01_02_01"
>Section 3.1.2.1</A
></P
></DD
><DT
><A
NAME="bash"
></A
><B
>.bashrc</B
></DT
><DD
><P
><A
HREF="#sect_03_01_02_04"
>Section 3.1.2.4</A
></P
></DD
><DT
><A
NAME="batchedit"
></A
><B
>batch editor</B
></DT
><DD
><P
><A
HREF="#sect_05_01_01"
>Section 5.1.1</A
></P
></DD
><DT
><A
NAME="break"
></A
><B
>break</B
></DT
><DD
><P
><A
HREF="#sect_09_05_01"
>Section 9.5.1</A
></P
></DD
><DT
><A
NAME="booleanops"
></A
><B
>boolean operators</B
></DT
><DD
><P
><A
HREF="#sect_07_02_04"
>Section 7.2.4</A
></P
></DD
><DT
><A
NAME="bourne"
></A
><B
>Bourne shell</B
></DT
><DD
><P
><A
HREF="#sect_01_01_02"
>Section 1.1.2</A
></P
></DD
><DT
><A
NAME="brace-expand"
></A
><B
>brace expansion</B
></DT
><DD
><P
><A
HREF="#sect_03_04_02"
>Section 3.4.3</A
></P
></DD
><DT
><A
NAME="built-in"
></A
><B
>built-in commands</B
></DT
><DD
><P
><A
HREF="#sect_01_03_02"
>Section 1.3.2</A
></P
></DD
></DL
></DIV
><DIV
CLASS="glossdiv"
><H1
CLASS="glossdiv"
><A
NAME="C"
></A
>C</H1
><DL
><DT
><A
NAME="case"
></A
><B
>case statements</B
></DT
><DD
><P
><A
HREF="#sect_07_02_05"
>Section 7.2.5</A
></P
></DD
><DT
><A
NAME="charclass"
></A
><B
>character classes</B
></DT
><DD
><P
><A
HREF="#sect_04_02_02_02"
>Section 4.2.2.2</A
>, <A
HREF="#sect_04_03_02"
>Section 4.3.2</A
></P
></DD
><DT
><A
NAME="child"
></A
><B
>child process</B
></DT
><DD
><P
><A
HREF="#sect_01_03_01"
>Section 1.3.1</A
></P
></DD
><DT
><A
NAME="combexrs"
></A
><B
>combined expressions</B
></DT
><DD
><P
><A
HREF="#sect_07_01_01_01"
>Section 7.1.1.1</A
></P
></DD
><DT
><A
NAME="commandsubst"
></A
><B
>command substitution</B
></DT
><DD
><P
><A
HREF="#sect_03_04_05"
>Section 3.4.6</A
></P
></DD
><DT
><A
NAME="comments"
></A
><B
>comments</B
></DT
><DD
><P
><A
HREF="#sect_02_02_02"
>Section 2.2.2</A
></P
></DD
><DT
><A
NAME="conditionals"
></A
><B
>conditionals</B
></DT
><DD
><P
><A
HREF="#sect_07_01"
>Section 7.1</A
></P
></DD
><DT
><A
NAME="configfiles"
></A
><B
>configuration files</B
></DT
><DD
><P
><A
HREF="#sect_03_01"
>Section 3.1</A
></P
></DD
><DT
><A
NAME="constants"
></A
><B
>constants</B
></DT
><DD
><P
><A
HREF="#sect_10_01_03"
>Section 10.1.3</A
></P
></DD
><DT
><A
NAME="continue"
></A
><B
>continue</B
></DT
><DD
><P
><A
HREF="#sect_09_05_02"
>Section 9.5.2</A
></P
></DD
><DT
><A
NAME="controlsigs"
></A
><B
>control signals</B
></DT
><DD
><P
><A
HREF="#sect_12_01_01_03"
>Section 12.1.1.3</A
></P
></DD
><DT
><A
NAME="createvars"
></A
><B
>creating variables</B
></DT
><DD
><P
><A
HREF="#sect_03_02_02"
>Section 3.2.2</A
></P
></DD
><DT
><A
NAME="csh"
></A
><B
>csh</B
></DT
><DD
><P
>The C shell, <A
HREF="#sect_01_01_02"
>Section 1.1.2</A
></P
></DD
></DL
></DIV
><DIV
CLASS="glossdiv"
><H1
CLASS="glossdiv"
><A
NAME="D"
></A
>D</H1
><DL
><DT
><A
NAME="debugging"
></A
><B
>debugging scripts</B
></DT
><DD
><P
><A
HREF="#sect_02_03"
>Section 2.3</A
></P
></DD
><DT
><A
NAME="declare"
></A
><B
>declare</B
></DT
><DD
><P
><A
HREF="#sect_10_01_02"
>Section 10.1.2</A
>, <A
HREF="#sect_10_02_01"
>Section 10.2.1</A
></P
></DD
><DT
><A
NAME="doublequotes"
></A
><B
>double quotes</B
></DT
><DD
><P
><A
HREF="#sect_03_03_04"
>Section 3.3.4</A
></P
></DD
></DL
></DIV
><DIV
CLASS="glossdiv"
><H1
CLASS="glossdiv"
><A
NAME="E"
></A
>E</H1
><DL
><DT
><A
NAME="echo"
></A
><B
>echo</B
></DT
><DD
><P
><A
HREF="#sect_01_05_05"
>Section 1.5.5</A
>, <A
HREF="#sect_02_01_02"
>Section 2.1.2</A
>, <A
HREF="#sect_02_03_02"
>Section 2.3.2</A
>, <A
HREF="#sect_08_01_02"
>Section 8.1.2</A
></P
></DD
><DT
><A
NAME="editors"
></A
><B
>editors</B
></DT
><DD
><P
><A
HREF="#sect_02_01_01"
>Section 2.1.1</A
></P
></DD
><DT
><A
NAME="else"
></A
><B
>else</B
></DT
><DD
><P
><A
HREF="#sect_07_02_01"
>Section 7.2.1</A
></P
></DD
><DT
><A
NAME="emacs"
></A
><B
>emacs</B
></DT
><DD
><P
><A
HREF="#sect_02_01_01"
>Section 2.1.1</A
></P
></DD
><DT
><A
NAME="env"
></A
><B
>env</B
></DT
><DD
><P
><A
HREF="#sect_03_02_01_01"
>Section 3.2.1.1</A
></P
></DD
><DT
><A
NAME="esac"
></A
><B
>esac</B
></DT
><DD
><P
><A
HREF="#sect_07_02_05"
>Section 7.2.5</A
></P
></DD
><DT
><A
NAME="escapechars"
></A
><B
>escape characters</B
></DT
><DD
><P
><A
HREF="#sect_03_03_02"
>Section 3.3.2</A
></P
></DD
><DT
><A
NAME="escapeseqs"
></A
><B
>escape sequences</B
></DT
><DD
><P
><A
HREF="#sect_08_01_02"
>Section 8.1.2</A
></P
></DD
><DT
><A
NAME="etcbashrc"
></A
><B
>/etc/bashrc</B
></DT
><DD
><P
><A
HREF="#sect_03_01_01_02"
>Section 3.1.1.2</A
></P
></DD
><DT
><A
NAME="passwd"
></A
><B
>/etc/passwd</B
></DT
><DD
><P
><A
HREF="#sect_01_01_02"
>Section 1.1.2</A
></P
></DD
><DT
><A
NAME="etcprofile"
></A
><B
>/etc/profile</B
></DT
><DD
><P
><A
HREF="#sect_03_01_01"
>Section 3.1.1</A
></P
></DD
><DT
><A
NAME="shells"
></A
><B
>/etc/shells</B
></DT
><DD
><P
><A
HREF="#sect_01_01_02"
>Section 1.1.2</A
></P
></DD
><DT
><A
NAME="exec"
></A
><B
>exec</B
></DT
><DD
><P
><A
HREF="#sect_01_03_01"
>Section 1.3.1</A
>, <A
HREF="#sect_08_02_04_02"
>Section 8.2.4.2</A
></P
></DD
><DT
><A
NAME="execute"
></A
><B
>execute permissions</B
></DT
><DD
><P
><A
HREF="#sect_02_01_03"
>Section 2.1.3</A
></P
></DD
><DT
><A
NAME="execution"
></A
><B
>execution</B
></DT
><DD
><P
><A
HREF="#sect_02_01_03"
>Section 2.1.3</A
></P
></DD
><DT
><A
NAME="exit"
></A
><B
>exit</B
></DT
><DD
><P
><A
HREF="#sect_07_02_05"
>Section 7.2.5</A
></P
></DD
><DT
><A
NAME="exitstatus"
></A
><B
>exit status</B
></DT
><DD
><P
><A
HREF="#sect_07_01_02_01"
>Section 7.1.2.1</A
></P
></DD
><DT
><A
NAME="expansion"
></A
><B
>expansion</B
></DT
><DD
><P
><A
HREF="#sect_01_04_01_05"
>Section 1.4.1.5</A
>, <A
HREF="#sect_03_04"
>Section 3.4</A
></P
></DD
><DT
><A
NAME="export"
></A
><B
>export</B
></DT
><DD
><P
><A
HREF="#sect_03_02_03"
>Section 3.2.3</A
></P
></DD
><DT
><A
NAME="extendedregexps"
></A
><B
>extended regular expressions</B
></DT
><DD
><P
><A
HREF="#sect_04_01_03"
>Section 4.1.3</A
></P
></DD
></DL
></DIV
><DIV
CLASS="glossdiv"
><H1
CLASS="glossdiv"
><A
NAME="F"
></A
>F</H1
><DL
><DT
><A
NAME="fd"
></A
><B
>file descriptors</B
></DT
><DD
><P
><A
HREF="#sect_08_02_03"
>Section 8.2.3</A
>, <A
HREF="#sect_08_02_04_01"
>Section 8.2.4.1</A
></P
></DD
><DT
><A
NAME="fileexpand"
></A
><B
>file name expansion</B
></DT
><DD
><P
><A
HREF="#sect_03_04_08"
>Section 3.4.9</A
></P
></DD
><DT
><A
NAME="findreplace"
></A
><B
>find and replace</B
></DT
><DD
><P
><A
HREF="#sect_05_02_04"
>Section 5.2.4</A
></P
></DD
><DT
><A
NAME="for"
></A
><B
>for</B
></DT
><DD
><P
><A
HREF="#sect_09_01"
>Section 9.1</A
></P
></DD
><DT
><A
NAME="fork"
></A
><B
>fork</B
></DT
><DD
><P
><A
HREF="#sect_01_03_01"
>Section 1.3.1</A
></P
></DD
><DT
><A
NAME="functions"
></A
><B
>functions</B
></DT
><DD
><P
><A
HREF="#sect_11_01_01"
>Section 11.1.1</A
></P
></DD
></DL
></DIV
><DIV
CLASS="glossdiv"
><H1
CLASS="glossdiv"
><A
NAME="G"
></A
>G</H1
><DL
><DT
><A
NAME="gawk"
></A
><B
>gawk</B
></DT
><DD
><P
><A
HREF="#sect_06_01_01"
>Section 6.1.1</A
></P
></DD
><DT
><A
NAME="gawkcommands"
></A
><B
>gawk commands</B
></DT
><DD
><P
><A
HREF="#sect_06_01_02"
>Section 6.1.2</A
></P
></DD
><DT
><A
NAME="gawkfields"
></A
><B
>gawk fields</B
></DT
><DD
><P
><A
HREF="#sect_06_02_01"
>Section 6.2.1</A
></P
></DD
><DT
><A
NAME="gawkformatting"
></A
><B
>gawk formatting</B
></DT
><DD
><P
><A
HREF="#sect_06_02_02"
>Section 6.2.2</A
></P
></DD
><DT
><A
NAME="gawkscripts"
></A
><B
>gawk scripts</B
></DT
><DD
><P
><A
HREF="#sect_06_02_05"
>Section 6.2.5</A
></P
></DD
><DT
><A
NAME="gawkvars"
></A
><B
>gawk variables</B
></DT
><DD
><P
><A
HREF="#sect_06_03"
>Section 6.3</A
></P
></DD
><DT
><A
NAME="gedit"
></A
><B
>gedit</B
></DT
><DD
><P
><A
HREF="#sect_02_01_01"
>Section 2.1.1</A
></P
></DD
><DT
><A
NAME="globalvars"
></A
><B
>global variables</B
></DT
><DD
><P
><A
HREF="#sect_03_02_01_01"
>Section 3.2.1.1</A
></P
></DD
><DT
><A
NAME="globbing"
></A
><B
>globbing</B
></DT
><DD
><P
><A
HREF="#sect_02_03_02"
>Section 2.3.2</A
></P
></DD
><DT
><A
NAME="grep"
></A
><B
>grep</B
></DT
><DD
><P
><A
HREF="#sect_04_02_01"
>Section 4.2.1</A
></P
></DD
></DL
></DIV
><DIV
CLASS="glossdiv"
><H1
CLASS="glossdiv"
><A
NAME="H"
></A
>H</H1
><DL
><DT
><A
NAME="heredoc"
></A
><B
>here document</B
></DT
><DD
><P
><A
HREF="#sect_08_02_04_04"
>Section 8.2.4.4</A
></P
></DD
></DL
></DIV
><DIV
CLASS="glossdiv"
><H1
CLASS="glossdiv"
><A
NAME="I"
></A
>I</H1
><DL
><DT
><A
NAME="if"
></A
><B
>if</B
></DT
><DD
><P
><A
HREF="#sect_07_01_01"
>Section 7.1.1</A
></P
></DD
><DT
><A
NAME="init"
></A
><B
>init</B
></DT
><DD
><P
><A
HREF="#sect_01_03_01"
>Section 1.3.1</A
>, <A
HREF="#sect_01_05_06"
>Section 1.5.6</A
></P
></DD
><DT
><A
NAME="initfiles"
></A
><B
>initialization files</B
></DT
><DD
><P
><A
HREF="#sect_03_01"
>Section 3.1</A
></P
></DD
><DT
><A
NAME="awkfieldsep"
></A
><B
>input field separator</B
></DT
><DD
><P
><A
HREF="#sect_03_02_04_01"
>Section 3.2.4.1</A
>, <A
HREF="#sect_03_02_05"
>Section 3.2.5</A
>, <A
HREF="#sect_06_03"
>Section 6.3</A
></P
></DD
><DT
><A
NAME="interactiveedit"
></A
><B
>interactive editing</B
></DT
><DD
><P
><A
HREF="#sect_05_02"
>Section 5.2</A
></P
></DD
><DT
><A
NAME="interactivescripts"
></A
><B
>interactive scripts</B
></DT
><DD
><P
><A
HREF="#sect_08_01"
>Section 8.1</A
></P
></DD
><DT
><A
NAME="interactive"
></A
><B
>interactive shell</B
></DT
><DD
><P
><A
HREF="#sect_01_02_02_02_01"
>Section 1.2.2.2.1</A
>, <A
HREF="#sect_01_02_02_02_02"
>Section 1.2.2.2.2</A
>, <A
HREF="#sect_01_02_02_03_03"
>Section 1.2.2.3.3</A
></P
></DD
><DT
><A
NAME="invocation"
></A
><B
>invocation</B
></DT
><DD
><P
><A
HREF="#sect_01_02_02_01"
>Section 1.2.2.1</A
></P
></DD
></DL
></DIV
><DIV
CLASS="glossdiv"
><H1
CLASS="glossdiv"
><A
NAME="J"
></A
>J</H1
><DL
><DT
><A
NAME=""
></A
><B
></B
></DT
><DD
><P
></P
></DD
></DL
></DIV
><DIV
CLASS="glossdiv"
><H1
CLASS="glossdiv"
><A
NAME="K"
></A
>K</H1
><DL
><DT
><A
NAME="kill"
></A
><B
>kill</B
></DT
><DD
><P
><A
HREF="#sect_12_01_02"
>Section 12.1.2</A
></P
></DD
><DT
><A
NAME="killall"
></A
><B
>killall</B
></DT
><DD
><P
><A
HREF="#sect_12_01_02"
>Section 12.1.2</A
></P
></DD
><DT
><A
NAME="ksh"
></A
><B
>ksh</B
></DT
><DD
><P
>Korn shell, <A
HREF="#sect_01_01_02"
>Section 1.1.2</A
></P
></DD
></DL
></DIV
><DIV
CLASS="glossdiv"
><H1
CLASS="glossdiv"
><A
NAME="L"
></A
>L</H1
><DL
><DT
><A
NAME="length"
></A
><B
>length of a variable</B
></DT
><DD
><P
><A
HREF="#sect_10_03_02"
>Section 10.3.2</A
></P
></DD
><DT
><A
NAME="lineanchor"
></A
><B
>line anchors</B
></DT
><DD
><P
><A
HREF="#sect_04_02_02_01"
>Section 4.2.2.1</A
></P
></DD
><DT
><A
NAME="locale"
></A
><B
>locale</B
></DT
><DD
><P
><A
HREF="#sect_03_03_06"
>Section 3.3.6</A
></P
></DD
><DT
><A
NAME="locate"
></A
><B
>locate</B
></DT
><DD
><P
><A
HREF="#sect_02_01_01"
>Section 2.1.1</A
></P
></DD
><DT
><A
NAME="logic"
></A
><B
>logic flow</B
></DT
><DD
><P
><A
HREF="#sect_01_05_04"
>Section 1.5.4</A
></P
></DD
><DT
><A
NAME="loginshell"
></A
><B
>login shell</B
></DT
><DD
><P
><A
HREF="#sect_01_02_02_02_01"
>Section 1.2.2.2.1</A
></P
></DD
></DL
></DIV
><DIV
CLASS="glossdiv"
><H1
CLASS="glossdiv"
><A
NAME="M"
></A
>M</H1
><DL
><DT
><A
NAME="menu"
></A
><B
>menu</B
></DT
><DD
><P
><A
HREF="#sect_09_06"
>Section 9.6</A
></P
></DD
><DT
><A
NAME="metachars"
></A
><B
>metacharacters</B
></DT
><DD
><P
><A
HREF="#sect_04_01_02"
>Section 4.1.2</A
></P
></DD
></DL
></DIV
><DIV
CLASS="glossdiv"
><H1
CLASS="glossdiv"
><A
NAME="N"
></A
>N</H1
><DL
><DT
><A
NAME="nestedifs"
></A
><B
>nested if statements</B
></DT
><DD
><P
><A
HREF="#sect_07_02_03"
>Section 7.2.3</A
></P
></DD
><DT
><A
NAME="noglob"
></A
><B
>noglob</B
></DT
><DD
><P
><A
HREF="#sect_02_03_02"
>Section 2.3.2</A
></P
></DD
><DT
><A
NAME="non-interactive-edit"
></A
><B
>non-interactive editing</B
></DT
><DD
><P
><A
HREF="#sect_05_03"
>Section 5.3</A
></P
></DD
><DT
><A
NAME="non-interactive"
></A
><B
>non-interactive shell</B
></DT
><DD
><P
><A
HREF="#sect_01_02_02_02_03"
>Section 1.2.2.2.3</A
></P
></DD
><DT
><A
NAME="non-login"
></A
><B
>non-login shell</B
></DT
><DD
><P
><A
HREF="#sect_01_02_02_02_02"
>Section 1.2.2.2.2</A
></P
></DD
><DT
><A
NAME="numcomp"
></A
><B
>numeric comparisons</B
></DT
><DD
><P
><A
HREF="#sect_07_01_02_02"
>Section 7.1.2.2</A
></P
></DD
></DL
></DIV
><DIV
CLASS="glossdiv"
><H1
CLASS="glossdiv"
><A
NAME="O"
></A
>O</H1
><DL
><DT
><A
NAME="options"
></A
><B
>options</B
></DT
><DD
><P
><A
HREF="#sect_03_06_01"
>Section 3.6.1</A
></P
></DD
><DT
><A
NAME="outsep"
></A
><B
>output field separator</B
></DT
><DD
><P
><A
HREF="#sect_06_03_02_01"
>Section 6.3.2.1</A
></P
></DD
><DT
><A
NAME="outrecsep"
></A
><B
>output record separator</B
></DT
><DD
><P
><A
HREF="#sect_06_03_02_02"
>Section 6.3.2.2</A
></P
></DD
></DL
></DIV
><DIV
CLASS="glossdiv"
><H1
CLASS="glossdiv"
><A
NAME="P"
></A
>P</H1
><DL
><DT
><A
NAME="paramexpand"
></A
><B
>parameter expansion</B
></DT
><DD
><P
><A
HREF="#sect_03_04_04"
>Section 3.4.5</A
></P
></DD
><DT
><A
NAME="path"
></A
><B
>PATH</B
></DT
><DD
><P
><A
HREF="#sect_02_01_02"
>Section 2.1.2</A
></P
></DD
><DT
><A
NAME="patmatch"
></A
><B
>pattern matching</B
></DT
><DD
><P
><A
HREF="#sect_04_03"
>Section 4.3</A
></P
></DD
><DT
><A
NAME="positionalparams"
></A
><B
>positionalparams</B
></DT
><DD
><P
><A
HREF="#sect_03_02_05"
>Section 3.2.5</A
>, <A
HREF="#sect_11_01_03"
>Section 11.1.3</A
></P
></DD
><DT
><A
NAME="posix"
></A
><B
>POSIX</B
></DT
><DD
><P
><A
HREF="#sect_01_02_01"
>Section 1.2.1</A
></P
></DD
><DT
><A
NAME="posixmode"
></A
><B
>POSIX mode</B
></DT
><DD
><P
><A
HREF="#sect_01_02_02_02_05"
>Section 1.2.2.2.5</A
></P
></DD
><DT
><A
NAME="primexps"
></A
><B
>primary expressions</B
></DT
><DD
><P
><A
HREF="#sect_07_01_01_01"
>Section 7.1.1.1</A
></P
></DD
><DT
><A
NAME="printenv"
></A
><B
>printenv</B
></DT
><DD
><P
><A
HREF="#sect_03_02_01_01"
>Section 3.2.1.1</A
></P
></DD
><DT
><A
NAME="printf"
></A
><B
>printf</B
></DT
><DD
><P
><A
HREF="#sect_01_05_05"
>Section 1.5.5</A
>, <A
HREF="#sect_06_03_06"
>Section 6.3.6</A
></P
></DD
><DT
><A
NAME="processsubst"
></A
><B
>process substitution</B
></DT
><DD
><P
><A
HREF="#sect_03_04_07"
>Section 3.4.8</A
></P
></DD
><DT
><A
NAME="profile"
></A
><B
>.profile</B
></DT
><DD
><P
><A
HREF="#sect_03_01_02_03"
>Section 3.1.2.3</A
></P
></DD
><DT
><A
NAME="prompt"
></A
><B
>prompt</B
></DT
><DD
><P
><A
HREF="#sect_03_01_03"
>Section 3.1.3</A
></P
></DD
></DL
></DIV
><DIV
CLASS="glossdiv"
><H1
CLASS="glossdiv"
><A
NAME="Q"
></A
>Q</H1
><DL
><DT
><A
NAME="quoting"
></A
><B
>quoting characters</B
></DT
><DD
><P
><A
HREF="#sect_03_03"
>Section 3.3</A
></P
></DD
><DT
><A
NAME=""
></A
><B
></B
></DT
><DD
><P
></P
></DD
></DL
></DIV
><DIV
CLASS="glossdiv"
><H1
CLASS="glossdiv"
><A
NAME="R"
></A
>R</H1
><DL
><DT
><A
NAME="redirection"
></A
><B
>redirection</B
></DT
><DD
><P
><A
HREF="#sect_01_04_01_07"
>Section 1.4.1.7</A
>, <A
HREF="#sect_03_06_02"
>Section 3.6.2</A
>, <A
HREF="#sect_08_02_03"
>Section 8.2.3</A
>, <A
HREF="#sect_09_04"
>Section 9.4</A
></P
></DD
><DT
><A
NAME="restricted"
></A
><B
>rbash</B
></DT
><DD
><P
><A
HREF="#sect_01_02_02_10"
>Section 1.2.2.10</A
></P
></DD
><DT
><A
NAME="read"
></A
><B
>read</B
></DT
><DD
><P
><A
HREF="#sect_08_02_01"
>Section 8.2.1</A
></P
></DD
><DT
><A
NAME="readonly"
></A
><B
>readonly</B
></DT
><DD
><P
><A
HREF="#sect_10_01_03"
>Section 10.1.3</A
></P
></DD
><DT
><A
NAME="regexpops"
></A
><B
>regular expression operators</B
></DT
><DD
><P
><A
HREF="#sect_04_01_02"
>Section 4.1.2</A
>, <A
HREF="#sect_05_02"
>Section 5.2</A
>, <A
HREF="#sect_06_02_04"
>Section 6.2.4</A
></P
></DD
><DT
><A
NAME="regexps"
></A
><B
>regular expressions</B
></DT
><DD
><P
><A
HREF="#sect_04_01"
>Section 4.1</A
></P
></DD
><DT
><A
NAME="remoteinvocation"
></A
><B
>remote invocation</B
></DT
><DD
><P
><A
HREF="#sect_01_02_02_02_06"
>Section 1.2.2.2.6</A
></P
></DD
><DT
><A
NAME="rmalias"
></A
><B
>removing aliases</B
></DT
><DD
><P
><A
HREF="#sect_03_05_02"
>Section 3.5.2</A
></P
></DD
><DT
><A
NAME="reservedvars"
></A
><B
>reserved variables</B
></DT
><DD
><P
><A
HREF="#sect_03_02_04"
>Section 3.2.4</A
></P
></DD
><DT
><A
NAME="return"
></A
><B
>return</B
></DT
><DD
><P
><A
HREF="#sect_11_01_03"
>Section 11.1.3</A
></P
></DD
></DL
></DIV
><DIV
CLASS="glossdiv"
><H1
CLASS="glossdiv"
><A
NAME="S"
></A
>S</H1
><DL
><DT
><A
NAME="sed"
></A
><B
>sed</B
></DT
><DD
><P
><A
HREF="#sect_05_01"
>Section 5.1</A
></P
></DD
><DT
><A
NAME="sedcmds"
></A
><B
>sed editing commands</B
></DT
><DD
><P
><A
HREF="#sect_05_01_02"
>Section 5.1.2</A
></P
></DD
><DT
><A
NAME="sedopts"
></A
><B
>sed options</B
></DT
><DD
><P
><A
HREF="#sect_05_01_02"
>Section 5.1.2</A
></P
></DD
><DT
><A
NAME="sedscript"
></A
><B
>sed script</B
></DT
><DD
><P
><A
HREF="#sect_05_03_02"
>Section 5.3.2</A
></P
></DD
><DT
><A
NAME="select"
></A
><B
>select</B
></DT
><DD
><P
><A
HREF="#sect_09_06"
>Section 9.6</A
></P
></DD
><DT
><A
NAME="set"
></A
><B
>set</B
></DT
><DD
><P
><A
HREF="#sect_03_02_01_02"
>Section 3.2.1.2</A
>, <A
HREF="#sect_03_06_01"
>Section 3.6.1</A
>, <A
HREF="#sect_11_01_04"
>Section 11.1.4</A
></P
></DD
><DT
><A
NAME="shift"
></A
><B
>shift</B
></DT
><DD
><P
><A
HREF="#sect_09_07"
>Section 9.7</A
></P
></DD
><DT
><A
NAME="signals"
></A
><B
>signals</B
></DT
><DD
><P
><A
HREF="#sect_12_01_01"
>Section 12.1.1</A
></P
></DD
><DT
><A
NAME="singlequotes"
></A
><B
>single quotes</B
></DT
><DD
><P
><A
HREF="#sect_03_03_03"
>Section 3.3.3</A
></P
></DD
><DT
><A
NAME="source"
></A
><B
>source</B
></DT
><DD
><P
><A
HREF="#sect_02_01_03"
>Section 2.1.3</A
></P
></DD
><DT
><A
NAME="specialparams"
></A
><B
>special parameters</B
></DT
><DD
><P
><A
HREF="#sect_03_02_05"
>Section 3.2.5</A
></P
></DD
><DT
><A
NAME="specialvars"
></A
><B
>special variables</B
></DT
><DD
><P
><A
HREF="#sect_03_02_05"
>Section 3.2.5</A
></P
></DD
><DT
><A
NAME="stderr"
></A
><B
>standard error</B
></DT
><DD
><P
><A
HREF="#sect_08_02_03_01"
>Section 8.2.3.1</A
></P
></DD
><DT
><A
NAME="stdin"
></A
><B
>standard input</B
></DT
><DD
><P
><A
HREF="#sect_08_02_03_01"
>Section 8.2.3.1</A
></P
></DD
><DT
><A
NAME="stdout"
></A
><B
>standard output</B
></DT
><DD
><P
><A
HREF="#sect_08_02_03_01"
>Section 8.2.3.1</A
></P
></DD
><DT
><A
NAME="stringcomp"
></A
><B
>string comparisons</B
></DT
><DD
><P
><A
HREF="#sect_07_01_02_03"
>Section 7.1.2.3</A
></P
></DD
><DT
><A
NAME="stty"
></A
><B
>stty</B
></DT
><DD
><P
><A
HREF="#sect_12_01_01"
>Section 12.1.1</A
></P
></DD
><DT
><A
NAME="submenu"
></A
><B
>submenu</B
></DT
><DD
><P
><A
HREF="#sect_09_06_02"
>Section 9.6.2</A
></P
></DD
><DT
><A
NAME="subshell"
></A
><B
>subshell</B
></DT
><DD
><P
><A
HREF="#sect_02_02_01"
>Section 2.2.1</A
></P
></DD
><DT
><A
NAME="substitution"
></A
><B
>substitution</B
></DT
><DD
><P
><A
HREF="#sect_10_03_03_01"
>Section 10.3.3.1</A
>, <A
HREF="#sect_10_03_03_03"
>Section 10.3.3.3</A
></P
></DD
><DT
><A
NAME="substring"
></A
><B
>substring</B
></DT
><DD
><P
><A
HREF="#sect_10_03_03_02"
>Section 10.3.3.2</A
></P
></DD
><DT
><A
NAME="syntax"
></A
><B
>syntax</B
></DT
><DD
><P
><A
HREF="#sect_01_04_01_01"
>Section 1.4.1.1</A
></P
></DD
></DL
></DIV
><DIV
CLASS="glossdiv"
><H1
CLASS="glossdiv"
><A
NAME="T"
></A
>T</H1
><DL
><DT
><A
NAME="tcsh"
></A
><B
>tcsh</B
></DT
><DD
><P
><A
HREF="#sect_01_01_02"
>Section 1.1.2</A
></P
></DD
><DT
><A
NAME="terminology"
></A
><B
>terminology</B
></DT
><DD
><P
><A
HREF="#sect_01_05_03"
>Section 1.5.3</A
></P
></DD
><DT
><A
NAME="then"
></A
><B
>then</B
></DT
><DD
><P
><A
HREF="#sect_07_01_01_02"
>Section 7.1.1.2</A
></P
></DD
><DT
><A
NAME="tilde-expand"
></A
><B
>tilde expansion</B
></DT
><DD
><P
><A
HREF="#sect_03_04_03"
>Section 3.4.4</A
></P
></DD
><DT
><A
NAME="transformations"
></A
><B
>transformation of variables</B
></DT
><DD
><P
><A
HREF="#sect_10_03_03"
>Section 10.3.3</A
></P
></DD
><DT
><A
NAME="traps"
></A
><B
>traps</B
></DT
><DD
><P
><A
HREF="#sect_12_02_01"
>Section 12.2.1</A
></P
></DD
><DT
><A
NAME="true"
></A
><B
>true</B
></DT
><DD
><P
><A
HREF="#sect_09_02_02_02"
>Section 9.2.2.2</A
></P
></DD
></DL
></DIV
><DIV
CLASS="glossdiv"
><H1
CLASS="glossdiv"
><A
NAME="U"
></A
>U</H1
><DL
><DT
><A
NAME="unalias"
></A
><B
>unalias</B
></DT
><DD
><P
><A
HREF="#sect_03_05_01"
>Section 3.5.1</A
>, <A
HREF="#sect_03_05_02"
>Section 3.5.2</A
></P
></DD
><DT
><A
NAME="unset"
></A
><B
>unset</B
></DT
><DD
><P
><A
HREF="#sect_03_02_02"
>Section 3.2.2</A
>, <A
HREF="#sect_10_02_03"
>Section 10.2.3</A
>, <A
HREF="#sect_11_01_04"
>Section 11.1.4</A
></P
></DD
><DT
><A
NAME="until"
></A
><B
>until</B
></DT
><DD
><P
><A
HREF="#sect_09_03"
>Section 9.3</A
></P
></DD
><DT
><A
NAME="userinput"
></A
><B
>user input</B
></DT
><DD
><P
><A
HREF="#sect_08_02_01"
>Section 8.2.1</A
>, <A
HREF="#sect_08_02_02"
>Section 8.2.2</A
></P
></DD
><DT
><A
NAME="usermsgs"
></A
><B
>user messages</B
></DT
><DD
><P
><A
HREF="#sect_08_01_01"
>Section 8.1.1</A
></P
></DD
></DL
></DIV
><DIV
CLASS="glossdiv"
><H1
CLASS="glossdiv"
><A
NAME="V"
></A
>V</H1
><DL
><DT
><A
NAME="variables"
></A
><B
>variables</B
></DT
><DD
><P
><A
HREF="#sect_03_02"
>Section 3.2</A
>, <A
HREF="#sect_10_01"
>Section 10.1</A
></P
></DD
><DT
><A
NAME="varexpand"
></A
><B
>variable expansion</B
></DT
><DD
><P
><A
HREF="#sect_03_04_04"
>Section 3.4.5</A
></P
></DD
><DT
><A
NAME="verbose"
></A
><B
>verbose</B
></DT
><DD
><P
><A
HREF="#sect_02_03_02"
>Section 2.3.2</A
></P
></DD
><DT
><A
NAME="vim"
></A
><B
>vi(m)</B
></DT
><DD
><P
><A
HREF="#sect_02_01_01"
>Section 2.1.1</A
></P
></DD
></DL
></DIV
><DIV
CLASS="glossdiv"
><H1
CLASS="glossdiv"
><A
NAME="W"
></A
>W</H1
><DL
><DT
><A
NAME="wait"
></A
><B
>wait</B
></DT
><DD
><P
><A
HREF="#sect_12_02_02"
>Section 12.2.2</A
></P
></DD
><DT
><A
NAME="whereis"
></A
><B
>whereis</B
></DT
><DD
><P
><A
HREF="#sect_02_01_01"
>Section 2.1.1</A
></P
></DD
><DT
><A
NAME="which"
></A
><B
>which</B
></DT
><DD
><P
><A
HREF="#sect_02_01_01"
>Section 2.1.1</A
></P
></DD
><DT
><A
NAME="while"
></A
><B
>while</B
></DT
><DD
><P
><A
HREF="#sect_09_02"
>Section 9.2</A
></P
></DD
><DT
><A
NAME="wildcards"
></A
><B
>wildcards</B
></DT
><DD
><P
><A
HREF="#sect_04_02_02_04"
>Section 4.2.2.3</A
></P
></DD
><DT
><A
NAME="wordanchor"
></A
><B
>word anchors</B
></DT
><DD
><P
><A
HREF="#sect_04_02_02_01"
>Section 4.2.2.1</A
></P
></DD
><DT
><A
NAME="wordsplit"
></A
><B
>word splitting</B
></DT
><DD
><P
><A
HREF="#sect_03_04_08"
>Section 3.4.9</A
></P
></DD
></DL
></DIV
><DIV
CLASS="glossdiv"
><H1
CLASS="glossdiv"
><A
NAME="X"
></A
>X</H1
><DL
><DT
><A
NAME="xtrace"
></A
><B
>xtrace</B
></DT
><DD
><P
><A
HREF="#sect_02_03_01"
>Section 2.3.1</A
>, <A
HREF="#sect_02_03_02"
>Section 2.3.2</A
></P
></DD
></DL
></DIV
><DIV
CLASS="glossdiv"
><H1
CLASS="glossdiv"
><A
NAME="Y"
></A
>Y</H1
></DIV
><DIV
CLASS="glossdiv"
><H1
CLASS="glossdiv"
><A
NAME="Z"
></A
>Z</H1
></DIV
></DIV
></DIV
></BODY
></HTML
>
